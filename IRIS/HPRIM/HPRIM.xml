<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2016.1.2 (Build 206U)" ts="2016-09-15 18:29:26">
<Class name="HPRIM.ContextSearch">
<Description>
Ensemble-specific version of context search methods.</Description>
<IncludeCode>Ensemble</IncludeCode>
<Super>%ZEN.Portal.ContextSearch</Super>
<System>4</System>
<TimeChanged>64176,65019.426433</TimeChanged>
<TimeCreated>61579,56265.914196</TimeCreated>

<Method name="MsgSource">
<Description><![CDATA[
Search method: MsgSource.<br/>
Execute a search for all Config Item names that are message sources.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pResults  Set tSC=$$$OK, N=0
	Try {
		&sql(DECLARE msgSource CURSOR FOR
		     SELECT %EXACT(SourceConfigName)
		     INTO :tSource
		     FROM Ens.MessageHeader
		     GROUP BY SourceConfigName
		)
		&sql(OPEN msgSource)
		Quit:SQLCODE
		&sql(FETCH msgSource)
		While (SQLCODE = 0) {
			If $L(tSource) {
				Set N=N+1, pResults(N)=tSource
			}
			&sql(FETCH msgSource)
		}
		&sql(CLOSE msgSource)
	} Catch {
		Set tSC = $$$SystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="MsgTarget">
<Description><![CDATA[
Search method: MsgTarget.<br/>
Execute a search for all Config Item names that are message targets.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pResults  Set tSC=$$$OK, N=0
	Try {
		&sql(DECLARE msgTarget CURSOR FOR
		     SELECT %EXACT(TargetConfigName)
		     INTO :tTarget
		     FROM Ens.MessageHeader
		     GROUP BY TargetConfigName
		)
		&sql(OPEN msgTarget)
		Quit:SQLCODE
		&sql(FETCH msgTarget)
		While (SQLCODE = 0) {
			If $L(tTarget) {
				Set N=N+1, pResults(N)=tTarget
			}
			&sql(FETCH msgTarget)
		}
		&sql(CLOSE msgTarget)
	} Catch {
		Set tSC = $$$SystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnterpriseMessageSource">
<Description><![CDATA[
Search method: EnterpriseMessageSource.<br/>
Execute a search for all message sources in the Message Bank.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pResults  Set tSC=$$$OK, N=0
	Try {
		&sql(DECLARE entMsgSource CURSOR FOR
		     SELECT %EXACT(SourceConfigName)
		     INTO :tSource
		     FROM Ens_Enterprise_MsgBank.MessageHeader
		     GROUP BY SourceConfigName
		)
		&sql(OPEN entMsgSource)
		Quit:SQLCODE
		&sql(FETCH entMsgSource)
		While (SQLCODE = 0) {
			If $L(tSource) {
				Set N=N+1, pResults(N)=tSource
			}
			&sql(FETCH entMsgSource)
		}
		&sql(CLOSE entMsgSource)
	} Catch {
		Set tSC = $$$SystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnterpriseMessageTarget">
<Description><![CDATA[
Search method: EnterpriseMessageTarget.<br/>
Execute a search for all message targets in the Message Bank.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pResults  Set tSC=$$$OK, N=0
	Try {
		&sql(DECLARE entMsgTarget CURSOR FOR
		     SELECT %EXACT(TargetConfigName)
		     INTO :tTarget
		     FROM Ens_Enterprise_MsgBank.MessageHeader
		     GROUP BY TargetConfigName
		)
		&sql(OPEN entMsgTarget)
		Quit:SQLCODE
		&sql(FETCH entMsgTarget)
		While (SQLCODE = 0) {
			If $L(tTarget) {
				Set N=N+1, pResults(N)=tTarget
			}
			&sql(FETCH entMsgTarget)
		}
		&sql(CLOSE entMsgTarget)
	} Catch {
		Set tSC = $$$SystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ProductionItems">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Set tProduction = $get(pParms("productionName"))
	Set tType = $select($get(pParms("targets")): -$$$eHostTypeService, $get(pParms("sources")): -$$$eHostTypeOperation, $get(pParms("services")): $$$eHostTypeService, 1: "")
	Set tRS = ##class(%ResultSet).%New("Ens.Config.Production:EnumerateConfigItems")
	Set tStatus = tRS.%Execute(tProduction, tType)
	If $$$ISERR(tStatus) Quit tStatus

	If tProduction = "" {
		Set tIndex = 0
		Try {
			Set tIndex = $i(^||%ISC.Ens.ProdItems)
			While tRS.%Next(.tStatus) {
				Set tConfigName = tRS.%Get("ConfigName")
				If tConfigName '= "" Set ^||%ISC.Ens.ProdItems(tIndex,tConfigName) = ""
			}
			If $$$ISERR(tStatus) Quit
			Set tConfigName = ""
			Set pResults = 0
			For {
				Set tConfigName = $order(^||%ISC.Ens.ProdItems(tIndex,tConfigName))
				Quit:(tConfigName = "")
				Set pResults = pResults + 1
				Set pResults(pResults) = tConfigName
			}
		}
		Catch ex {
			Set tStatus = $$$SystemError
		}
		If tIndex Kill ^||%ISC.Ens.ProdItems(tIndex)
	}
	Else {
		While tRS.%Next(.tStatus) {
			Set pResults($i(pResults)) = tRS.%Get("ConfigName")
		}
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="CharacterSets">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	
	// initialize with our own names
	Set pResults(1) = "Binary"
	Set pResults(2) = "Native"
	Set n = 2
	
	// get the locale information
	Set loc=##class(%SYS.NLS.Locale).%New()
	Set tabs=loc.XLTTables
	
	// get the character set external names
	Set x="" 
	For { 
		Set x=$O(^%SYS("NLS","Chs","Ext-Int",x))  
		Quit:x=""  
		if ..InLocale($G(^%SYS("NLS","Chs","Ext-Int",x)),tabs) {	
			Set n = n + 1
			Set pResults(n) = x 
		}
	}
	
	// get the character set internal names (table names)
	For i=1:1:$LL(tabs) {
		Set n = n + 1
		Set pResults(n) = "@"_$List(tabs,i)
	}
	
	Quit tStatus
]]></Implementation>
</Method>

<Method name="InLocale">
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String,pTabs:%List</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set found=0
	For i=1:1:$LL(pTabs) {
		Quit:found=1
		If $List(pTabs,i)=pName { Set found=1 }
	}
	Quit found
]]></Implementation>
</Method>

<Method name="ProductionCategories">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Set tProduction = $get(pParms("productionName"))
	If tProduction '= "" {
		Set tRS = ##class(%ResultSet).%New("Ens.Config.Production:EnumerateCategories")
		Set tStatus = tRS.%Execute(tProduction)
		If $$$ISERR(tStatus) Quit tStatus

		While tRS.%Next(.tStatus) {
			Set pResults($i(pResults)) = tRS.%Get("Category")
		}
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="MonitorCategories">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""
	Set tRS = ##class(%ResultSet).%New("Ens.Enterprise.MonitorRole:EnumerateMonitorRoles")
	Set tStatus = tRS.%Execute()
	While tRS.%Next(.tStatus) {
		Set tCategories = tRS.%Get("CategoryList")
		If tCategories '= "" {
			For i=1:1:$LENGTH(tCategories,",") {
				Set tCategory = $PIECE(tCategories,",",i)
				If (tCategory '= "") {
					Set tCatArray(tCategory) = ""
				}
			}
		}
	}
	Set tCat = ""
	Set tCatList = ""
	For {
		Set tCat = $order(tCatArray(tCat))
		Quit:(tCat = "")
		Set pResults($I(pResults)) = tCat
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="BasicDatatypes">
<Description>
Execute a search for a basic subset of Cach√© datatypes</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults
	Kill %objlasterror

	Try {
		For type = "%Boolean","%Date","%Decimal","%Double","%Integer","%Numeric","%String","%Time","%TimeStamp" {
			Set pResults($increment(count)) = type
		}
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="SearchTableProperties">
<Description>
Search method to list the properties for a SearchTable specified in
the "searchTable" parameter.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Kill pResults
	Set tMask = $ZCVT(pSearchKey,"U")
	Set n = 0
	
	Try {
		Set tSearchTable = $get(pParms("searchTable"))
		If (tSearchTable '= "") && ##class(%Dictionary.CompiledClass).%ExistsId(tSearchTable) {
			If $classmethod(tSearchTable,"%Extends","Ens.VDoc.SearchTable") {
				Kill %objlasterror
				Set tRS = ##class(%ResultSet).%New("Ens.VDoc.SearchTableGenerator:EnumerateSearchProps")
				If '$IsObject(tRS) Set tSC = %objlasterror Quit
				Set tSC = tRS.Execute(tSearchTable)
				If $$$ISOK(tSC) {
					For {
						If 'tRS.Next(.tSC) Quit
						Set tName = tRS.Get("Name")
						If (tMask'="") && ($E(tName,1,$L(tMask))'=tMask) Continue
						Set n = n+1
						Set pResults(n) = tName
					}
				}
			}
			ElseIf $classmethod(tSearchTable,"%Extends","Ens.CustomSearchTable") {
				Set tSC = $classmethod(tSearchTable,"ListAllProperties",.tIndexedProps,.tProps)
				If $$$ISERR(tSC) Quit
				Set pTopResults = $listlength(tIndexedProps)
				For i=1:1:pTopResults {
					Set pTopResults(i) = $listget(tIndexedProps,i)
				}
				Set pResults = $listlength(tProps)
				For i=1:1:pResults {
					Set pResults(i) = $listget(tProps,i)
				}
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="getDisplayList">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Kill pResults
	Set tMask = $ZCVT(pSearchKey,"U")
	Set N = 0
	Try {
		Set tHostId = $get(pParms("host"))  Quit:""=tHostId
		Set tProp = $get(pParms("prop"))  Quit:""=tProp
		&sql(SELECT Classname INTO :tClass from Ens_Config.Item WHERE Id = :tHostId)
		Quit:""=$G(tClass)||SQLCODE
		Set tDisplayList=$$$GetPropertyParameter(tClass,tProp,"DISPLAYLIST")
		Set:""=tDisplayList tValueList=$$$GetPropertyParameter(tClass,tProp,"VALUELIST")
		Quit:""=tDisplayList
		Set tSep=$E(tDisplayList)  Quit:""=tSep
		Set tCount=$L(tDisplayList,tSep)
		For i=1:1:tCount { Set tItem=$ZStrip($P(tDisplayList,tSep,i),"<>W")  Continue:""=tItem
			Set N = N+1
			Set pResults(N) = tItem
		}
	}
	Catch {
		Set tSC = $$$ERROR($$$CacheError,$ZE)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="MessageProperties">
<Description><![CDATA[
Display all the properties of a given object, including deep objects.
The method accepts the following parameters: <ul>
<li>	shallow = 0|1 -- only retrieve properties reflected in the class description.
This invokes ..<method>Properties</method>(). The default is 0.</li>
<li>	class -- the name of the class to retrieve properties for.</li>
<li>	sqlFields = 0|1 -- only retrieve properties which have an SQL projection (i.e. are stored or SQLComputed).</li></ul>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Kill pResults
	
	#Define hasSQLProjection(%class,%prop) ($$$comMemberKeyGet(%class,$$$cCLASSproperty,%prop,$$$cPROPstorable) || $$$comMemberKeyGet(%class,$$$cCLASSproperty,%prop,$$$cPROPsqlcomputed))
	
	Try {
		Set tClass = $get(pParms("class"))
		Set tClass= $$$NormalizeClassname(tClass)
		Set tSQLFields = +$get(pParms("sqlFields"))
		Set tShallow = +$get(pParms("shallow"))
		Set tMask = $ZCVT(pSearchKey,"U")
		Set n = 0
		
		If tShallow {
			Set tSC = ..Properties(.pCaption, .pTopResults, .pResults, .pParms, pSearchKey)
			If tSQLFields {
				Set tKey = ""
				For {
					Set tKey = $order(pTopResults(tKey),1,tProp)
					Quit:(tKey = "")
					If '$$$hasSQLProjection(tClass,tProp) {
						Kill pTopResults(tKey)
					}
				}
				If $data(pTopResults)<10 Kill pTopResults
				For {
					Set tKey = $order(pResults(tKey),1,tProp)
					Quit:(tKey = "")
					If '$$$hasSQLProjection(tClass,tProp) {
						Kill pResults(tKey)
					}
				}
				If $data(pResults)<10 Kill pResults
			}
			Quit
		}
		If tClass '= "" {
			Kill %objlasterror
			Set tRS = ##class(%ResultSet).%New("Ens.VDoc.Utils:EnumerateDocContents")
			If '$IsObject(tRS) Set tSC = %objlasterror Quit
			Set tSC = tRS.Execute(tClass,"source",,,0,1)
			If $$$ISERR(tSC) Quit
			
			While tRS.Next() {
				Set tName = tRS.Get("Property")
				If (tMask'="") && ($ZCVT($E(tName,1,$L(tMask)),"U")'=tMask) Continue
				If tSQLFields && '$$$hasSQLProjection(tClass,tName) Continue
				
				Set tResults(tName) = ""
			}
			Set tName = ""
			For {
				Set tName = $order(tResults(tName))
				Quit:(tName = "")
				Set n = n + 1
				Set pResults(n) = tName
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="VDocClasses">
<Description><![CDATA[
Search method to list Virtual Document classes based on the EnumerateVDocs query in 
<class>Ens.VDoc.Interface</class>. The search method accepts three parameters: <ul>
<li>	segmented = 0|1 -- if 1, display classes which extend EnsLib.EDI.Segmented. Default is 0.</li>
<li>	abstract = 0|1 -- if 1, display abstract classes. Default is 0.</li>
<li>	persistent = 0|1 -- if 1, require the class to be persistent. Default is 1.</li></ul>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults
	Set pCaption = $$$Text("Classes")
	
	Try {
		Set tSegmented = $get(pParms("segmented"), 0)
		Set tPersistent = $get(pParms("persistent"), 1)
		Set tAbstract = $get(pParms("abstract"), 0)
		Set tRS = ##class(%ResultSet).%New("Ens.VDoc.Interface:EnumerateVDocs")
		Set tStatus = tRS.Execute(tPersistent, tAbstract)
		If $$$ISERR(tStatus) Quit
		Set n = 0
		
		While tRS.Next() {
			Set tClass = tRS.Get("Name")
			If tSegmented && '$classmethod(tClass, "%Extends", "EnsLib.EDI.Segmented") {
				Continue
			}
			Set n = n + 1
			Set pResults(n) = tClass
		}
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="SubclassOf">
<Description>
This is a simpler method than the similar-purposed Classes() method in %ZEN.Portal.ContextSearch.
This method provides more accurate results in simpler cases. 
It is useful when you just want to list all subclasses.
Let the value of the "class" parameter be the name of the superclass whose subclasses you want to list.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Kill pResults
	Try {
		Set n = 0
		Set tClass = $G(pParms("class"))
		Set tAbstract = ''$G(pParms("abstract"))
		If tClass '= "" {
			Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
			Set tSC = tRS.Execute(tClass)
			While (tRS.Next()) {
				Set cls = tRS.Data("Name")
	 			If ('tAbstract) && ($$$comClassKeyGet(cls,$$$cCLASSabstract)) Continue
				Set n = n+1
				Set pResults(n) = cls
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnterpriseClients">
<Description>
Get a list of known Enterprise Clients</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults
	Try {
		Set tRS = ##class(%SQL.Statement).%ExecDirect(,"SELECT ID FROM Ens_Enterprise.MonitorClient ORDER BY ID")
		Set tCount = 0
		While tRS.%Next() {
			Set tCount = tCount + 1
			Set pResults(tCount) = tRS.ID
		}
	}
	Catch {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="BusinessPartners">
<Description>
Get a list of Business Partner profiles</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK  Kill pResults
	Try {
		Kill %objlasterror
		Set tRS = ##class(%ResultSet).%New("Ens.Config.BusinessPartner:List")
		If '$IsObject(tRS) Set tSC = %objlasterror Quit
		Set tSC = tRS.Execute()  Quit:$$$ISERR(tSC)
		Set n=0  While (tRS.Next(.tSC)) { Set n = n+1
			Set pResults(n) = tRS.Get("PartnerName")
		}
	}
	Catch {
		Set tSC = $$$ERROR($$$CacheError,$ZE)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SSLConfigs">
<Description>
Get a list of SSL/TLS Configurations</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK  Kill pResults
	Try {
		Set tConfigs = $$ListSSLConfigs^%SYS.SECURITY("Server")_","_$$ListSSLConfigs^%SYS.SECURITY("Client")
		// alphabetize and remove possible empty string before inserting into pResults
		For i=1:1:$L(tConfigs,",") {
			Set:$P(tConfigs,",",i)'="" tResults($P(tConfigs,",",i)) = ""
		}
		Set tName = ""
		For {
			Set tName = $O(tResults(tName)) Quit:tName=""
			Set pResults($i(n)) = tName
		}
	}
	Catch {
		Set tSC = $$$ERROR($$$CacheError,$ZE)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="Credentials">
<Description>
Get a list of Credential definitions</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK  Kill pResults
	Try {
		Kill %objlasterror
		Set tRS = ##class(%ResultSet).%New("Ens.Config.Credentials:List")
		If '$IsObject(tRS) Set tSC = %objlasterror Quit
		Set tSC = tRS.Execute()  Quit:$$$ISERR(tSC)
		Set n=0  While (tRS.Next(.tSC)) { Set n = n+1
			Set pResults(n) = tRS.Get("ID")
		}
	}
	Catch {
		Set tSC = $$$ERROR($$$CacheError,$ZE)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecordMaps">
<Description>
Get a list of Record Map definitions</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK  Kill pResults
	Try {
		Kill %objlasterror
		Set tRS = ##class(%ResultSet).%New("EnsLib.RecordMap.RecordMap:List")
		If '$IsObject(tRS) Set tSC = %objlasterror Quit
		Set tSC = tRS.Execute()  Quit:$$$ISERR(tSC)
		Set n=0  While (tRS.Next(.tSC)) { Set n = n+1
			Set pResults(n) = tRS.Get("name")
		}
	}
	Catch {
		Set tSC = $$$ERROR($$$CacheError,$ZE)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RuleNames">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK  
	Kill pResults
	Try {
		Set tSC = ##class(Ens.Projection.Rule).GetRuleNameList(.list)  Quit:$$$ISERR(tSC)
		Set n=0, tName=""  For { Set tName=$O(list(tName)) Quit:tName=""  
			Set n = n+1
			Set pResults(n) = tName
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RoutingRuleNames">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK  
	Kill pResults
	Try {
		Set tSC = ##class(Ens.Projection.Rule).GetRuleNameList(.list)  Quit:$$$ISERR(tSC)
		Set n=0, tName=""  For { Set tName=$O(list(tName)) Quit:tName="" 
		
			// sort out whether the name is an alias or a class name and get the class name
			Set tValue = $G(list(tName))
			Set tClass = $S(tValue="":tName,1:tValue)
			
			// see if the class has a RuleAssistClass that indicates a routing rule
			Set tAssist = $$$GetClassParameter(tClass,"RuleAssistClass")
			If ((tAssist [ "EnsLib.HL7.MsgRouter") || (tAssist [ "EnsLib.MsgRouter")) {
				Set n = n+1
				Set pResults(n) = tName
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ScheduleNames">
<Description>
Get a list of named schedule strings</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK  Kill pResults
	Try {
		Set tRS = ##class(%ResultSet).%New()
		Set tSC = tRS.Prepare("SELECT Name FROM Ens_Util.Schedule")  Quit:$$$ISERR(tSC)
		Set tSC = tRS.Execute()  Quit:$$$ISERR(tSC)
		Set n=0  While (tRS.Next(.tSC)) { Set n = n+1
			Set pResults(n) = "@"_tRS.Data("Name")
		} 
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SearchTableClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK  
	Kill pResults
	Try {
		Set n = 0
		Set tHostClass = $get(pParms("host"))  Quit:""=tHostClass
		Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
		Do tRS.Execute("Ens.SearchTableBase")
		While (tRS.Next()) { 
			Set tSearchClass = tRS.Data("Name")
			If ($$$defClassKeyGet(tSearchClass,$$$cCLASSabstract)) Continue
			If ((tHostClass = "EnsLib.MsgRouter.RoutingEngine") || (##class(EnsPortal.Utils).IsSubclass(tHostClass,"EnsLib.MsgRouter.RoutingEngine"))) {
				Set n = n + 1
				Set pResults(n) = tSearchClass
			}
			Else { // get the DOCCLASS value for this search table class; see if it the same or a subclass of the document class for this host 
				Set tDocClass = $$$GetClassParameter(tSearchClass, "DOCCLASS")
				If (tHostClass [ "EnsLib.EDI.") { // document class EnsLib.EDI.*.Document
					Set tMatch = ((tDocClass = $P(tHostClass,".",1,3)_".Document") || (##class(EnsPortal.Utils).IsSubclass(tDocClass, $P(tHostClass,".",1,3)_".Document")))
				}
				ElseIf (tHostClass [ "EnsLib.HL7.") { // document class EnsLib.HL7.Message
					Set tMatch = ((tDocClass = "EnsLib.HL7.Message") || (##class(EnsPortal.Utils).IsSubclass(tDocClass, "EnsLib.HL7.Message")))
				}
				ElseIf (tHostClass [ "EnsLib.XML.") { // document class Ens.StreamContainer
					Set tMatch = ((tDocClass = "Ens.StreamContainer") || (##class(EnsPortal.Utils).IsSubclass(tDocClass, "Ens.StreamContainer")))
				}
				Else { // by default include all search table classes
					Set tMatch = 1
				}
				If (tMatch) {
					Set n = n + 1
					Set pResults(n) = tSearchClass
				}
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SchemaCategories">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK  
	Kill pResults
	Try {
		Set n = 0
		Set tHostClass = $get(pParms("host"))  Quit:""=tHostClass
		If (tHostClass [ "HPRIM.EDI.") {
			Set tRS = ##class(%ResultSet).%New($P(tHostClass,".",1,3)_".Document:EnumerateTypeCategories")
		}
		Else {
			Quit
		}
		Do tRS.Execute()
		While (tRS.Next()) { 
			Set n = n + 1
			Set pResults(n) = tRS.Data("Category")
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="BusinessServices">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tStatus = tRS.%Execute("Ens.BusinessService")
	If $$$ISERR(tStatus) Quit tStatus

	While tRS.%Next(.tStatus) {
		Set tName = tRS.%Get("Name")
		If '##class(%Dictionary.CompiledClass).%ExistsId(tName) Continue
		If ($$$defClassKeyGet(tName,$$$cCLASSabstract)) Continue
		Set pResults($i(pResults)) = tName
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="BusinessMetrics">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tStatus = tRS.%Execute("Ens.BusinessMetric")
	If $$$ISERR(tStatus) Quit tStatus

	While tRS.%Next(.tStatus) {
		Set tName = tRS.%Get("Name")
		If '##class(%Dictionary.CompiledClass).%ExistsId(tName) Continue
		If ($$$defClassKeyGet(tName,$$$cCLASSabstract)) Continue
		Set pResults($i(pResults)) = tName
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="BusinessProcesses">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tStatus = tRS.%Execute("Ens.BusinessProcess")
	If $$$ISERR(tStatus) Quit tStatus

	While tRS.%Next(.tStatus) {
		Set tName = tRS.%Get("Name")
		If '##class(%Dictionary.CompiledClass).%ExistsId(tName) Continue
		If ($$$defClassKeyGet(tName,$$$cCLASSabstract)) Continue
		Set pResults($i(pResults)) = tName
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="BusinessComponents">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tStatus = tRS.%Execute("Ens.BusinessProcess")
	If $$$ISERR(tStatus) Quit tStatus
	
	While tRS.%Next(.tStatus) {
		Set tName = tRS.Data("Name")  
		If '##class(%Dictionary.CompiledClass).%ExistsId(tName) Continue
		Set cdef = ##class(%Dictionary.ClassDefinition).%OpenId(tName)
		If ($IsObject(cdef) && (cdef.Abstract '= 1) && ..IsComponent(tName)) { // It's a valid non-abstract component classs
			Set pResults($i(pResults)) = tName
		}
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="IsComponent">
<Description>
Given a business process class name, return if it is a component</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tRet = 0
	Set $ZT = "Trap"
	Do {
		Set tRet = $zobjclassmethod(pClass,"IsComponent")
	} While(0)

Exit
	Quit tRet
Trap
	#; the error is most likely that this host does not
	#; support the IsComponent API.
 	Set $ZT=""
	Set tRet = 0
	Goto Exit
]]></Implementation>
</Method>

<Method name="BusinessOperations">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tStatus = tRS.%Execute("Ens.BusinessOperation")
	If $$$ISERR(tStatus) Quit tStatus

	While tRS.%Next(.tStatus) {
		Set tName = tRS.%Get("Name")
		If '##class(%Dictionary.CompiledClass).%ExistsId(tName) Continue
		If ($$$defClassKeyGet(tName,$$$cCLASSabstract)) Continue
		Set pResults($i(pResults)) = tName
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="WorkflowOperations">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tStatus = tRS.%Execute("EnsLib.Workflow.Operation")
	If $$$ISERR(tStatus) Quit tStatus

	While tRS.%Next(.tStatus) {
		Set tName = tRS.%Get("Name")
		If '##class(%Dictionary.CompiledClass).%ExistsId(tName) Continue
		If ($$$defClassKeyGet(tName,$$$cCLASSabstract)) Continue
		Set pResults($i(pResults)) = tName
	}
	
	// Also include the superclass
	Set pResults($i(pResults)) = "EnsLib.Workflow.Operation"
	
	Quit tStatus
]]></Implementation>
</Method>

<Method name="AllBusinessHosts">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tStatus1 = tRS.%Execute("Ens.BusinessService")
	If $$$ISOK(tStatus1) {
		While tRS.%Next(.tStatus1) {
			Set tName = tRS.%Get("Name")
			If '##class(%Dictionary.CompiledClass).%ExistsId(tName) Continue
			If ($$$defClassKeyGet(tName,$$$cCLASSabstract)) Continue
			Set pResults($i(pResults)) = tName
		}
	}
	Kill tRS

	Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tStatus2 = tRS.%Execute("Ens.BusinessProcess")
	If $$$ISOK(tStatus2) {
		While tRS.%Next(.tStatus2) {
			Set tName = tRS.%Get("Name")
			If '##class(%Dictionary.CompiledClass).%ExistsId(tName) Continue
			If ($$$defClassKeyGet(tName,$$$cCLASSabstract)) Continue
			Set pResults($i(pResults)) = tName
		}
	}
	Kill tRS

	Set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tStatus3 = tRS.%Execute("Ens.BusinessOperation")
	If $$$ISOK(tStatus3)
	While tRS.%Next(.tStatus3) {
		Set tName = tRS.%Get("Name")
		If '##class(%Dictionary.CompiledClass).%ExistsId(tName) Continue
		If ($$$defClassKeyGet(tName,$$$cCLASSabstract)) Continue
		Set pResults($i(pResults)) = tName
	}
	Kill tRS

	For s = tStatus1,tStatus2,tStatus3 {
		If $$$ISERR(s) Set tStatus = $system.Status.AppendStatus(tStatus,s)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="ListEnsembleUsers">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Set tRS = ##class(%ResultSet).%New("%SQL.Manager.CatalogPriv:Users")
	Set tStatus = tRS.%Execute()
	If $$$ISERR(tStatus) Quit tStatus

	While tRS.%Next(.tStatus) {
		Set tName = tRS.%Get("USERNAME")
		If ((tName = "_Ensemble") || (tName = "_PUBLIC") || (tName = "_SYSTEM") || (tName = "CSPSystem") || (tName = "UnknownUser")) {
			Continue
		}
		Set pResults($i(pResults)) = tName
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="ClassPackages">
<Description>
List the names of all class packages in the hierarchy.
Exclude the InterSystems internal packages csp, CSPX, Ens, EnsLib, EnsPortal, HS, and any packages whose name starts with "%".</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Set depth=1, pkg(0)=""
	Set tRS(depth) = ##class(%ResultSet).%New("%Dictionary.PackageDefinition:SubPackage")
	Set tSC = tRS(depth).%Execute(pkg(depth-1))
	While depth {
		If 'tRS(depth).%Next(.tSC) || $$$ISERR(tSC) {
			Kill tRS(depth)
			Set depth=depth-1
			Continue
		}
		Set tName = tRS(depth).%Get("Name")  
		Continue:$Case(tName,"":1,"csp":1,"CSPX":1,"Ens":1,"EnsLib":1,"EnsPortal":1,"HS":1,:$S("%"=$E(tName):1,1:0))
		Set tPrev=pkg(depth-1)
		Set pkg(depth) = $S(tPrev="":tName,1:tPrev_"."_tName)
		Set pResults($I(pResults)) = pkg(depth)
		Set depth=depth+1
		Set tRS(depth) = ##class(%ResultSet).%New("%Dictionary.PackageDefinition:SubPackage")
		Set tSC = tRS(depth).%Execute(pkg(depth-1))
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="TCPLocalInterfaces">
<Description>
Get a list of link-local interface addresses</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(%IO.SocketCommon).GetLocalInterfaces(.pResults)
]]></Implementation>
</Method>

<Method name="ManagedAlertSources">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Set tStatement = ##class(%SQL.Statement).%New()
	Set tStatus = tStatement.%Prepare("SELECT DISTINCT SourceConfigName FROM Ens_Alerting.ManagedAlert ORDER BY SourceConfigName")
	If $$$ISERR(tStatus) Quit tStatus
	Set tExactStatement = ##class(%SQL.Statement).%New()
	Set tStatus = tExactStatement.%Prepare("SELECT TOP 1 %EXACT(SourceConfigName) As ExactSource FROM Ens_Alerting.ManagedAlert WHERE SourceConfigName = ?")
	If $$$ISERR(tStatus) Quit tStatus
	Set tSourceRS = tStatement.%Execute()
	Set tCount = 0
	While tSourceRS.%Next() {
		Set tExactRS = tExactStatement.%Execute(tSourceRS.SourceConfigName)
		If tExactRS.%Next() {
			Set tCount = tCount + 1
			Set pResults(tCount) = tExactRS.ExactSource
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ManagedAlertGroups">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""
	
	Set tCount = 0
	Set tGroup = ""
	For {
		Set tGroup = $order(^Ens.Alerting.ManagedAlertI("AlertGroups",tGroup))
		Quit:(tGroup = "")

		Set tCount = tCount + 1
		Set pResults(tCount) = tGroup
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SDSGetProductions">
<Description>
Search method to get Productions for the System Default Settings page.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	Set tSC = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Try {
		Set tCount = 1
		Set pResults(1) = "*"
		Set gbl = $Name(@##class(EnsPortal.DefaultSetting).GetTempGlobal()@("work","productions"))
		Set tProd = ""
		For  {
		 	Set tProd = $O(@gbl@(tProd))
		 	Quit:tProd=""
			Set tCount = tCount + 1
			Set pResults(tCount) = tProd
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="SDSGetProductionItems">
<Description>
Search method to get all items of a single Production or of all Productions for the System Default Settings page.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Try {
		Set tCount = 1
		Set pResults(1) = "*"
		Set gbl = $Name(@##class(EnsPortal.DefaultSetting).GetTempGlobal()@("work","items"))
		Set tItem = ""
		For  {
		 	Set tItem = $O(@gbl@(tItem))
		 	Quit:tItem=""
			Set tCount = tCount + 1
			Set pResults(tCount) = tItem
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}

	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SDSGetHostClasses">
<Description>
Search method to get all host class names for the System Default Settings page.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Try {
		Set tCount = 1
		Set pResults(1) = "*"
		Set gbl =$Name(@##class(EnsPortal.DefaultSetting).GetTempGlobal()@("work","classes"))
		Set tClass = ""
		For  {
		 	Set tClass = $O(@gbl@(tClass))
		 	Quit:tClass=""
			Set tCount = tCount + 1
			Set pResults(tCount) = tClass
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}

	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SDSGetSettings">
<Description>
Search method to get all setting names for the System Default Settings page.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""

	Try {
		Kill tOutList
		// Stuff in EnsColumns that is *NOT* a setting name
		For tName = "Age","Alerting","Basic","Count","Created","Detail","Dev","Duration","Error","False","ID","Info","IsActive","IsCompleted","IsError","Job","Label","LastAction","LastStartTime","LastStopTime","Legend","Level","Method","New","Options","Password","Production","Property","Queue","Reason","Roles","Session","SessionId","Status","TaskId","True","Units","Users" {
			Set tOutList(tName) = ""
		}
		// Item's core settings
		Try {
			Set tObj = ##class(Ens.Config.Item).%New("Ens.Config.Item")
			Kill tList
			Set tSC = tObj.GetStaticSettings(.tList)
		}
		Catch {
		}
		Set tIndex = ""
		For {
			Set tIndex = $O(tList(tIndex))
			Quit:tIndex=""
			Set tName = $Li(tList(tIndex),2)
			Set:tName'="" tOutList(tName) = ""
		}
		// Production's core settings
		Try {
			Set tObj = ##class(Ens.Config.Production).%New()
			Kill tList
			Set tSC = tObj.GetStaticSettings(.tList)
		}
		Catch {
		}
		Set tIndex = ""
		For {
			Set tIndex = $O(tList(tIndex))
			Quit:tIndex=""
			Set tName = $Li(tList(tIndex),2)
			Set:tName'="" tOutList(tName) = ""
		}

		// Get settings from domain EnsColumns less the exclusion list
		Set tLang = %session.Language
		Set tCount = 0
		Set tSett = "@"
		For  {
		 	Set tSett = $O(^CacheMsg("EnsColumns","en",tSett))
		 	Quit:tSett=""
		 	Continue:$D(tOutList(tSett))
		 	// Concatenate localized name if different
		 	Set tLoc = $G(^CacheMsg("EnsColumns",tLang,tSett))
		 	If (tLoc'="")&&(tLoc'=tSett) Set tFull = tSett_" ("_tLoc_")"
		 	Else  Set tFull = tSett
			Set tCount = tCount + 1
			Set pResults(tCount) = tFull
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}

	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ProductionAlertGroups">
<Description>
Context Search to get all the AlertGroups defined for config items in a specified production.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""
	Set tProduction = $get(pParms("productionName"))

	If (tProduction '= "") {
		Set tCount = 0
		Set tGroup = ""
		For {
			Set tGroup = $order(^Ens.Config.ItemI("AlertGroup",tProduction,tGroup))
			Quit:(tGroup = "")

			Set tCount = tCount + 1
			Set pResults(tCount) = tGroup
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="MessageBankNodes">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""
	Try {
		Set tRS = ##class(%SQL.Statement).%ExecDirect(,"SELECT ID,Name FROM Ens_Enterprise_MsgBank.Node ORDER BY ID DESC")
		Set tCount = 0
		While tRS.%Next() {
			Set tCount = tCount + 1
			Set pResults(tCount) = "+"_tRS.ID_":"_tRS.Name
		}
		Set tRS = ##class(%SQL.Statement).%ExecDirect(,"SELECT ID,Name FROM Ens_Enterprise_MsgBank.Node ORDER BY TimeUpdated DESC")
		If tRS.%Next() {Set pTopResults(1) = "+"_tRS.ID_":"_tRS.Name}
	}
	Catch {
		Set tStatus = $$$SystemError
	}
	
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetEnsembleNamespaces">
<Description>
Context Search to get all the Ensemble namespaces</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pCaption:%String,*pTopResults,*pResults,&pParms:%String,pSearchKey:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Kill pResults, pTopResults
	Set pCaption = ""
	Set tCount = 0, tNS = ""
	For {
		Set tNS = $O(^%SYS("Ensemble","InstalledNamespace",tNS))
		Quit:(tNS = "")
		Set tCount = tCount + 1
		Set pResults(tCount) = tNS
	}
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Adapter.TCPAdapter">
<Description>
As specialized ASTM 2-way Adapter based on TCPInboundAdapter</Description>
<ClassType/>
<IncludeCode>HPRIME1238</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.TCP.InboundAdapter</Super>
<System>4</System>
<TimeChanged>64175,60618</TimeChanged>
<TimeCreated>59318,79308.949</TimeCreated>

<Property name="ResponseTimeout">
<Description>
Number of seconds to wait for a response to begin arriving back from the remote system after sending a request. Setting the timeout to -1 means wait forever.</Description>
<Type>%Numeric</Type>
<InitialExpression>15</InitialExpression>
<Parameter name="MINVAL" value="-1"/>
</Property>

<Property name="OutSeparators">
<Description><![CDATA[
Separator characters to use when sending outbound ASTM documents.<p>
'Flex' means copy the separators from inbound messages, or use the native separators of the outbound message if outbound goes first.]]></Description>
<Type>%String</Type>
<InitialExpression>"Flex"</InitialExpression>
<Parameter name="MAXLEN" value="5"/>
<Parameter name="MINLEN" value="5"/>
</Property>

<Parameter name="SETTINGS">
<Default>ResponseTimeout,OutSeparators</Default>
</Parameter>

<Property name="%InSeparators">
<Description>
Remember separators from last input document</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="5"/>
<Parameter name="MINLEN" value="5"/>
</Property>

<UDLText name="T">
<Content><![CDATA[/* Override InitialExpression */
]]></Content>
</UDLText>

<Property name="Port">
<Description>
TCP Port to connect to. To listen instead of intiating a connection, configure AllowedIPAddresses=!IPaddr.</Description>
<Type>Ens.DataType.TCPAgentPort</Type>
<InitialExpression>10001</InitialExpression>
<Required>1</Required>
</Property>

<UDLText name="T">
<Content><![CDATA[/* Override InitialExpression */
]]></Content>
</UDLText>

<Property name="Terminators">
<Type>%String</Type>
<InitialExpression>$C(10)</InitialExpression>
</Property>

<Property name="%EOT">
<Description>
Flag to not send outbound until EOT is received, if in EOTOPTIONAL mode</Description>
<Type>%Boolean</Type>
<Internal>1</Internal>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="%ENQ">
<Description>
Flag to remember ENQ was sent but more data was received</Description>
<Type>%Boolean</Type>
<Internal>1</Internal>
</Property>

<Property name="%FrameNum">
<Description>
Flag to hold current frame number in case it crosses message boundaries, if in EOTOPTIONAL mode</Description>
<Type>%Integer</Type>
<Internal>1</Internal>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="%EventList">
<Description>
List of events for $system.Socket.Select()</Description>
<Type>%List</Type>
<Internal>1</Internal>
</Property>

<Property name="%SyncReplyHeader">
<Description>
Flag for outbound messages that require a synchronous reply</Description>
<Type>Ens.MessageHeader</Type>
<Internal>1</Internal>
</Property>

<Property name="OutQueueName">
<Type>%String</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="ZeroFrameNum">
<Description>
If FrameNum begins at 0</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="getOutQueueName">
<Description>
Output Queue name is ConfigName:RemoteIPAddr. This allows JobPerConnection jobs to receive targeted output messages and to resume after a shutdown</Description>
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<Implementation><![CDATA[..BusinessHost.%ConfigName_":"_$P($S("!"=$E(..IOAddr):$E(..IOAddr,2,*), 1:$P(..IOAddr,"<-",2)),$S(..IOAddr["|":"|",1:":"))
]]></Implementation>
</Method>

<Method name="OnConnected">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK, (tENQ,tACK)="", $ZT="Trap"
	Do {
		Set tSC=..initEventList(.tAlsoConfig)  Quit:$$$ISERR(tSC)

		Read tENQ#1:0  Set tTimedOut='$Test
		If (tTimedOut&&..%EOT || ($$$ACK=tENQ && ..%ENQ)) && '$IsObject(..%SyncReplyHeader) {
			$$$catTRACE("connwait","No ENQ pending, looking for outbound messages to send")
			#; Check for non-empty queue; no need to lock because it's just us listening
			While $G($$$EnsQueue(..OutQueueName,0,"count")) || (tAlsoConfig&&$G($$$EnsQueue(..BusinessHost.%ConfigName,0,"count"))) {
				#; We think there's an ASTM doc waiting in our queue; try to acquire the line for sending
				If $$$ACK=tENQ {
					Set tENQ=$$$ENQ, tACK=$$$ACK, ..%ENQ=""
				} Else {
					Write $$$ENQ,*-3
					$$$catTRACE("protocol","Wrote <ENQ> request to send outbound message")
					While 1 {
						If -1=..ResponseTimeout {
							Read tACK#1
						} Else {
							Read tACK#1:..ResponseTimeout  Set tTimedOut='$Test
							If tTimedOut Set tSC=$$$ERROR($$$EnsErrTCPReadTimeoutExpired,..ResponseTimeout,"ASTM ENQ ACK","binary")  Quit
						}
						Quit:$$$ACK=tACK
						Continue:$C(13,10)[tACK
						If $$$ENQ=tACK {
							#; Assume we are the LIS and the remote is the device; therefore always yield (per ASTM 1381-95)
							Set tENQ=tACK
							$$$sysTRACE("Received ENQ in response to our ENQ; yielding and ACK'ing their ENQ")
						} ElseIf $$$STX=tACK {
							#; they are sending a fresh message without ENQ first; process it but remember we sent the ENQ for when they eventually ACK it.
							Set tENQ=tACK
							Set ..%ENQ=$$$ENQ
							$$$catTRACE("protocol","Got <STX> in response to our ENQ, continuing to read next message")
						} Else {
							Set tSC=$$$ERROR($$$EnsErrGeneral,"Received unexpected ASTM ENQ ACK character: Ascii "_$$$MapCtlChar(tACK))
						}
						Quit
					} Quit:$$$ISERR(tSC)||$Case(tACK, $$$ENQ:1, $$$STX:1, :0)
				}
				$$$catTRACE("protocol","Got <ACK> for our ENQ, dequeuing message to send")
				Set tSC = ##class(Ens.Queue).DeQueue(..OutQueueName,.tOutHdr,0)  Quit:$$$ISERR(tSC)
				If '$IsObject(tOutHdr) && tAlsoConfig {
					#; also check for message (from Operation) on shared queue if JobPerConnection=0 or N/A
					Set tSC = ##class(Ens.Queue).DeQueue(..BusinessHost.%ConfigName,.tOutHdr,0)  Quit:$$$ISERR(tSC)
					Quit:'$IsObject(tOutHdr)
				}
				Do tOutHdr.SetStatus($$$eMessageStatusDelivered)
				If tOutHdr.MessageBodyClassName'="" {
					Set tOutDoc = $classmethod(tOutHdr.MessageBodyClassName,"%OpenId",tOutHdr.MessageBodyId)
					If '$IsObject(tOutDoc)||'tOutDoc.%Extends("HPRIM.EDI.E1238.Document") Set tOutDoc=$$$NULLOREF  $$$LOGERROR("ASTM message body does not exist for Msg Header #"_tOutHdr.%Id()_" with body class "_tOutHdr.MessageBodyClassName)
				} Else {
					Set tOutDoc=$$$NULLOREF  $$$LOGERROR("No MessageBody classname for MessageHeader #"_tOutHdr.%Id())
				}
				If '$IsObject(tOutDoc) {
					Do tOutHdr.SetStatus($$$eMessageStatusError)
					Quit
				}
				#; Now we have an outbound ASTM document; send it
				Set tSeparators=$Case(..OutSeparators, "":tOutDoc.Separators, "Flex":$S(""'=..%InSeparators:..%InSeparators, 1:tOutDoc.Separators), :..OutSeparators)
				$$$sysTRACE("Sending ASTM doc "_tOutHdr.MessageBodyId_" on "_..IOAddr)
				Set tSC=tOutDoc.OutputToIOStream(..Socket,tSeparators,..SetFrameNum(),..ResponseTimeout)
				Set ..BusinessHost.%LastHandledTime=$ZH
				If $$$ISERR(tSC) {
					If ..IsWriteError(tSC)||..IsReadError(tSC) {
						Set tSC=$$$ERROR($$$EnsErrInConnectionLost,"ASTM Write", ..Device, $$$StatusDisplayString(tSC))
						Do ..Disconnect()
					}
					Do tOutHdr.SetStatus($$$eMessageStatusError)
					$$$LOGSTATUS(tSC)
					$$$ASAVEIOLOGENTRY(tSC,"after TCP WriteASTM error on "_..IOAddr,tOutDoc)
					Quit ; if error sending, try to receive instead
				} Else {
					Do tOutHdr.SetStatus($$$eMessageStatusCompleted)
					$$$ASAVEIOLOGENTRY(tSC,"after TCP WriteASTM on "_..IOAddr,tOutDoc)
					Kill $$$EnsActiveMessage($$$SystemName_":"_$Job)
					Set ..%SyncReplyHeader=tOutHdr
					Kill tOutHdr
				}
			} ; end queue While loop
			If $$$ISERR(tSC) {
				If $$$IsdefObject(tOutHdr)&&(""'=tOutHdr.ReturnQueueName) {
					Set tSC = tOutHdr.NewErrorResponse(.tResponseHeader,tSC)  Quit:$$$ISERR(tSC)
					Set tSC = ##class(Ens.Queue).EnQueue(tResponseHeader)  Quit:$$$ISERR(tSC)
				} Else { Quit }
			}
			If $Case(tACK, $$$ENQ:0, $$$STX:0, :1) {
				$$$catTRACE("connwait","Beginning read for ENQ with timeout "_..CallInterval_" on "_..IOAddr)
				Set tReadyList=$System.Socket.Select(..%EventList,..CallInterval)
				If $LL(tReadyList) {
					$$$catTRACE("protocol","Woke due to event(s) "_$LG(tReadyList,1)_"("_$Case($LF(..%EventList,$LG(tReadyList,1)),1:"TCP "_..IOAddr,2:"queue "_..OutQueueName,3:"queue "_..BusinessHost.%ConfigName,:"")_"), "_$LG(tReadyList,2)_"("_$Case($LF(..%EventList,$LG(tReadyList,2)),1:"TCP "_..IOAddr,2:"queue "_..OutQueueName,3:"queue "_..BusinessHost.%ConfigName,:"")_"), "_$LG(tReadyList,3)_"("_$Case($LF(..%EventList,$LG(tReadyList,3)),1:"TCP "_..IOAddr,2:"queue "_..OutQueueName,3:"queue "_..BusinessHost.%ConfigName,:"")_").")
					#; Clean out any bytes previously written to the queue event device(s)
					Set tDev=$LG(..%EventList,2)  If ""'=tDev && $LF(tReadyList,tDev) { Use tDev  try { For { Read tC#1:0  Quit:'$Test } } catch {}  Use ..Device }
					Set tDev2=$LG(..%EventList,3)  If ""'=tDev2 && (tDev2'=tDev) && $LF(tReadyList,tDev2) { Use tDev2  try { For { Read tC#1:0  Quit:'$Test } } catch {}  Use ..Device }
					If $LG(tReadyList)=..Device {
						Read tENQ#1:0  Set tTimedOut='$Test
						Quit:tTimedOut||""=tENQ
					}
				}
			}
			// Handshake in other cases
			set tSChandshake=..SendHandShake(.tENQ,.tACK)
			if (tSChandshake) Quit
		} ElseIf tTimedOut&&'..%EOT {
			$$$catTRACE("connwait","Not checking for outbound messages because in EOTOPTIONAL mode and no EOT received")
		}
		$$$ANEWINIOLOGENTRY($$$OK,"TCP ReadASTM on :"_..IOAddr,"HPRIM.EDI.E1238.Document")

		If $$$ENQ=tENQ {
			Set ..%FrameNum=1, ..%ENQ="" ; got an ENQ - reset frame sequence counter
		} ElseIf $$$STX=tENQ {
			If ..BusinessHost.%GetParameter("EOTOPTIONAL") { Set ..%EOT=0 } ; prevent ENQ send until EOT is received
			Else { Set ..%FrameNum=1 } ; when we get multiple messages with EOT but no ENQ between, reset the frame num for each message
			$$$catTRACE("protocol","Got <STX>, waiting to receive EOT")
		} Else {
			If $$$EOT=tENQ && ..BusinessHost.%GetParameter("EOTOPTIONAL") {
				Set ..%EOT=1, ..%FrameNum=1
				$$$catTRACE("protocol","Got <EOT>, ready to output messages")
			} ElseIf ""'=tENQ {
				Read tLine#32000:0
				$$$LOGWARNING("Expected <ENQ>; got: "_$$$MapCtlChars(tENQ_tLine))
				$$$ACLOSEIOLOGENTRY(tSC,"Expected <ENQ> on "_..IOAddr,tENQ_tLine)
			}
			Quit
		}
		#; Got an ENQ (or STX); ACK the ENQ and read message
		If tENQ=$$$ENQ { Write $$$ACK,*-3  $$$catTRACE("protocol","Got <ENQ>, sent <ACK>") }
		Else { $$$catTRACE("protocol","Got "_$$$MapCtlChars(tENQ)_", not sending <ACK>") }
		Set tSC=..BusinessHost.ProcessInput("",.tDoc)
		If $$$ISERR(tSC) {
			If ..IsWriteError(tSC)||..IsReadError(tSC) {
				Set tSC=$$$ERROR($$$EnsErrInConnectionLost,"ASTM Write",..IOAddr,$$$StatusDisplayString(tSC))
				Do ..Disconnect()
			}
			#; Returning error status will cause this listener job to terminate
			$$$ACLOSEIOLOGENTRY(tSC,"after TCP ProcessInput error on :"_..IOAddr,$$$NULLOREF)

			#; resolve Ensemble-to-Ensemble race conditions after ENQ-ENQ collision where we both yielded: hang a moment if we were not the initiator
			If tACK=tENQ && $$$StatusEquals(tSC,$$$EnsErrTCPReadTimeoutExpired) {
				Hang:""=..%outIPAddr 0.5 ; listen-for-connection mode
				Set tSC=$$$OK
			}
			Quit
		}
		If $$$IsdefObject(tDoc) Set ..%InSeparators=tDoc.Separators
		If $IsObject(..BusinessHost.IOLogEntry) && ..BusinessHost.IOLogEntry.IsEmpty() { Set ..BusinessHost.IOLogEntry=$$$NULLOREF } ; don't log empty IO if no error
		Else { $$$ACLOSEIOLOGENTRY(tSC,"after TCP ProcessInput on :"_..IOAddr,$$$NULLOREF) }
	} While 0
Exit
	#; Returning error status would cause this listener job to terminate
	If $$$ISERR(tSC) {
		#; Never quit the listener, but drop the connection on unrecognized error
		If ..Connected&&..StayConnected { $$$LOGERROR("Disconnecting due to "_$$$StatusDisplayString(tSC)) Set tSC=$$$OK  Do ..Disconnect() }
		If $$$ISERR(tSC) $$$LOGSTATUS(tSC)
	}
	Quit $$$OK
Trap
	Set $ZT="", tZE=$ZE
	If $G(tZE)["<READ>" || ($G(tZE)["<WRITE>") {
		Set tSC=$$$ERROR($$$EnsErrInConnectionLost,"ASTM Read",..IOAddr,tZE)
		If ""=tENQ Set tTxt=$$$StatusText(tSC), tSC=$$$OK  If ..StayConnected<0 { $$$LOGWARNING(tTxt) } ElseIf ..%logConnections { $$$LOGINFO(tTxt) } Else { $$$sysTRACE(tTxt) } ; change error to info if lost connection with no data
		Do ..Disconnect()
	} Else {
		Set tSC=$$$SystemError
	}
	Goto Exit
]]></Implementation>
</Method>

<Method name="Disconnect">
<Implementation><![CDATA[
	If ..Connected Do ..BusinessHost.%Parser.Reset()
	Do ##super()
	try {
		Set tDev=$LG(..%EventList,2)  If ""'=tDev { Do ##class(Ens.Queue).ClearEventDevice(..OutQueueName,tDev)  Close tDev }
		Set tDev2=$LG(..%EventList,3)  If ""'=tDev2 { Do ##class(Ens.Queue).ClearEventDevice(..BusinessHost.%ConfigName,tDev2)  Close tDev2 }
	} catch {
		Set tSC1=$$$SystemError
	}
	Set i%OutQueueName="", ..%EventList=""
]]></Implementation>
</Method>

<Method name="initEventList">
<Internal>1</Internal>
<FormalSpec>*pAlsoConfig:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Re-initialize %EventList if needed
	Set tOutQueue=..getOutQueueName()
	Set pAlsoConfig=(("!"=$E(..AllowedIPAddresses)||'..JobPerConnection))
	If tOutQueue'=..OutQueueName {
		Set tOldDev=$LG(..%EventList,2)
		If ""'=tOldDev { Do ##class(Ens.Queue).ClearEventDevice(..OutQueueName,tOldDev)  Close tOldDev }
		Set i%OutQueueName=tOutQueue
	}
	Set tSC=..OpenEventDevice(.tDev)  Quit:$$$ISERR(tSC) tSC
	Set tSC=##class(Ens.Queue).SetEventDevice(tOutQueue,tDev)  Quit:$$$ISERR(tSC) tSC
	Set tOldDev2=$LG(..%EventList,3)
	If pAlsoConfig {
		If ..%EventList'=$LB(..Device,tOutQueue,..BusinessHost.%ConfigName) {
			If ""=tOldDev2 {
				Set tSC=..OpenEventDevice(.tDev2)  Quit:$$$ISERR(tSC) tSC
				Set tSC=##class(Ens.Queue).SetEventDevice(..BusinessHost.%ConfigName,tDev2)  Quit:$$$ISERR(tSC) tSC
			} Else {
				Set tDev2=tOldDev2 ; always our config name; no need to reopen or reset queue
			}
			Set ..%EventList=$LB(..Device,tDev,tDev2)
		}
	} Else {
		If ..%EventList'=$LB(..Device,tOutQueue) {
			If ""'=tOldDev2 { Do ##class(Ens.Queue).ClearEventDevice(..BusinessHost.%ConfigName,tOldDev2)  Close tOldDev2 }
			Set ..%EventList=$LB(..Device,tDev)
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OpenEventDevice">
<Internal>1</Internal>
<FormalSpec>*pDevice:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK, pDevice=""
	try {
		For tPort=20001:1:30000 {
			Set tEventDevice="|TCP|"_tPort
			Open tEventDevice:(:tPort:"SA-D"):0
			If $Test Set pDevice=tEventDevice Quit
		}
		Set:""=pDevice tSC=$$$ERROR($$$EnsErrGeneral,"Could not find a free port between 20001 and 30000 for $System.Socket.Select()") 
	} catch {
		Set tSC=$$$SystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendHandShake">
<Description>
Code to send initial ENQ and read ACK and send EOT</Description>
<FormalSpec><![CDATA[&tENQ:%String,&tACK:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Maintaining dialog
	use ..Device
	Write $$$ENQ,*-3
	Set tSC=$$$OK
	$$$catTRACE("protocol","Wrote <ENQ> request to send outbound message")
	While 1 {
		If -1=..ResponseTimeout {
			Read tACK#1
		} Else {
			Read tACK#1:..ResponseTimeout  Set tTimedOut='$Test
			If tTimedOut Set tSC=$$$ERROR($$$EnsErrTCPReadTimeoutExpired,..ResponseTimeout,"A2.2 ENQ ACK","binary")  Quit
		}
		Quit:$$$ACK=tACK
	}
	Write $$$EOT,*-3
	s ..%SyncReplyHeader = $$$NULLOREF
	quit tSC
]]></Implementation>
</Method>

<Method name="SetFrameNum">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	if (..ZeroFrameNum)
	{
		q -1
	}
	else
	{
		q -2
	}
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Document">
<Description>
Represents an Interchange or a TransactionSet. FunctionalGroups are represented as Segments within an Interchange.</Description>
<ClassType>persistent</ClassType>
<IncludeCode>HPRIME1238</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,EnsLib.EDI.Document,EnsLib.EDI.Segmented,HPRIM.EDI.E1238.MsgBodyMethods</Super>
<System>4</System>
<TimeChanged>64176,66543.762487</TimeChanged>
<TimeCreated>59816,48502.780779</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="DOMAIN">
<Description>
Use our own domain for localization</Description>
<Default>Ensemble</Default>
</Parameter>

<Parameter name="DOCCLASSNAME">
<Default>E1238 Document</Default>
</Parameter>

<Parameter name="DOCCLASSFULLNAME">
<Default>ASC E1238 EDI Document</Default>
</Parameter>

<Parameter name="DOCSHORTNAME">
<Default>E1238</Default>
</Parameter>

<Parameter name="DEFSEARCHCLASS">
<Description>
Name of the default SearchTable indexing class used in UI choices and MessageBank submissions </Description>
<Default>HPRIM.EDI.E1238.SearchTable</Default>
</Parameter>

<Parameter name="SCHEMACLASS">
<Description>
Name of the associated schema class and, after a colon, the schema class code that represents a DocType</Description>
<Default>HPRIM.EDI.E1238.Schema:DS</Default>
</Parameter>

<Parameter name="EXTENTSIZE">
<Default>2000000</Default>
</Parameter>

<Index name="Extent">
<Type>bitmap</Type>
<Extent>1</Extent>
</Index>

<Index name="OriginalDocId">
<Properties>OriginalDocId</Properties>
</Index>

<Property name="Envelope">
<Description>
'Envelope' information for the ASTM document message. Used in propagating info about the return Service address for reply documents</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Separators">
<Description>
All 5 Separators as a String,FLDSEP_SUBFLDSEP_REPSEP_ESCSEP_COMSEP_SEGSEP</Description>
<Type>%String</Type>
<Transient>1</Transient>
<Parameter name="MAXLEN" value="5"/>
<Parameter name="MINLEN" value="5"/>
</Property>

<Property name="FieldSeparator">
<Description>
Data-field separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
</Property>

<Property name="SubFieldSeparator">
<Description>
Data-subfield separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
</Property>

<Property name="RepetitionSeparator">
<Description>
Repetition separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
</Property>

<Property name="EscapeSeparator">
<Description>
Escape separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
</Property>

<Property name="ComponentSeparator">
<Description>
Sub-element component separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
</Property>

<Property name="Name">
<Description>
Raw type name of document</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set data=$G($$$vaSegmentGbl($G($$$vaExtentGbl({ID},"segs",2),0)))  Set {Name}=$$$vaDataTypeName(data) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="TypeVersion">
<Description>
Raw type version name of message found at H:13 in message content</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set data=$G($$$vaSegmentGbl($G($$$vaExtentGbl({ID},"segs",1),0)))  Set {TypeVersion}=$$$vaDataTypeVersion(data) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Identifier">
<Description>
Unique document identification string found in document content</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set data=$G($$$vaSegmentGbl($G($$$vaExtentGbl({ID},"segs",1),0)))  Set {Identifier}=$$$vaDataDocIdentifier(data) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="SegCount">
<Description>
Count of segments composing this document</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {SegCount}=$G($$$vaExtentGbl({ID},"segs"),0) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="RawContent">
<Description>
The raw text content of the document. Note that this is a truncated version suitable for use in SQL results and visual inspection,
but not a complete or definitive representation of the document.</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {RawContent}=##class({%%CLASSNAME}).getSegsAsString({ID}) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
<Parameter name="MAXLEN" value="10000"/>
</Property>

<Property name="DocTypeCategory">
<Description>
the category portion of the DocType</Description>
<Type>%String</Type>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="DocTypeName">
<Description>
Stored raw document type name ; the secondary type name portion of the DocType</Description>
<Type>%String</Type>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="FullSize">
<Description><![CDATA[
Size in bytes of the message content (assuming 1-byte segment terminators, including segments >32k)]]></Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="%maps">
<Description>
A local array of orefs
"orefs" - a local map of integer ids to segment objects
And either a subscript into ^CacheTemp for this object's LVD maps (for notes on LVD implementation see EnsEDI.inc)
or local storage for these additional maps:
"runtimeIndex" - array for runtime index to segment; will always be defined unless mapRuntimePath is defined
"runtimePath" - array for runtime path to segment
"bidirectionalLink" - array for runtime path and index linkage</Description>
<MultiDimensional>1</MultiDimensional>
<Transient>1</Transient>
</Property>

<Property name="%ClonedId">
<Description><![CDATA[
Id of parent object if we are a mutable clone (also used as a legal subscript that will result in $G(xxx(..%ClonedId))="" instead of a <SUBSCRIPT> error)]]></Description>
<Type>%CacheString</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="FieldSeparatorGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$FLDSEP(..Separators)
]]></Implementation>
</Method>

<Method name="SubFieldSeparatorGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$SSSEP(..Separators)
]]></Implementation>
</Method>

<Method name="RepetitionSeparatorGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$REPSEP(..Separators)
]]></Implementation>
</Method>

<Method name="EscapeSeparatorGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$ESCSEP(..Separators)
]]></Implementation>
</Method>

<Method name="ComponentSeparatorGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$COMSEP(..Separators)
]]></Implementation>
</Method>

<Method name="NameGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..GetValueAt("2:0")_$S("M"=..GetValueAt("2:0"):"-"_..GetValueAt("2:2"),1:"")
]]></Implementation>
</Method>

<Method name="TypeVersionGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..GetValueAt("1:13","|^~\&")
]]></Implementation>
</Method>

<Method name="IdentifierGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..GetValueAt("1:3")
]]></Implementation>
</Method>

<Method name="SegCountGet">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	If $D($$$vaM("runtimeIndex")) Quit $$$vaM("runtimeIndex")
	Set count=0,path="" For  Set path=$O($$$vaM("runtimePath",path)) Quit:path=""  Set count=count+1
	Quit count
]]></Implementation>
</Method>

<Method name="RawContentGet">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..OutputToString()
]]></Implementation>
</Method>

<Method name="FullSizeGet">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Do:'$D($$$vaM("runtimeIndex"))&&$D($$$vaM("runtimePath")) ..buildRuntimeIndexFromPath()
	Set tLen=0 For i=1:1:$G($$$vaM("runtimeIndex")) { Set tSeg=..getSegmentByIndex(i)
		If 'tSeg.IsChildHolder(.tRef) { Set tLen=tLen+tSeg.FullSize+1 }
		Do ..commitSegmentByIndex(i)
	}
	Quit tLen
]]></Implementation>
</Method>

<Method name="GetFullSize">
<ClassMethod>1</ClassMethod>
<FormalSpec>pMsgId</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tLen=0 For i=1:1:$$$vaExtentGbl(pMsgId,"segs") {
		#; Add segment size: - 5 separators + 2 terminator
		Set tLen = tLen + $L($$$vaSegmentGbl($$$vaExtentGbl(pMsgId,"segs",i))) - 2
		#; Get extra from any segs > 32k
		For j=1:1 { Quit:'$D($$$vaSegmentGbl($$$vaExtentGbl(pMsgId,"segs",i),j),extra)
			Set tLen = tLen + $L(extra)
		}
	}
	Quit tLen
]]></Implementation>
</Method>

<Method name="GetNextIndex">
<Description>
Gets the next index in an array</Description>
<FormalSpec><![CDATA[pPath:%String,pIndex:%String,&pStatus:%Status=$$$OK]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set f=$F(pPath,"()")  If 'f Set pStatus=$$$ERROR($$$EnsErrGeneral,"Can't iterate on SegmentPath '"_pPath_"'") Quit ""
	Set tSegmentPath=$P(pPath,":",1)
	If f-1>$L(tSegmentPath) { ; '()' was found in PropertyPath not SegmentPath
		Set tPropertyPath=$P(pPath,":",2)
		Set tSegObj=..GetSegmentAt(tSegmentPath,.pStatus) Quit:$$$ISERR(pStatus) ""
		Quit tSegObj.GetNextIndex(tPropertyPath,pIndex,.pStatus)
	} Else {
		Set tHead=$E(pPath,1,f-2), tLen=$L(tHead)
		Quit:"("=tHead $S(+pIndex<..SegCount:pIndex+1,1:"") ; iterate by index if path is just "()"
		Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
		If '$D($$$vaM("loopIndex",tHead)) {
			#; Build LoopIndex node
			Set path=tHead For { Set path=$O($$$vaM("runtimePath",path))  Quit:path=""
				Quit:$E(path,1,tLen)'=tHead
				Set $$$vaM("loopIndex",tHead,$E(path,tLen+1,$F(path,")",tLen)-2))=""
			}
			If '$D($$$vaM("loopIndex",tHead)) Set $$$vaM("loopIndex",tHead)=0
		}
		Quit $O($$$vaM("loopIndex",tHead,pIndex))
	}
]]></Implementation>
</Method>

<Method name="GetNextGroupPath">
<Description>
Gets the next path in a group</Description>
<FormalSpec><![CDATA[pGroup:%String,pPath:%String,&pStatus:%Status=$$$OK]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Quit:$$$vaIsIndex(pGroup) ""
	If pGroup[":"||($L(pPath)<$L(pGroup)) Set pStatus=$$$ERROR($$$EnsErrGeneral,"Can't iterate in Group '"_pGroup_"' on Path '"_pPath_"'") Quit ""
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
	Set nextpath=$O($$$vaM("runtimePath",pPath))
	Quit:$E(nextpath,1,$L(pGroup))'=pGroup||$Case($E(nextpath,$L(pGroup)+1),"(":0,".":0,:1) ""
	Quit nextpath
]]></Implementation>
</Method>

<Method name="SetValueAt">
<FormalSpec>pValue:%String,pSegmentPropertyPath:%String,pAction:%String="set",pKey:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If pSegmentPropertyPath["()" {
		Set tSC=$$$OK
		Set tFind=$F(pSegmentPropertyPath,"()")
		Set tHead=$E(pSegmentPropertyPath,1,tFind-3), tTail=$E(pSegmentPropertyPath,tFind,*)
		Set k=$P(pKey,","), pKey=$P(pKey,",",2,$L(pKey,","))
		If k { Set tSC=..SetValueAt(.pValue,tHead_"("_(k)_")"_tTail,pAction,pKey) Quit:$$$ISERR(tSC) }
		Else {
			Set i="" For { Set i=..GetNextIndex(tHead_"()",i) Quit:i=""
				Set tNewPath=tHead_"("_(i)_")"_tTail
				Set tSC=..SetValueAt(.pValue,tNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
			}
		}
		Quit tSC
	}
	Set tGrpPath=$P(pSegmentPropertyPath,":"), tPropPath=$P(pSegmentPropertyPath,":",2)
	Set tSegPath=..GetNextGroupPath(tGrpPath,tGrpPath)
	If ""'=tSegPath { ; if there are group sub-elements
		For {
			Set tNewPath=tSegPath_$S(""=tPropPath:"",1:":"_tPropPath)
			Set tSC=..SetValueAt(.pValue,tNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
			Set tSegPath=..GetNextGroupPath(tGrpPath,tSegPath,.tSC) Quit:$$$ISERR(tSC)
			Quit:""=tSegPath
		}
		Quit tSC
	} Else {
		Quit:(pAction="remove")&&(""=tPropPath) ..RemoveSegmentAt(tGrpPath)
		Set tSegObj=..GetMutableSegmentAt(tGrpPath,.tSC)  Quit:$$$ISERR(tSC) tSC  $$$ASSERT($IsObject(tSegObj))
		Quit tSegObj.SetValueAt(.pValue,tPropPath,pAction,pKey)
	}
]]></Implementation>
</Method>

<Method name="GetValueAt">
<FormalSpec>pSegmentPropertyPath:%String,pSeparators:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK, tSeparators=$G(pSeparators,..Separators)
	Set tSegmentPath=$P(pSegmentPropertyPath,":"), tPropertyPath=$P(pSegmentPropertyPath,":",2)
	If ""=tPropertyPath&&(tSegmentPath["*") {
		Quit:$Case(tSegmentPath,"*":1,"(*)":1,:0) ..SegCount
		Set tLen=$L(tSegmentPath)
		If $E(tSegmentPath,tLen-2,tLen)="(*)" {
			Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
			Set count=0, (path,path0)=$E(tSegmentPath,1,tLen-2), tLen0=$L(path0), i=0
			For { Set path=$O($$$vaM("runtimePath",path))  Quit:path=""||(path0'=$E(path,1,tLen0))
				Set ti=+$E(path,tLen0+1,*)  Set:ti'=i&&ti count=count+1,i=ti
			}
			Quit count
		}
		If $E(tSegmentPath,tLen-1,tLen)=".*" {
			Set count=0,(path,path0)=$E(tSegmentPath,1,tLen-2),tLen0=$L(path0)
			Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
			For { Set path=$O($$$vaM("runtimePath",path))  Quit:path=""||(path0'=$E(path,1,tLen0))  Set count=count+1 }
			Quit count
		}
		Quit $$$ERROR($$$EnsErrGeneral,"Invalid segment count value path '"_tSegmentPath_"'")
	}
	Set tSegObj=..GetSegmentAt(tSegmentPath,.pStatus)  Quit:'$IsObject(tSegObj) ""  $$$ASSERT($$$ISOK(pStatus))
	Quit tSegObj.GetValueAt(tPropertyPath,tSeparators,.pStatus)
]]></Implementation>
</Method>

<Method name="GetSegmentPath">
<Description>
Given a segment index, find the corresponding segment path</Description>
<FormalSpec>pIndex:%Integer,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If '$D($$$vaM("bidirectionalLink")) {
		If '$D($$$vaM("runtimePath")) { Set pStatus=$$$ERROR($$$EnsErrGeneral,"Document is in index-only mode")  Quit "" }
		Else { Set pStatus=$$$ERROR($$$EnsErrGeneral,"Document is in path-only mode")  Quit "" }
	}
	Set pStatus=$$$OK
	Set tVal=$G($$$vaM("bidirectionalLink",+pIndex))
	Set:""=tVal pStatus=$$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds")
	Quit tVal
]]></Implementation>
</Method>

<Method name="GetSegmentIndex">
<Description>
Given a segment path, find the corresponding segment index</Description>
<FormalSpec>pPath:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	If '$D($$$vaM("bidirectionalLink")) {
		If '$D($$$vaM("runtimePath")) { Set pStatus=$$$ERROR($$$EnsErrGeneral,"Document is in index-only mode")  Quit "" }
		Else { Set pStatus=$$$ERROR($$$EnsErrGeneral,"Document is in path-only mode")  Quit "" }
	}
	Set pStatus=$$$OK
	Set tVal=$G($$$vaM("bidirectionalLink",pPath))
	Set:""=tVal||(tVal'=+tVal) pStatus=$$$ERROR($$$EnsErrGeneral,"Path "_pPath_" not found")
	Quit tVal
]]></Implementation>
</Method>

<Method name="FindSegment">
<Description>
Gets the next segment with the given name.
Supports SegName = '*' to match any segment</Description>
<FormalSpec><![CDATA[pSegName:%String,&pIndex:%String="",*pStatus:%Status]]></FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Segment</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK, tId=..%Id()  Set:'tId tId=..%ClonedId
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Set seg=""  For index=+pIndex+1:1:$$$vaM("runtimeIndex") { Set seg=$$$vaSegLookthru(index,tId)  Continue:""=seg
		If $$$vaIsOref(seg) {
			Set tSegObj=..%maps("orefs",index)
			If (pSegName="*")||(tSegObj.Name=pSegName) Set pIndex=index  Quit
		} Else {
			Set segid=$P(seg,"|"), data=$G($$$vaSegmentGbl(segid))
			If (pSegName="*")||(pSegName=$$$vaDataSegName(data)) {
				#; Same code as in getSegmentByIndex
				Set pIndex=index
				Set tSegObj=##class(HPRIM.EDI.E1238.Segment).%New($LB(segid,(..IsMutable&&(tId=..%ClonedId)),$P(seg,"|",2)))
				Set ..%maps("orefs",pIndex)=tSegObj
				Set $$$vaM("runtimeIndex",pIndex)="@"
				Set path=$G($$$vaM("bidirectionalLink",pIndex)) Set:""'=path $$$vaM("runtimePath",path)="@"_pIndex
				Quit
			}
		}
	}
	If +pIndex<index Set pIndex=""  Quit $$$NULLOREF
	Quit tSegObj
]]></Implementation>
</Method>

<Method name="getSegmentByIndex">
<Internal>1</Internal>
<FormalSpec>pIndex:%Integer,*pStatus:%Status</FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Segment</ReturnType>
<Implementation><![CDATA[
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Set pStatus=$$$OK, tId=..%Id()  Set:'tId tId=..%ClonedId
	Set seg=$$$vaSegLookthru(pIndex,tId)
	If seg="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Segment Index  "_pIndex_" is out of bounds") Quit $$$NULLOREF
	Quit:$$$vaIsOref(seg) ..%maps("orefs",pIndex)
	Set tSegObj=##class(HPRIM.EDI.E1238.Segment).%New($LB($P(seg,"|"),(..IsMutable&&(tId=..%ClonedId)),$P(seg,"|",2)))
	Set ..%maps("orefs",pIndex)=tSegObj
	Set $$$vaM("runtimeIndex",pIndex)="@"
	Set path=$G($$$vaM("bidirectionalLink",pIndex)) Set:""'=path $$$vaM("runtimePath",path)="@"_pIndex
	Quit tSegObj
]]></Implementation>
</Method>

<Method name="getSegmentByPath">
<Internal>1</Internal>
<FormalSpec>pPath:%String,*pStatus:%Status</FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Segment</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
	Set seg=$G($$$vaM("runtimePath",pPath))
	If seg="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"No segment found at path '"_pPath_"'") Quit $$$NULLOREF
	Quit:$$$vaIsOref(seg) ..%maps("orefs",$E(seg,2,*))
	Set tSegObj=##class(HPRIM.EDI.E1238.Segment).%New($LB($P(seg,"|"),(..IsMutable&&'..%Id()&&..%ClonedId),$P(seg,"|",2)))
	Set index=$G($$$vaM("bidirectionalLink",pPath))
	If index { Set seg="@"_index, $$$vaM("runtimeIndex",index)="@" }
	Else { Set index=$O(..%maps("orefs",""))-1, seg="@"_index}
	Set ..%maps("orefs",index)=tSegObj
	Set $$$vaM("runtimePath",pPath)=seg
	Quit tSegObj
]]></Implementation>
</Method>

<Method name="getSegmentIdByIndex">
<FormalSpec>pIndex:%Integer,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK, tId=..%Id()  Set:'tId tId=..%ClonedId
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Set seg=$$$vaSegLookthru(pIndex,tId)
	If seg="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds") Quit ""
	Quit:'$$$vaIsOref(seg) $P(seg,"|")
	Quit ..%maps("orefs",pIndex).ID
]]></Implementation>
</Method>

<Method name="getSegmentIdByPath">
<FormalSpec>pPath:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
	Set seg=$G($$$vaM("runtimePath",pPath))
	Quit:'$$$vaIsOref(seg) $P(seg,"|")
	Quit ..%maps("orefs",$E(seg,2,*)).ID
]]></Implementation>
</Method>

<Method name="getMutableSegmentByIndex">
<Internal>1</Internal>
<FormalSpec>pIndex:%Integer,*pStatus:%Status</FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Segment</ReturnType>
<Implementation><![CDATA[
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Set pStatus=$$$OK, i%BuildMapStatus="", tId=..%Id()  Set:'tId tId=..%ClonedId
	Set seg=$$$vaSegLookthru(pIndex,tId)
	If seg="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds")  Quit $$$NULLOREF
	If $$$vaIsOref(seg) {
		Set tSegObj=..%maps("orefs",pIndex)
		If tSegObj.IsMutable Set tSegObj.Separators=..Separators  Quit tSegObj
		Kill ..%maps("orefs",pIndex)
		Set seg=tSegObj.ID_"|"_tSegObj.DocType
	}
	;Set tSegObj=..NewSegment(pPath)
	Set tSegObj=##class(HPRIM.EDI.E1238.Segment).%New($LB($P(seg,"|"),1,$P(seg,"|",2)))
	If '$IsObject(tSegObj)  Set pStatus=%objlasterror  Quit $$$NULLOREF
	Set tSegObj.Separators=..Separators
	Set ..%maps("orefs",pIndex)=tSegObj
	Set $$$vaM("runtimeIndex",pIndex)="@"
	Set path=$G($$$vaM("bidirectionalLink",pIndex)) Set:""'=path $$$vaM("runtimePath",path)="@"_pIndex
	Quit tSegObj
]]></Implementation>
</Method>

<Method name="getMutableSegmentByPath">
<Internal>1</Internal>
<FormalSpec>pPath:%String,*pStatus:%Status</FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Segment</ReturnType>
<Implementation><![CDATA[
	If (..DocTypeCategory="")||(..DocTypeName="") Set pStatus=$$$ERROR($$$EnsErrGeneral,"Cannot recognize path before DocType is set")  Quit $$$NULLOREF
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
	Set pStatus=$$$OK, i%BuildMapStatus=""
	Set seg=$G($$$vaM("runtimePath",pPath))
	If $$$vaIsOref(seg) {
		Set index=$E(seg,2,*)
		Set tSegObj=..%maps("orefs",index)
		If tSegObj.IsMutable Set tSegObj.Separators=..Separators  Quit tSegObj
		Kill ..%maps("orefs",index)
		Set seg=$S(""=tSegObj.ID:"",1:tSegObj.ID_$S(""=tSegObj.DocType:"", 1:"|"_tSegObj.DocType))
	}
	If ""=seg {
		;Set tSegObj=..NewSegment(pPath)
		Set schema=$G($$$vaSchemaGbl(..DocTypeCategory,"DS",..DocTypeName,"map",..convertRuntimePathToSchemaPath(pPath)))
		If schema="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Path '"_pPath_"' is not mapped in schema for DocType '"_..DocType_"'")  Quit $$$NULLOREF
		Set tSegType=$P(schema,"|",2), tSegName=$P(tSegType,":",2)
		If $ZCVT(tSegName,"U")'=tSegName Set pStatus=$$$ERROR($$$EnsErrGeneral,"Cannot instantiate abstract segment type "_tSegType)  Quit $$$NULLOREF
		Set tSegObj=##class(HPRIM.EDI.E1238.Segment).%New($LB("",1,tSegType,$E(..Separators,1,5)_tSegName))
		If '$IsObject(tSegObj) Set pStatus=%objlasterror  Quit $$$NULLOREF
		Kill $$$vaM("runtimeIndex"), $$$vaM("bidirectionalLink") ; we are operating only by PathMap now.
		Set index=$O(..%maps("orefs",""))-1, seg="@"_index
	} Else {
		Set tSegObj=##class(HPRIM.EDI.E1238.Segment).%New($LB($P(seg,"|"),1,$P(seg,"|",2)))
		If '$IsObject(tSegObj) Set pStatus=%objlasterror  Quit $$$NULLOREF
		Set index=$G($$$vaM("bidirectionalLink",pPath))
		If index { Set seg="@"_index, $$$vaM("runtimeIndex",index)="@" }
		Else { Set index=$O(..%maps("orefs",""))-1, seg="@"_index }
	}
	Set tSegObj.Separators=..Separators
	Set ..%maps("orefs",index)=tSegObj
	Set $$$vaM("runtimePath",pPath)=seg
	If ..AutoBuildMap { Do ..BuildMap(0) }
	Else {
		Set i%BuildMapStatus=""
		#; Add relevant loopIndex node(s) if any
		Set pcs=$L(pPath,"(")-1, tHead=$P(pPath,"(",1,pcs)_"("
		For { Set tHead=$O($$$vaM("loopIndex",tHead_")"),-1), tLen=$L(tHead)  Quit:""=tHead
			If tHead=$E(pPath,1,tLen) { Set $$$vaM("loopIndex",tHead,$E(pPath,tLen+1,$F(pPath,")",tLen)-2))="", pcs=pcs-1, tHead=$P(pPath,"(",1,pcs)_"(" }
			Else {
				Set tPart="" For pcs=1:1 { Set tPrevPart=tPart, tPart=$P(pPath,"(",1,pcs)_"(", tLen=$L(tPart)
					If tPart'=$E(tHead,1,tLen) { Set tHead=tPrevPart  Quit }
				}
			}
			Quit:""=tHead||'pcs
		}
	}
	Quit tSegObj
]]></Implementation>
</Method>

<Method name="setSegmentByIndex">
<Internal>1</Internal>
<FormalSpec>pSegObj:HPRIM.EDI.E1238.Segment,pIndex:%Integer,pInsert:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Quit:'$$$IsdefObject(pSegObj) $$$ERROR($$$EnsErrGeneral,"Cannot set null segment object at index "_pIndex)
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Quit:(pIndex\1'=pIndex)||(pIndex<1)||(pIndex>($$$vaM("runtimeIndex")+1)) $$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds")

	If pInsert {
		Set tId=..%Id()  Set:'tId tId=..%ClonedId  For i=$$$vaM("runtimeIndex"):-1:pIndex { ; slide up all segments to make room for inserted one
			Set $$$vaM("runtimeIndex",i+1)=$$$vaSegLookthru(i,tId)
			If $D(..%maps("orefs",i)) Set ..%maps("orefs",i+1)=..%maps("orefs",i)  Kill ..%maps("orefs",i)
		}
		Set path=""
	} Else {
		Set path=$G($$$vaM("bidirectionalLink",pIndex))  Set:""'=path $$$vaM("runtimePath",path)="@"_pIndex
	}
	If pInsert||(pIndex=($$$vaM("runtimeIndex")+1)) Set $$$vaM("runtimeIndex")=$$$vaM("runtimeIndex")+1

	Set $$$vaM("runtimeIndex",pIndex)="@"
	Set pSegObj.DocType="" ; setting by index, the SegType might not match its new position
	Set ..%maps("orefs",pIndex)=pSegObj

	Kill:""=path $$$vaM("runtimePath"), $$$vaM("bidirectionalLink"), $$$vaM("loopIndex") ; we are operating only by IndexMap now.
	If ..AutoBuildMap { Do ..BuildMap(0) } Else { Set i%BuildMapStatus="" }
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="setSegmentByPath">
<Internal>1</Internal>
<FormalSpec>pSegObj:HPRIM.EDI.E1238.Segment,pPath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Quit:(..DocTypeCategory="")||(""=..DocTypeName) $$$ERROR($$$EnsErrGeneral,"Cannot recognize path before DocType is set")
	Quit:'$$$IsdefObject(pSegObj) $$$ERROR($$$EnsErrGeneral,"Cannot set null segment object at position "_pPath)
	Do:'$D($$$vaM("runtimePath")) ..BuildMap()

	Set schema=$G($$$vaSchemaGbl(..DocTypeCategory,"DS",..DocTypeName,"map",..convertRuntimePathToSchemaPath(pPath)))
	Quit:""=schema $$$ERROR($$$EnsErrGeneral,"Path '"_pPath_"' is not mapped in schema for DocType '"_..DocType_"'")
	Set tSegType=$P(schema,"|",2), tSegName=$P(tSegType,":",2)
	Quit:tSegName'=pSegObj.Name $$$ERROR($$$EnsErrGeneral,"Cannot set segment named '"_pSegObj.Name_"' at position "_pPath)
	Set pSegObj.DocType=tSegType ; setting by path, Set the SegType to match its new position

	Set index=$G($$$vaM("bidirectionalLink",pPath))
	If index { Set seg="@"_index, $$$vaM("runtimeIndex",index)="@" }
	Else {
		Set seg=$G($$$vaM("runtimePath",pPath))
		If $$$vaIsOref(seg) { Set index=$E(seg,2,*) }
		Else {
			Set index=$O(..%maps("orefs",""))-1, seg="@"_index
			Kill $$$vaM("runtimeIndex"), $$$vaM("bidirectionalLink") ; we are operating only by PathMap now.
		}
	}
	Set ..%maps("orefs",index)=pSegObj
	Set $$$vaM("runtimePath",pPath)=seg
	If ..AutoBuildMap { Do ..BuildMap(0) }
	Else {
		Set i%BuildMapStatus=""
		#; Add relevant loopIndex node(s) if any
		Set pcs=$L(pPath,"(")-1, tHead=$P(pPath,"(",1,pcs)_"("
		For { Set tHead=$O($$$vaM("loopIndex",tHead_")"),-1), tLen=$L(tHead)  Quit:""=tHead
			If tHead=$E(pPath,1,tLen) { Set $$$vaM("loopIndex",tHead,$E(pPath,tLen+1,$F(pPath,")",tLen)-2))="", pcs=pcs-1, tHead=$P(pPath,"(",1,pcs)_"(" }
			Else {
				Set tPart="" For pcs=1:1 { Set tPrevPart=tPart, tPart=$P(pPath,"(",1,pcs)_"(", tLen=$L(tPart)
					If tPart'=$E(tHead,1,tLen) { Set tHead=tPrevPart  Quit }
				}
			}
			Quit:""=tHead||'pcs
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="setSegmentIdByIndex">
<Internal>1</Internal>
<FormalSpec>pSegId:%String,pIndex:%Integer,pInsert:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Quit:(pIndex\1'=pIndex)||(pIndex<1)||(pIndex>($$$vaM("runtimeIndex")+1)) $$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds")

	If pInsert {
		Set tId=..%Id()  Set:'tId tId=..%ClonedId  For i=$$$vaM("runtimeIndex"):-1:pIndex { ; slide up all segments to make room for inserted one
			Set $$$vaM("runtimeIndex",i+1)=$$$vaSegLookthru(i,tId)
			If $D(..%maps("orefs",i)) Set ..%maps("orefs",i+1)=..%maps("orefs",i)  Kill ..%maps("orefs",i)
		}
		Set path=""
	} Else {
		Set path=$G($$$vaM("bidirectionalLink",pIndex))  Set:""'=path $$$vaM("runtimePath",path)="@"_pIndex
	}
	If pInsert||(pIndex=($$$vaM("runtimeIndex")+1)) Set $$$vaM("runtimeIndex")=$$$vaM("runtimeIndex")+1

	Set $$$vaM("runtimeIndex",pIndex)=pSegId
	
	Kill:""=path $$$vaM("runtimePath"), $$$vaM("bidirectionalLink"), $$$vaM("loopIndex") ; we are operating only by IndexMap now.
	If ..AutoBuildMap { Do ..BuildMap(0) } Else { Set i%BuildMapStatus="" }
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="setSegmentIdByPath">
<Internal>1</Internal>
<FormalSpec>pSegId:%String,pPath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Quit:(..DocTypeCategory="")||(..DocTypeName="") $$$ERROR($$$EnsErrGeneral,"Cannot recognize path unless DocType is set")
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)

	Set schema=$G($$$vaSchemaGbl(..DocTypeCategory,"DS",..DocTypeName,"map",..convertRuntimePathToSchemaPath(pPath)))
	Quit:""=schema $$$ERROR($$$EnsErrGeneral,"Path '"_pPath_"' is not mapped in schema for DocType '"_..DocType_"'")
	Set newseg=pSegId_"|"_..DocTypeCategory_":"_..DocTypeName_":"_$P(schema,"|",2)
	
	Set index=$G($$$vaM("bidirectionalLink",pPath))
	If index { Kill ..%maps("orefs",index)  Set $$$vaM("runtimeIndex",index)=newseg }
	Else {
		Set seg=$G($$$vaM("runtimePath",pPath))
		If $$$vaIsOref(seg) { Kill ..%maps("orefs",$E(seg,2,*)) }
		Else {
			Kill $$$vaM("runtimeIndex"), $$$vaM("bidirectionalLink") ; we are operating only by PathMap now.
		}
	}
	Set $$$vaM("runtimePath",pPath)=newseg
	If ..AutoBuildMap { Do ..BuildMap(0) } Else { Set i%BuildMapStatus="" }
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="removeSegmentByIndex">
<Internal>1</Internal>
<FormalSpec>pIndex:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Set tId=..%Id()  Set:'tId tId=..%ClonedId
	Set seg=$$$vaSegLookthru(pIndex,tId)

	Quit:""=seg $$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds")

	For i=pIndex:1:$$$vaM("runtimeIndex")-1 { ; slide all segments down over removed one
		Set $$$vaM("runtimeIndex",i)=$$$vaSegLookthru(i+1,tId)
		If $D(..%maps("orefs",i+1)) Set ..%maps("orefs",i)=..%maps("orefs",i+1)  Kill ..%maps("orefs",i+1)
	}
	Kill $$$vaM("runtimeIndex",$$$vaM("runtimeIndex")), ..%maps("orefs",$$$vaM("runtimeIndex"))
	Set $$$vaM("runtimeIndex")=$$$vaM("runtimeIndex")-1

	Kill $$$vaM("runtimePath"), $$$vaM("bidirectionalLink"), $$$vaM("loopIndex") ; we are operating only by IndexMap now.
	If ..AutoBuildMap { Do ..BuildMap(0) } Else { Set i%BuildMapStatus="" }
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="removeSegmentByPath">
<Internal>1</Internal>
<FormalSpec>pPath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Quit:(..DocTypeCategory="")||(..DocTypeName="") $$$ERROR($$$EnsErrGeneral,"Cannot recognize path before DocType is set")
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)

	Set seg=$G($$$vaM("runtimePath",pPath))  If seg="" Quit $$$ERROR($$$EnsErrGeneral,"No segment found at path '"_pPath_"'")
	If $$$vaIsOref(seg) { Kill ..%maps("orefs",$E(seg,2,*)) }
	Kill $$$vaM("runtimePath",pPath)

	Kill $$$vaM("runtimeIndex"), $$$vaM("bidirectionalLink") ; we are operating only by PathMap now.
	If ..AutoBuildMap { Do ..BuildMap(0) }
	Else {
		Set i%BuildMapStatus=""
		If pPath["(" {
			#; Invalidate relevant loopIndex sub-arrays if any
			Set tPathHead=$P(pPath,"(",$L(pPath,"(")-1)
			Set tHead=tPathHead For { Set tHead=$O($$$vaM("loopIndex",tHead))  Quit:tPathHead_"("'=$E(tHead,1,$L(tPathHead)+1)
				Kill $$$vaM("loopIndex",tHead)
			}
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="commitSegmentByIndex">
<Description>
collapse segment object into just ID; Save if necessary</Description>
<FormalSpec>pIndex:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Quit:(pIndex<1)||(pIndex>$$$vaM("runtimeIndex")) $$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds")
	Set seg=$G($$$vaM("runtimeIndex",pIndex))
	Quit:'$$$vaIsOref(seg) $$$OK
	Set tSegObj=..%maps("orefs",pIndex)
	If tSegObj.IsMutable Set tSC=tSegObj.SaveData(..Separators) Quit:$$$ISERR(tSC) tSC
	Set newseg=tSegObj.ID_$S(""=tSegObj.DocType:"", 1:"|"_tSegObj.DocType)
	Set $$$vaM("runtimeIndex",pIndex)=newseg
	Set path=$G($$$vaM("bidirectionalLink",pIndex)) Set:""'=path $$$vaM("runtimePath",path)=newseg
	Kill ..%maps("orefs",pIndex)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="commitSegmentByPath">
<Description>
collapse segment object into just Id; Save if necessary</Description>
<FormalSpec>pPath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
	Set seg=$G($$$vaM("runtimePath",pPath))
	If seg="" Quit $$$ERROR($$$EnsErrGeneral,"No segment found at path '"_pPath_"'")
	If '$$$vaIsOref(seg) Quit $$$OK
	Set index=$E(seg,2,*)
	Set tSegObj=..%maps("orefs",index)
	If tSegObj.IsMutable Set tSC=tSegObj.SaveData(..Separators) Quit:$$$ISERR(tSC) tSC

	Set newseg=tSegObj.ID_$S(""=tSegObj.DocType:"", 1:"|"_tSegObj.DocType)
	Set $$$vaM("runtimePath",pPath)=newseg
	Kill ..%maps("orefs",index)
	Set index=$G($$$vaM("bidirectionalLink",pPath)) Set:""'=index $$$vaM("runtimeIndex",index)=newseg
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="convertRuntimePathToSchemaPath">
<FormalSpec>pPath:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tOutput=pPath
	Set f=0 For {
		Set f=$F(tOutput,"(",f) Quit:f=0
		Set g=$F(tOutput,")",f) If g=0 Set tOutput="" quit
		Set tOutput=$E(tOutput,1,f-1)_$E(tOutput,g-1,*)
		Set f=g
	}
	Quit tOutput
]]></Implementation>
</Method>

<Method name="getOrderKeyFromRuntimePath">
<Description>
Given a runtime path, this method generates the key used for collation</Description>
<Internal>1</Internal>
<FormalSpec>pRuntimePath:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSchemaPath=pRuntimePath, tRuntimeIndex=0
	Set f=0 For {
		Set f=$F(tSchemaPath,"(",f) Quit:f=0
		Set g=$F(tSchemaPath,")",f) If g=0 Set tSchemaPath="" quit
		Set tRuntimeIndex($i(tRuntimeIndex))=$E(tSchemaPath,f,g-2)
		Set tSchemaPath=$E(tSchemaPath,1,f-1)_$E(tSchemaPath,g-1,*)
		Set f=g
	}
	If tSchemaPath="" Quit ""
	Set tMapValue=$G($$$vaSchemaGbl(..DocTypeCategory,"DS",..DocTypeName,"map",tSchemaPath)) If tMapValue="" Quit ""
	Set tKey=$P(tMapValue,"|")
	For i=1:1:$G(tRuntimeIndex) {
		Set f=$F(tKey,"*") If f=0 Set tKey="" quit
		Set $E(tKey,f-1)=$tr($j(tRuntimeIndex(i),8)," ",0)
	}
	#; If couldn't find a replacement position or there are remaining unfilled replacement positions then key is invalid
	Quit:tKey["*"||'f ""

	Quit tKey
]]></Implementation>
</Method>

<Method name="buildRuntimeIndexFromPath">
<Internal>1</Internal>
<FormalSpec>pClearSegTypes:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$ASSERT('$D($$$vaM("runtimeIndex"))&&'$D($$$vaM("bidirectionalLink")))
	Set tPath="" For { Set tPath=$O($$$vaM("runtimePath",tPath))  Quit:""=tPath
		Set tOrderKey=..getOrderKeyFromRuntimePath(tPath)  Continue:""=tOrderKey
		Set $$$vaM("OrderKeyToRuntimePath",tOrderKey)=tPath
	}
	#; Re-Order mapOrefs according to new index sequence.
	Set key="",index=0 For { Set key=$O($$$vaM("OrderKeyToRuntimePath",key),1,tPath)  Quit:key=""
		Set seg=$$$vaM("runtimePath",tPath)
		Set index=index+1
		If $$$vaIsOref(seg) {
			Set oldindex=$E(seg,2,*)
			Set tSegObj=..%maps("orefs",oldindex)
			Set:pClearSegTypes tSegObj.DocType=""
			If oldindex'=index {
				Set $$$vaM("runtimePath",tPath)="@"_index  Kill ..%maps("orefs",oldindex)
				#; Migrate ..mapOrefs if needed rather than doing it in place, because re-ordering in Path mode may have occurred after runtimeIndex map was killed
				If $D(..%maps("orefs",index)) { Set tMapOrefs(index)=tSegObj } Else { Set ..%maps("orefs",index)=tSegObj }
			}
			Set $$$vaM("runtimeIndex",index)="@"
		} Else {
			Set:pClearSegTypes seg=$P(seg,"|")
			Set $$$vaM("runtimeIndex",index)=seg
		}
		Set $$$vaM("bidirectionalLink",index)=tPath, $$$vaM("bidirectionalLink",tPath)=index
	}
	Kill $$$vaM("OrderKeyToRuntimePath")
	Merge ..%maps("orefs")=tMapOrefs
	Set $$$vaM("runtimeIndex")=index, $$$vaM("runtimeIndex",0)="" ; set a marker for negative path indices
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnConstructClone">
<FormalSpec><![CDATA[object:%RegisteredObject,deep:%Boolean=0,&cloned:%String]]></FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$vaMgetIndex

#ifndef LOCALMAPS
	#; copy runtime maps from old instance
	Merge $$$vaM("runtimePath")=$$$vaMobj(object,"runtimePath")
	Merge $$$vaM("bidirectionalLink")=$$$vaMobj(object,"bidirectionalLink")
	Set tId=object.%Id()  Merge:tId $$$vaM("runtimeIndex")=$$$vaExtentGbl(tId,"segs") ; no lookthru to other guy's Id
	Merge $$$vaM("runtimeIndex")=$$$vaMobj(object,"runtimeIndex")
#endif	
	#; Clone segment objects so the clone can continue to use them without changing the original's data or properties
	Set index="" For { Set index=$O(object.%maps("orefs",index),1,tSegObj)  Quit:""=index
		Set ..%maps("orefs",index)=tSegObj.%ConstructClone()
	}
	Set i%IsMutable=1 ; mark it mutable
	Set i%%ClonedId=object.%ClonedId  Set:'..%ClonedId i%%ClonedId=object.%Id()  Set:'..%ClonedId i%%ClonedId=0
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnNew">
<Description>
create an object based on id=initvalue but editable</Description>
<FormalSpec>initvalue:%CacheString=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSegmentIds=$LG(initvalue,1), ..Separators=$LG(initvalue,2), i%Source=$LG(initvalue,3)
	Set:""=..Separators ..Separators=$$$E1238DefSeparators
	$$$vaMgetIndex
	Set $$$vaM("runtimeIndex")=$LL(tSegmentIds), $$$vaM("runtimeIndex",0)="" ; set a marker for negative path indices
	For i=1:1:$$$vaM("runtimeIndex") { Set $$$vaM("runtimeIndex",i)=$LI(tSegmentIds,i) }
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnOpen">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tId=..%Id()
	$$$vaMgetIndex
	Set cnt=$G($$$vaExtentGbl(tId,"segs")), $$$vaM("runtimeIndex")=cnt, $$$vaM("runtimeIndex",0)="" ; set a marker for negative path indices
	If 'cnt { Set ..Separators=$$$E1238DefSeparators }
	Else { Set seg1id=$$$vaExtentGbl(tId,"segs",1), ..Separators=$E($$$vaSegmentGbl(seg1id),1,5) }
	Set i%DocTypeCategory=$P(..DocType,":",1)
	Set i%DocTypeName=$P(..DocType,":",2)
	#; No automatic BuildMap here - allow cheap instantiation for portal etc; do BuildMap() only when called for
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAfterSave">
<FormalSpec>insert:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK, tId=..%Id()
	Do:'$D($$$vaM("runtimeIndex"))&&$D($$$vaM("runtimePath")) ..buildRuntimeIndexFromPath()
	Set count=+$G($$$vaM("runtimeIndex"))  For index=1:1:count { Set seg=$$$vaSegLookthru(index,..%ClonedId)
		If $$$vaIsOref(seg) {
			Set tSegObj=..%maps("orefs",index)
			Set tSC=tSegObj.SaveData(..Separators)  Quit:$$$ISERR(tSC)
			Set segid=tSegObj.ID
		} Else {
			Set segid=$P(seg,"|")
		}
		Set:segid $$$vaExtentGbl(tId,"segs",index)=segid, $$$vaSegmentGbl(segid,0,tId)=""
	}
	For index=count+1:1:+$G($$$vaExtentGbl(tId,"segs")) { Kill $$$vaExtentGbl(tId,"segs",index) } ; Kill leftovers if we shrank
	Set $$$vaExtentGbl(tId,"segs")=count
	Set i%%ClonedId=0
	Quit tSC
]]></Implementation>
</Method>

<Method name="PokeDocType">
<CodeMode>expression</CodeMode>
<FormalSpec>pDocType:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..DocTypeSet(pDocType,0)
]]></Implementation>
</Method>

<Method name="DocTypeSet">
<FormalSpec>pDocType:%String,pBuildMap:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pDocType=..DocType&&$D($$$vaM("runtimePath")) $$$OK ; nothing is changed

	#; convert runtimePath to runtimeIndex and then Kill runtimePath
	Do:'$D($$$vaM("runtimeIndex"))&&$D($$$vaM("runtimePath")) ..buildRuntimeIndexFromPath(1) ; 1 = clear types
	Kill $$$vaM("runtimePath"), $$$vaM("bidirectionalLink"), $$$vaM("loopIndex")
	Set i%DocType=pDocType
	Set i%DocTypeCategory=$P(pDocType,":",1)
	Set i%DocTypeName=$P(pDocType,":",2)
	Do:pBuildMap ..BuildMap()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="BuildMap">
<Description>
pKeepParsingAfterError means keep trying to parse after errors are encountered; returned Status will contain all errors encountered</Description>
<FormalSpec>pKeepParsingAfterError:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ((""=..DocTypeCategory)||(""=..DocTypeName)) {
		Set i%BuildMapStatus=$S(""=..DocType:"", 1:$$$ERROR($$$EnsEDIErrMapDocType,"E1238",..DocType))
	} Else {
		Quit:$D($$$vaM("runtimePath"))&&(""'=..BuildMapStatus) ..BuildMapStatus ; already done
		Set i%BuildMapStatus=""
	}
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath(1) ; 1 = clear types
	Kill $$$vaM("runtimePath"), $$$vaM("bidirectionalLink"), $$$vaM("loopIndex")

	Quit:""=..DocType $$$OK
	Quit:""'=..BuildMapStatus ..BuildMapStatus

	Set tSchema=$G($$$vaSchemaGbl(..DocTypeCategory,"DS",..DocTypeName))
	If tSchema="" {
		Set i%BuildMapStatus=$$$ERROR($$$EnsEDIErrMapDocType,"E1238",..DocType)
		Quit ..BuildMapStatus
	}
	Set tId=..%Id()  Set:'tId tId=..%ClonedId
	Set tCurrSeg=1, %seglastmatch=0, %pathlastmatch=""
	Set tSC=..buildRuntimePathFromIndex(tId,"",$Name($$$vaSchemaGbl)_"("""_..DocTypeCategory_""",""DS"","""_..DocTypeName_""",""array"")","top",.tCurrSeg,0,$$$OK,pKeepParsingAfterError)
	$$$ASSERT(%seglastmatch=(tCurrSeg-1))
	#; Map leftover segments
	Set tSegments=$$$vaM("runtimeIndex")
	If tCurrSeg<=tSegments {
		For i=tCurrSeg:1:tSegments {
			Set $$$vaM("runtimePath","leftoversegs("_(i+1-tCurrSeg)_")")=i
		}
		If pKeepParsingAfterError||$$$ISOK(tSC) {
			#; Find current Segment's Type Name
			Set seg=$$$vaSegLookthru(tCurrSeg,tId)
			If $$$vaIsOref(seg) {
				Set tSegObj=..%maps("orefs",tCurrSeg)
				Set currsegname=tSegObj.Name
			} Else {
				Set data=$G($$$vaSegmentGbl($P(seg,"|")))
				Set currsegname=$$$vaDataSegName(data)
			}
			If tCurrSeg=1 { Set lastname="" }
			Else {
				#; Find previous Segment's Type Name
				Set seg=$$$vaSegLookthru(tCurrSeg-1,tId)
				If $$$vaIsOref(seg) {
					Set tSegObj=..%maps("orefs",tCurrSeg-1)
					Set lastname=tSegObj.Name
				} Else {
					Set data=$G($$$vaSegmentGbl($P(seg,"|")))
					Set lastname=$$$vaDataSegName(data)
				}
			}
			Set lastmatch=$S(""'=lastname&&%seglastmatch:%seglastmatch_" ("_%pathlastmatch_")", 1:"0")
			Set tSC=$$$ADDSC(tSC,$$$ERROR($$$EnsEDIErrMapSegUnrecog,currsegname,lastmatch))
		}
	}
	Kill %seglastmatch, %pathlastmatch
	Set i%BuildMapStatus=tSC
	Quit tSC
]]></Implementation>
</Method>

<Method name="buildRuntimePathFromIndex">
<Description><![CDATA[
Build a segment map for the current segment index array based on the document schema<br>
If <var>pKeepParsingAfterError</var> is false then stop parsing when first error is encountered<br>]]></Description>
<FormalSpec><![CDATA[pId:%String,pPath:%String,pContentArray:%String,pType:%String,&pCurrSeg:%Integer,pParentGrpOpt:%Boolean,pSC:%Status,pKeepParsingAfterError:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSegments=$$$vaM("runtimeIndex"), currsegname=""
	Set type=$P(pType,"(",1,$L(pType,"(")), len=$L(type), tIsUnion="union"=$E(type,len+1-$L("union"),len)
	Set tGrpOpt=(pParentGrpOpt||$G(@pContentArray@("opt"),0)), tFirstReq="", tGrpSeg=pCurrSeg
	For i=1:1:$G(@pContentArray) { ; loop over sub-elements of the root element at this level
		Set pIContents=$Name(@pContentArray@(i))
		Set opt=$G(@pIContents@("opt"),0), tFirstReq=$S(""=tFirstReq&&'opt:1, ""=tFirstReq:"", 1:0)
		Set type=@pIContents@("type")
		Set segtype=$P(type,":",3)
		Set isrep=$P(segtype,"(",2), tMaxReps=$Case(isrep, ")":0, "":1, :+isrep), isrep=(""'=isrep), tRequiredReps='opt
		Set segtype=$P(segtype,"(") ; strip off parens
		Set keyfields=$P(segtype,"-",2), segtype=$P(segtype,"-") ; split off key fields indicator
		Set segname=$P(@pIContents@("name"),"(")
		Set subs=$G(@pIContents,0)
		Set tISeg=pCurrSeg
		For rep=1:1 { Quit:rep>tMaxReps&&tMaxReps ; loop for repetitions of the current sub-element
			Set tBaseSeg=pCurrSeg
			Set tIPath=$S(""=pPath:"",1:pPath_".")_segname_$S(isrep:"("_rep_")",1:"")
			#;If isrep&&(rep=1)&&(i=1)&&opt Set pSC=$$$ADDSC(pSC,$$$ERROR($$$EnsEDIErrMapGeneral,"Schema error at "_tIPath_" - the first element in a repeating group must not be optional"))  Quit

			If subs {
				Set pSC=..buildRuntimePathFromIndex(pId,tIPath,pIContents,type,.pCurrSeg,tGrpOpt||(rep>tRequiredReps),pSC,pKeepParsingAfterError)
			} Else {
				#; Find current Segment's Type Name
				If pCurrSeg>tSegments {
					Set currsegname=""
				} Else {
					Set seg=$$$vaSegLookthru(pCurrSeg,pId)
					If $$$vaIsOref(seg) {
						Set tSegObj=..%maps("orefs",pCurrSeg)
						Set data=$E(tSegObj.Separators,1,5)_tSegObj.GetValueAt()
					} Else {
						Set data=$G($$$vaSegmentGbl($P(seg,"|")))
					}
					Set currsegname=$$$vaDataSegName(data)
				}
				#; Check for segment type match
				If segtype=currsegname &&(""=keyfields
				 || $$keyfieldsMatch(keyfields,data)) {	
					#; Set seg address/schema at path into runtimePath
					Set schema=$P($P(type,":",2,3),"(")
					Set seg=$$$vaSegLookthru(pCurrSeg,pId)
					If $$$vaIsOref(seg) {
						Set $$$vaM("runtimePath",tIPath)="@"_pCurrSeg
						Set ..%maps("orefs",pCurrSeg).DocType=schema
					} Else {
						Set seg=$P(seg,"|")_"|"_schema
						Set $$$vaM("runtimeIndex",pCurrSeg)=seg
						Set $$$vaM("runtimePath",tIPath)=seg
					}
					Set $$$vaM("bidirectionalLink",pCurrSeg)=tIPath, $$$vaM("bidirectionalLink",tIPath)=pCurrSeg

					Set %seglastmatch=pCurrSeg, %pathlastmatch=tIPath
					Set:pCurrSeg<=tSegments pCurrSeg=pCurrSeg+1, currsegname=""
				}
			}
			If tBaseSeg=pCurrSeg { ; found no match in repeat loop
				Set:rep<tRequiredReps&&'tIsUnion&&'tGrpOpt pSC=$$$ADDSC(pSC,$$$ERROR($$$EnsEDIErrMapSegCount,tRequiredReps,tIPath,pCurrSeg_$S(""=$G(currsegname):"",1:" ("_currsegname_")")))
				Quit
			} Else {
				Set tGrpOpt=0
				Quit:pCurrSeg>tSegments
			}
		}
		Quit:$$$ISERR(pSC)&&'pKeepParsingAfterError
		If tISeg=pCurrSeg { ; found no match at element i
			If 'opt&&'tIsUnion {
				Quit:i=1
				Set:'tGrpOpt pSC=$$$ADDSC(pSC,$$$ERROR($$$EnsEDIErrMapRequired,tIPath,pCurrSeg_$S(""=$G(currsegname):"",1:" ("_currsegname_")")))
				Quit:tFirstReq||'pKeepParsingAfterError
			}
		} Else {
			Set tGrpOpt=0
			Quit:tIsUnion
		}
	}
	If tIsUnion {
		If tGrpSeg=pCurrSeg { ; found no match in any union element
			Set:'tGrpOpt pSC=$$$ADDSC(pSC,$$$ERROR($$$EnsEDIErrMapRequiredUnion,pPath,pCurrSeg_$S(""=$G(currsegname):"",1:" ("_currsegname_")")))
		}
	}
	Quit pSC
keyfieldsMatch(pKeyFields,pData) ; local routine that returns true if all keyfields match the data
	Set tMatch=1, nFlds=$L(pKeyFields,"&") For iFld=1:1:nFlds { Set tKey=$P(pKeyFields,"&",iFld)  Continue:""=tKey
		If (tKey'=$$$SEGELEM(pData,2)) Set tMatch=0  Quit
	}
	Quit tMatch
]]></Implementation>
</Method>

<Method name="DumpMaps">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set DocType=..DocType w ! zw DocType
	w !,"DocTypeCategory,DocTypeName="_..DocTypeCategory_","_..DocTypeName
	Set BuildMapStatus=..BuildMapStatus w ! zw BuildMapStatus
	If ""'=..DocTypeCategory&&(""'=..DocTypeName) {
		Merge mapSchemaPath=$$$vaSchemaGbl(..DocTypeCategory,"DS",..DocTypeName,"map") w ! zw mapSchemaPath
		Merge mapContentArray=$$$vaSchemaGbl(..DocTypeCategory,"DS",..DocTypeName,"array") w ! zw mapContentArray
	}
	Merge mapRuntimeIndex=$$$vaM("runtimeIndex") w ! zw mapRuntimeIndex
	Merge mapRuntimePath=$$$vaM("runtimePath") w ! zw mapRuntimePath
	Merge mapBidirectionalLink=$$$vaM("bidirectionalLink") w ! zw mapBidirectionalLink
	Merge mapLoopIndex=$$$vaM("loopIndex") w ! zw mapLoopIndex
 	Merge mapOrefs=..%maps("orefs") w ! zw mapOrefs
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetContentArray">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>*pContents,pMode:%String,pDocType:%String,pLevel:%Integer,pIncludeBase:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(HPRIM.EDI.E1238.Schema).GetContentArray(.pContents,.pMode,.pDocType,.pLevel,.pIncludeBase)
]]></Implementation>
</Method>

<Query name="EnumerateDocTypes">
<Description><![CDATA[
Returns a list of available DocTypes for this document class. <br/>
The DocType is returned as the first column in the result set. <br/>
The <var>Category</var> parameter can be used to restrict the list. <br/>
If <var>Category</var> is: <br/>
 0 - return only DocTypes in standard categories <br/>
 + - return only DocTypes in user-defined categories <br/>
 empty - return DocTypes from all categories <br/>
 a category name - return only DocTypes in the named category <br/>
 a partial name suffixed with '%' - return only DocTypes in categories matching the partial category name <br/>
 other - return nothing <br/>
If <var>IncludeBase</var> is: <br/>
 0 - return only DocTypes defined in the current schema category itself <br/>
 1 - return all DocTypes in the current schema category's base category in addition to those defined in the current category itself <br/>]]></Description>
<Type>%Query</Type>
<FormalSpec>Category:%String="",IncludeBase:%Boolean=1</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Type:%String"/>
</Query>

<Method name="EnumerateDocTypesExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary,Category:%String="",IncludeBase:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(HPRIM.EDI.E1238.Schema).DocStructuresExecute(.qHandle,.Category,.IncludeBase)
]]></Implementation>
</Method>

<Method name="EnumerateDocTypesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer]]></FormalSpec>
<PlaceAfter>EnumerateDocTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##class(HPRIM.EDI.E1238.Schema).DocStructuresFetch(.qHandle,.Row,.AtEnd)
	Set:""'=$G(Row) Row=$LB($LG(Row))
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateDocTypesClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateDocTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(HPRIM.EDI.E1238.Schema).DocStructuresClose(.qHandle)
]]></Implementation>
</Method>

<Query name="EnumerateTypeCategories">
<Description><![CDATA[
Returns a list of document type schema categories for the document class.<br>
The Standard parameter can be used to restrict the list.<br>
If Standard is:
 0 - return only standard categories
 + - return only user-defined categories
 empty - return all categories
 a partial category name - return only categories starting with the given category name part<br/>
 other - return nothing]]></Description>
<Type>%Query</Type>
<FormalSpec>Standard:%String=""</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Category:%String,Description:%String,IsStandard:%Boolean,Base:%String"/>
</Query>

<Method name="EnumerateTypeCategoriesExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary,Standard:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(HPRIM.EDI.E1238.Schema).TypeCategoriesExecute(.qHandle, Standard)
]]></Implementation>
</Method>

<Method name="EnumerateTypeCategoriesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer]]></FormalSpec>
<PlaceAfter>EnumerateTypeCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##class(HPRIM.EDI.E1238.Schema).TypeCategoriesFetch(.qHandle,.Row,.AtEnd)
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateTypeCategoriesClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateTypeCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(HPRIM.EDI.E1238.Schema).TypeCategoriesClose(.qHandle)
]]></Implementation>
</Method>

<Query name="EnumerateSegTypes">
<Description><![CDATA[
Returns a list of schema categories and segment types and segment fields for this document class. <br/>
The <var>Category</var> and <var>Level</var> parameters can be used to restrict the list. <br/>
If <var>Category</var> is: <br/>
 0 - return only standard categories <br/>
 + - return only user-defined categories <br/>
 empty - return all categories <br/>
 a category name - return only SegTypes in the named category <br/>
 a category name:segment type name - return only information about the named SegType <br/>
 a partial name suffixed with '%' - return only SegTypes in categories matching the partial category name <br/>
 other - return nothing <br/>
If <var>Level</var> is: <br/>
 0 - return all segment names <br/>
 n - return the given number of levels of nested field names within each segment <br/>
 empty - return all levels of nested field names within each segment <br/>
If <var>IncludeBase</var> is: <br/>
 0 - return only segment names defined in the current schema category itself <br/>
 1 - return all segment names in the current schema category's base category in addition to those defined in the current category itself <br/>]]></Description>
<Type>%Query</Type>
<FormalSpec>Category:%String="",Level:%String=""</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="SegType:%String,Field:%String,Description:%String,IsStandard:%Boolean"/>
</Query>

<Method name="EnumerateSegTypesExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary,Category:%String,Level:%String,IncludeBase:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(HPRIM.EDI.E1238.Schema).SegTypesExecute(.qHandle,.Category,.Level,.IncludeBase)
]]></Implementation>
</Method>

<Method name="EnumerateSegTypesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer]]></FormalSpec>
<PlaceAfter>EnumerateSegTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##class(HPRIM.EDI.E1238.Schema).SegTypesFetch(.qHandle,.Row,.AtEnd)
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateSegTypesClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateSegTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(HPRIM.EDI.E1238.Schema).SegTypesClose(.qHandle)
]]></Implementation>
</Method>

<Method name="GetAlias">
<Description>
This method computes the Alias string for a property name, given the property's node in the Content Array.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pContentArrayName:%String,pArrayPos:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[##class(HPRIM.EDI.E1238.Schema).GetAlias(pContentArrayName,pArrayPos)
]]></Implementation>
</Method>

<Method name="checkDocType">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pDocType:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set category=$P(pDocType,":",1)
	Set secondary=$P(pDocType,":",2)
	If (""=category)||(""=secondary)||(""=$G($$$vaSchemaGbl(category,"DS",secondary))) {
		Set tSC=$$$ERROR($$$EnsEDIErrMapDocType,"E1238",pDocType)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="getSegsAsString">
<Description>
This method is for use from the RawContent property's SQL Compute invocation</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pId:%String,pMaxLen:%Integer=10000,pStartOffset:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#; Use delimiters from first segment, translate all subsequent delims to those; SegTerminator=$C(13,10)
	Set str=""  For index=1:1:+$G($$$vaExtentGbl(pId,"segs")) { Set data=$$$vaSegmentGbl($$$vaExtentGbl(pId,"segs",index))
		Set:index=1 tSeparators=$E(data,1,5)
		Set:tSeparators'=$E(data,1,5) data=##class(HPRIM.EDI.E1238.Segment).replaceSeparators(data, tSeparators)
		If pStartOffset>1 {
			If pStartOffset>($L(data)-5+2) { Set pStartOffset=pStartOffset-($L(data)-5+2) }
			Else { Set pStartOffset=1, data=$E(data,pStartOffset,*) }
		}
		If pMaxLen-$L(str)>=($L(data)-5+2) { Set str=str_$E(data,6,*)_$C(13,10) }
		Else { Set str=str_$E(data_$C(13,10),6,5+pMaxLen-$L(str)) }
		Quit:$L(str)>=pMaxLen
	}
	Quit str
]]></Implementation>
</Method>

<Method name="OutputToFile">
<FormalSpec>pFilename:%String,pOverwrite:%Boolean,pSeparators:%String,pDoFraming:%Integer,pResponseTimeout:%Numeric=-1,pIOFormatClassname:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=##Class(%IO.FileStream).%New()
	Do tIOStream.Open(pFilename,$S($G(pOverwrite):"NEW",1:"AEW"),5,,.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit ..OutputToIOStream(tIOStream, .pSeparators, .pDoFraming, .pResponseTimeout, .pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="OutputToDevice">
<FormalSpec>pSeparators:%String,pDoFraming:%Integer,pResponseTimeout:%Numeric=-1,pIOFormatClassname:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tDeviceStream=##class(%IO.DeviceStream).AttachNew(,.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit ..OutputToIOStream(tDeviceStream, .pSeparators, .pDoFraming, .pResponseTimeout, .pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="OutputToLibraryStream">
<FormalSpec>pLibStream:%Stream.Object,pSeparators:%String,pDoFraming:%Integer,pResponseTimeout:%Numeric=-1,pIOFormatClassname:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=$S(pLibStream.%Extends("%IO.I.CharacterStream"):pLibStream, 1:##Class(%IO.MetaCharacterStream).%New(pLibStream))
	Quit ..OutputToIOStream(tIOStream, .pSeparators, .pDoFraming, .pResponseTimeout, .pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="OutputToString">
<FormalSpec>pSeparators:%String,pDoFraming:%Integer,pResponseTimeout:%Numeric=-1,*pStatus:%Status,pIOFormatClassname:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=##Class(%IO.StringStream).%New()
	Set pStatus = ..OutputToIOStream(tIOStream, .pSeparators, .pDoFraming, .pResponseTimeout, .pIOFormatClassname)
	Do tIOStream.Rewind()
	Quit tIOStream.Read()
]]></Implementation>
</Method>

<Method name="OutputToIOStream">
<FormalSpec><![CDATA[pIOStream:%IO.I.CharacterStream,pSeparators:%String,&pDoFraming:%Integer=0,pResponseTimeout:%Numeric=-1,pIOFormatClassname:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK  Set pDoFraming=$S(pDoFraming>7:2, pDoFraming<-7:-2, 1:pDoFraming)
	Set tSeparators=$S(""=$G(pSeparators):..Separators, 1:pSeparators)  Set:""=tSeparators tSeparators=$$$E1238DefSeparators
	If ""=pIOFormatClassname || '$classmethod(pIOFormatClassname,"OutputDocument",$this,.tSC,pIOStream,tSeparators) {
		Do:'$D($$$vaM("runtimeIndex"))&&$D($$$vaM("runtimePath")) ..buildRuntimeIndexFromPath()
		For i=1:1:$G($$$vaM("runtimeIndex")) { Set tSeg=..getSegmentByIndex(i)
			Set tSC=tSeg.OutputToIOStream(pIOStream, tSeparators, .pDoFraming, .pResponseTimeout)
			Do ..commitSegmentByIndex(i)
		}
		Do:""'=pIOFormatClassname $classmethod(pIOFormatClassname,"OutputDocumentEnd",$this,.tSC,pIOStream,tSeparators)
		If $$$ISOK(tSC) {
			If pDoFraming { Do pIOStream.Write($$$EOT,1,.tSC) }
			Else { Do pIOStream.Flush(.tSC) }
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OutputHTML">
<Description>
Display Segments as HTML, using DocType info if available</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set tSeparators=..Separators  Set:""=tSeparators tSeparators=$$$E1238DefSeparators
	Quit ..OutputToDevice(tSeparators,,,"HPRIM.EDI.E1238.Util.FormatHTML")
]]></Implementation>
</Method>

<Method name="OutputHTMLZen">
<Description>
Display Segments as HTML, using DocType info if available</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set tSeparators=..Separators  Set:""=tSeparators tSeparators=$$$E1238DefSeparators
	Quit ..OutputToDevice(tSeparators,,,"HPRIM.EDI.E1238.Util.FormatHTMLZen")
]]></Implementation>
</Method>

<Method name="ImportFromFile">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pFilename:%String,pDocNum:%Integer=1,*pStatus:%Status,&pConfigItem:%String,pIOFormatClassname:%String]]></FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Document</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=##Class(%IO.FileStream).%New()
	Set tIOStream.LineTerminator=$C(13,10) ; override OS dependent default
	Do tIOStream.Open(pFilename,,5,,.pStatus)  Quit:$$$ISERR(pStatus) $$$NULLOREF
	$$$sysTRACE("Opened file '"_pFilename_"'")
	Set tDoc=$$$NULLOREF  For i=1:1:pDocNum {
		If tIOStream.AtEnd Set pStatus=$$$ERROR($$$EnsErrGeneral,"Fewer than "_pDocNum_" documents in file "_pFilename)  Quit
		Set tDoc=..ImportFromIOStream(tIOStream,.pStatus,.pConfigItem,.pIOFormatClassname)  Quit:$$$ISERR(pStatus)
	}
	Quit:$$$ISERR(pStatus) $$$NULLOREF
	Quit tDoc
]]></Implementation>
</Method>

<Method name="ImportFromDevice">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pStatus:%Status,&pConfigItem:%String,pIOFormatClassname:%String]]></FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Document</ReturnType>
<Implementation><![CDATA[
	Set tDeviceStream=##class(%IO.DeviceStream).AttachNew(,.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit ..ImportFromIOStream(tDeviceStream,.pStatus,.pConfigItem,.pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="ImportFromLibraryStream">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pLibStream:%Stream.Object,*pStatus:%Status,&pConfigItem:%String,pIOFormatClassname:%String]]></FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Document</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=$S(pLibStream.%Extends("%IO.I.CharacterStream"):pLibStream,1:##Class(%IO.MetaCharacterStream).%New(pLibStream))
	Quit ..ImportFromIOStream(tIOStream,.pStatus,.pConfigItem,.pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="ImportFromString">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pString:%String,*pStatus:%Status,&pConfigItem:%String,pIOFormatClassname:%String]]></FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Document</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=##Class(%IO.StringStream).%New(pString)
	Quit ..ImportFromIOStream(tIOStream,.pStatus,.pConfigItem,.pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="ImportFromIOStream">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pIOStream:%IO.I.CharacterStream,*pStatus:%Status=$$$OK,&pConfigItem:%String="",pIOFormatClassname:%String=""]]></FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Document</ReturnType>
<Implementation><![CDATA[
	Quit:""'=pIOFormatClassname&&$classmethod(pIOFormatClassname,"ImportDocument",.tDoc,.pStatus,pIOStream,pConfigItem) tDoc

	If ""'=pConfigItem {
		If $IsObject(pConfigItem) {
			Set tInst=pConfigItem
		} Else {
			Set tInst=##class(Ens.Host).GetShadowInstance(pConfigItem,.pStatus)  Quit:$$$ISERR(pStatus) $$$NULLOREF
		}
		If 'tInst.%Extends("HPRIM.EDI.E1238.Service.Standard") Set pStatus=$$$ERROR($$$EnsErrGeneral,"Config Item class "_$classname(tInst)_" found For "_pConfigItem_" is not not an EDI document Service")  Quit $$$NULLOREF
	} Else {
		Set tInst=##class(Ens.Host).GetShadowInstance("class ||HPRIM.EDI.E1238.Service.FileService",.pStatus)  Quit:$$$ISERR(pStatus) $$$NULLOREF
	}
	#; Get a new parser based on a Service; OnInit not called for shadow service instances
	If '$IsObject(tInst.%Parser) Set tInst.%Parser=##class(HPRIM.EDI.E1238.Parser).%New(tInst)  $$$ASSERT($IsObject(tInst.%Parser))

	If tInst'=pConfigItem { ; override some default properties if we created the shadow instance
		Set tInst.SearchTableClass=""
	}
	#; call the parser
	Set tInst.%PreserveSession=2 ; don't let Service process the document
	Set pStatus=tInst.%Parser.ParseIOStream(pIOStream,.tDoc)
	Set pConfigItem=tInst ; allow repeated calls on the same parser
	Quit tDoc
]]></Implementation>
</Method>

<Method name="CopyValues">
<FormalSpec>pSource:HPRIM.EDI.E1238.Document,pSourcePath:%String,pTargetPath:%String,pAction:%String,pKey:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSourceWild=$F(pSourcePath,"()"), tTargetWild=$F(pTargetPath,"()")
	If tSourceWild||tTargetWild {
		Set tSourceHead=$E(pSourcePath,1,tSourceWild-3), tSourceTail=$E(pSourcePath,tSourceWild,*)
		Set tTargetHead=$E(pTargetPath,1,tTargetWild-3), tTargetTail=$E(pTargetPath,tTargetWild,*)
		If tSourceWild {
			Set i="" For { Set i=pSource.GetNextIndex(tSourceHead_"()",i,.tSC) Quit:i=""
				Set tSourceNewPath=tSourceHead_"("_(i)_")"_tSourceTail
				Set tTargetNewPath=$S(tTargetWild:tTargetHead_"("_(i)_")"_tTargetTail,1:pTargetPath)
				Set tSC=..CopyValues(pSource,tSourceNewPath,tTargetNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
			}
		} Else {
			Set i="" For { Set i=..GetNextIndex(tTargetHead_"()",i,.tSC) Quit:i=""
				Set tTargetNewPath=tTargetHead_"("_(i)_")"_tTargetTail
				Set tSC=..CopyValues(pSource,pSourcePath,tTargetNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
			}
		}
	} Else {
		Set tSourceGrpPath=$P(pSourcePath,":"), tSourcePropPath=$P(pSourcePath,":",2)
		Set tTargetGrpPath=$P(pTargetPath,":"), tTargetPropPath=$P(pTargetPath,":",2)
		Set tSrcSegPath=pSource.GetNextGroupPath(tSourceGrpPath,tSourceGrpPath)
		Set tTrgSegPath=..GetNextGroupPath(tTargetGrpPath,tTargetGrpPath)
		If (""'=tSrcSegPath)||(""'=tTrgSegPath) { ; if there are group sub-elements
			If (""'=tSrcSegPath) {
				For {
					Set tSourceNewPath=tSrcSegPath_$S(""=tSourcePropPath:"",1:":"_tSourcePropPath)
					Set tTargetNewPath=tTargetGrpPath_$E(tSrcSegPath,1+$L(tSourceGrpPath),$L(tSrcSegPath))_$S(""=tSourcePropPath:"",1:":"_tSourcePropPath)
					Set tSC=..CopyValues(pSource,tSourceNewPath,tTargetNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
					Set tSrcSegPath=pSource.GetNextGroupPath(tSourceGrpPath,tSrcSegPath,.tSC) Quit:$$$ISERR(tSC)
					Quit:""=tSrcSegPath
				}
			} Else {
				For {
					Set tTargetNewPath=tTrgSegPath_$S(""=tTargetPropPath:"",1:":"_tTargetPropPath)
					Set tSC=..CopyValues(pSource,pSourcePath,tTargetNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
					Set tTrgSegPath=..GetNextGroupPath(tTargetGrpPath,tTrgSegPath,.tSC) Quit:$$$ISERR(tSC)
					Quit:""=tTrgSegPath
				}
			}
		} Else {
			If ""'=tSourcePropPath||("*"=pSourcePath)||($E(pSourcePath,*-2,*)="(*)") {
				Set tSC=..SetValueAt(pSource.GetValueAt(pSourcePath),pTargetPath,pAction,pKey)
			} Else { ; create clone segment object for id or oref
				Set tId=pSource.GetSegmentIdAt(pSourcePath,.tSC)  Quit:$$$ISERR(tSC) tSC
				If tId'="" {
					Set tSegObj=##class(HPRIM.EDI.E1238.Segment).%New($LB(tId,1,"",1))
					Set:$IsObject(tSegObj) tSC=..SetSegmentAt(tSegObj,pTargetPath)
				} Else {
					Set tSegObj=pSource.GetSegmentAt(pSourcePath,.tSC)  Quit:$$$ISERR(tSC) tSC
					Set:$IsObject(tSegObj) tSC=..SetSegmentAt(tSegObj.%ConstructClone(),pTargetPath)
				}
			}
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="Purge">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pDeletedCount:%Integer,pDaysToKeep:%Integer=7,pDummy:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If 0=pDaysToKeep Do ..KillGlobals(.pDeletedCount,1,0)  Quit $$$OK

	New %tDoNotDeleteDate,%tID,%tTime  Set %tDoNotDeleteDate = $$$timeUTCHtoUTC($s($ztimezone'<0:($H-pDaysToKeep+1)_","_($ztimezone*60),1:($H-pDaysToKeep)_","_($ztimezone*60+86400)))
	Set SQLCODE=0, pDeletedCount=0
	&sql(Declare C1 Cursor for
		Select ID,TimeCreated Into :%tID,:%tTime From HPRIM_EDI_E1238.Document Order By ID)
	&sql(OPEN C1) For { &sql(FETCH C1)  Quit:SQLCODE
		If $$$timeCmp(%tTime,%tDoNotDeleteDate)<0 {
			&sql(Delete From HPRIM_EDI_E1238.Document Where ID=:%tID)
			Set pDeletedCount=pDeletedCount+%ROWCOUNT
		}
	} Set tCode=SQLCODE &sql(CLOSE C1) Set:'SQLCODE SQLCODE=tCode
	Quit:SQLCODE&&(SQLCODE'=100) $$$ERROR($$$EnsErrGeneral,"Purge error at ID "_%tID_"; SQLCODE = "_SQLCODE)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New %tID  Set %tID=$$$oidPrimary(oid)
	Do ##class(Ens.SearchTableBase).RemoveSearchTableEntries($classname(),%tID,1)
	For index=1:1:+$G($$$vaExtentGbl(%tID,"segs")) Set segid=$$$vaExtentGbl(%tID,"segs",index) Kill $$$vaSegmentGbl(segid,0,%tID) If $D($$$vaSegmentGbl(segid,0))=0 Kill $$$vaSegmentGbl(segid)
	Quit $$$OK
]]></Implementation>
</Method>

<Trigger name="OnDelete">
<Code>	New %tID,index,segid  Set %tID={%%ID}
	Do ##class(Ens.SearchTableBase).RemoveSearchTableEntries($classname(),%tID,1)
	For index=1:1:+$G($$$vaExtentGbl(%tID,"segs")) Set segid=$$$vaExtentGbl(%tID,"segs",index) Kill $$$vaSegmentGbl(segid,0,%tID) If $D($$$vaSegmentGbl(segid,0))=0 Kill $$$vaSegmentGbl(segid)
	Quit</Code>
<Event>DELETE</Event>
</Trigger>

<Method name="KillGlobals">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pDeletedCount,pKeepExtentCount=0,pDisplayLog=1</FormalSpec>
<Implementation><![CDATA[
	Set pDeletedCount=..TotalCount()
	Set tExtentCount=$G($$$vaExtentGbl)
	Write:pDisplayLog !,"Killing ",$classname()," extent ("_pDeletedCount_"/"_tExtentCount_")"
	Do ..%KillExtent()
	Set:pKeepExtentCount $$$vaExtentGbl=tExtentCount

	Do ##class(HPRIM.EDI.E1238.SearchTable).%KillExtent()

	Set globals($Name($$$vaSegmentGbl))=""

	Set global="" For { Set global=$O(globals(global))  Quit:""=global
		Kill tExtentCount  Set:pKeepExtentCount tExtentCount=$S($D(@global)#2:@global,1:$$topNodesSum(global))
		Write:pDisplayLog !,"Killing ",global,"("_$G(tExtentCount)_")"
		Kill @global
		If $D(tExtentCount) Set @global=tExtentCount
	}
	Quit
topNodesSum(global)
	Set tSum=0,cnt=0,sub="" For { Set sub=$O(@global@(sub),1,cnt) Quit:""=sub  Set tSum=tSum+cnt }
	Quit tSum
]]></Implementation>
</Method>

<Method name="TotalCount">
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	&sql(SELECT COUNT(*) INTO :tCount From HPRIM_EDI_E1238.Document)
	Quit tCount
]]></Implementation>
</Method>

<Method name="%OnClose">
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Kill Segment storage if not %Save'd and segment not used by other Documents
	Set tId=..%Id()
	If ""=tId {
		If $D($$$vaM("runtimeIndex")) {
			For index=1:1:$$$vaM("runtimeIndex") { Set seg=$G($$$vaM("runtimeIndex",index))
				If '$$$vaIsOref(seg) { Set segid=$P(seg,"|") }
				Else {
					Set tSegObj=..%maps("orefs",index)
					Set segid=$S(tSegObj.%Cloned:"", 1:tSegObj.ID) ; don't delete ID from cloned segs because the ID does not really belong to them
				}
				Kill:""'=segid&&'$D($$$vaSegmentGbl(segid,0)) $$$vaSegmentGbl(segid)
			}
		} Else {
			Set path="" For { Set path=$O($$$vaM("runtimePath",path),1,seg) Quit:""=path
				If '$$$vaIsOref(seg) { Set segid=$P(seg,"|") }
				Else {
					Set tSegObj=..%maps("orefs",$E(seg,2,*))
					Set segid=$S(tSegObj.%Cloned:"", 1:tSegObj.ID) ; don't delete ID from cloned segs because the ID does not really belong to them
				}
				Kill:""'=segid&&'$D($$$vaSegmentGbl(segid,0)) $$$vaSegmentGbl(segid)
			}
		}
	}
	If 'tId||$D($$$vaExtentGbl(tId)) $$$vaMkill  ; ..%maps can be undefined when aborting %OpenId() of nonexistent Id
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="NewReplyDocument">
<FormalSpec>pDocType:%String="",pLocalApplicationID:%String,*pSC:%Status</FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Document</ReturnType>
<Implementation><![CDATA[
	Kill %objlasterror
	Set pSC=$$$OK, tReplyDoc=..%New($LB("",..Separators))
	If '$IsObject(tReplyDoc) Set pSC=$$$ERROR($$$EnsErrGeneral,"Failed to instantiate reply document for doc "_..%Id()_"; status = "_$G(%objlasterror,$$$OK))  Quit $$$NULLOREF
	Set:""=pDocType pDocType=..DocType
	Do tReplyDoc.PokeDocType(pDocType)
	Quit tReplyDoc
]]></Implementation>
</Method>

<Method name="Clear">
<Description>
Delete All Content and reset all properties</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Set tSC=..%OnClose()  Quit:$$$ISERR(tSC) tSC
	Kill $$$vaM("runtimeIndex"), $$$vaM("runtimePath"), $$$vaM("bidirectionalLink"), $$$vaM("loopIndex")
	Set $$$vaM("runtimeIndex")=0
	Set i%BuildMapStatus=""
	Set ..Source=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getId">
<Description>
The same as %Id(), but allocates the Id even if the object hasn't been saved already</Description>
<CodeMode>generator</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	$$$GENERATE(" If ..%Id()="""" Do ..%IdSet($increment("_$$$EXTidlocation($$$pEXT,%class)_"))")
	$$$GENERATE(" Quit ..%Id()")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetManagerLinks">
<Description>
Returns an array of links to manager pages for this type of VDoc; item 0 is the family description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pColumns</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set iCol=0
	Set pColumns(iCol,"page")="http://www.ASTM.org"
	Set pColumns(iCol,"name")=$$$Text("E1238")
	Set pColumns(iCol,"desc")=$$$Text("E1238-38 / A2.2 protocol")

	Set iCol=iCol+1
	Set pColumns(iCol,"page")=##class(%CSP.Page).Link("E1238/E1238SchemaMain.csp")
	Set pColumns(iCol,"name")=$$$Text("Schema Structures")
	Set pColumns(iCol,"desc")=$$$Text("View schema definitions for various types of E1238 message documents")

	Set iCol=iCol+1
	Set pColumns(iCol,"page")=##class(%CSP.Page).Link("EDIDocumentView.csp?NAME="_$ZCVT("E1238 Document","O","URL")_"&CLASS=HPRIM.EDI.E1238.Document")
	Set pColumns(iCol,"name")=$$$Text("Document Viewer")
	Set pColumns(iCol,"desc")=$$$Text("View E1238 Documents from a variety of sources and test them with various DocType schema definitions and Data Transformations")

	Quit 1
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^HPRIM.EDI.E1238.DocumentD</DataLocation>
<DefaultData>DocumentDefaultData</DefaultData>
<IdLocation>^HPRIM.EDI.E1238.DocumentD</IdLocation>
<IndexLocation>^HPRIM.EDI.E1238.DocumentI</IndexLocation>
<StreamLocation>^HPRIM.EDI.E1238.DocumentS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="DocumentDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>DocType</Value>
</Value>
<Value name="3">
<Value>Envelope</Value>
</Value>
<Value name="4">
<Value>TimeCreated</Value>
</Value>
<Value name="5">
<Value>Source</Value>
</Value>
<Value name="6">
<Value>IsMutable</Value>
</Value>
<Value name="7">
<Value>OriginalDocId</Value>
</Value>
</Data>
<Data name="UserValues">
<Attribute>UserValues</Attribute>
<Structure>subnode</Structure>
<Subscript>"UserValues"</Subscript>
</Data>
</Storage>
</Class>


<Class name="HPRIM.EDI.E1238.MsgBodyMethods">
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>HPRIME1238,%systemInclude</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Util.MessageBodyMethods</Super>
<System>4</System>
<TimeChanged>64175,60538</TimeChanged>
<TimeCreated>59318,79308.939</TimeCreated>

<Method name="%GetContentType">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit "text/html"
]]></Implementation>
</Method>

<Method name="%ShowContents">
<FormalSpec>pZenOutput:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	If pZenOutput {
		Do ..OutputHTMLZen()
	}
	Else {
		Do ..OutputHTML()
	}
]]></Implementation>
</Method>

<Method name="%ShowContentsHead">
<FormalSpec>pZenOutput:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	/* Styles for EDI segment display */

	If '$g(%donotoverwritestyles) {
		&html<<LINK REL="stylesheet" TYPE="text/css" HREF="csputils.css" TITLE="Standard Style" >>
	}

	&html<
<style>

/* EDI Document Table */
TABLE.EDIDocumentTable {
		border: black solid 1px; font-size: 0.8em;
		background: #DDDDFF;
		margin-left: 10px; margin-right: 10px;
		width: 10;
	}

TD.EDIDocumentTableExpandor {
		background: #D0D0FF;
		border-bottom: gray solid 1px;
		padding: 2px;
	}

TD.EDIDocumentTableSegnum {
		background: white;
		font-weight: bold;
		text-align: right;
		border-bottom: gray solid 1px;
		padding: 2px;
	}

TD.EDIDocumentTableSegid {
		background: white;
		border-bottom: gray solid 1px;
		border-right: gray solid 1px;
		padding: 2px;
	}

TD.EDIDocumentTableSegname {
		background: #D0D0FF;
		text-align: center;
		font-weight: bold;
		border-bottom: gray solid 1px;
		padding: 2px;
	}

/* -- Segment single-row Table */
TABLE.EDISegmentsTable {
		background: white;
		font-size: 0.9em;
		border-bottom: gray solid 1px;
	}

TD.EDISegmentsTableValue {
		background: white;
		padding: 2px;
	}

TD.EDISegmentsTableSeparator {
		background: white;
		padding: 2px;
	}

TD.EDISegmentsTableEmptyfield {
		background: white;
		padding: 2px;
	}
</style>
	>
]]></Implementation>
</Method>

<Method name="chooseDocType">
<FormalSpec>*pDocDesc</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tDocType=..DocType
	If ""'=tDocType && ##class(HPRIM.EDI.E1238.Schema).ElementExists("DS:"_tDocType) {
		Set pDocDesc="E1238 Document"
	} Else {
		Set tDocType=""
	}
	Quit tDocType
]]></Implementation>
</Method>

<Method name="%DrawHTMLTable">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pObj:%RegisteredObject,&pID:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	&html<<div>>
	Do pObj.%ShowContentsHead()
	Do pObj.OutputHTML()
	&html<</div><br/>ASTM document object properties:>
	Quit ##class(%CSP.Util.AutoFormDynamic).DrawHTMLTable(pObj, .pID)
]]></Implementation>
</Method>

<Method name="%DrawHTMLForm">
<Description>
This method is called by the Management Portal to display a message-specific content editor</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pObj:%RegisteredObject,&pID:%String,pActionURL:%String="",&pButtons:%CSP.Util.FormButton,pTarget:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	&html<<br/>A2.2 document content:<br/>
	<div><textarea name="%XCONT" rows="20" cols="100" style="border: 1px black solid;">>
	Do pObj.OutputToDevice(pObj.Separators_$C(13,10),0,0)
	&html<</textarea></div></br>E1238 document object properties:>
	Set pID("XCONT")=""
	Quit ##class(%CSP.Util.AutoFormDynamic).DrawHTMLForm(pObj, .pID, pActionURL, .pButtons, pTarget)
]]></Implementation>
</Method>

<Method name="%ProcessSubmit">
<Description><![CDATA[
This method is called by the Management Portal to 
display a message-specific content editor.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pRequest:%CSP.Request,&pID:%String="",*pErrorMsg:%String]]></FormalSpec>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[
	#; apply %request changes to old stored object or to new object if no old ID
	Set pErrorMsg=""
	Set tOldObj=##class(%CSP.Util.AutoFormDynamic).ProcessSubmit(pRequest, .pID, .pErrorMsg, 0)
	Quit:'$IsObject(tOldObj) $$$NULLOREF
	If ""'=tOldObj.%Id() {
		// It's a resend, not a testing request
		Kill %objlasterror
		Set tOldObj=tOldObj.%ConstructClone() ; clone it so as not to save changes to the original
		If '$IsObject(tOldObj) {
			Set tSC=$G(%objlasterror,$$$OK)
			Set pErrorMsg=pErrorMsg_" Failed to clone edited E1238 message object"
			Set:$$$ISERR(tSC) pErrorMsg=pErrorMsg_" - Status "_$$$StatusDisplayString(tSC)
			Quit $$$NULLOREF
		}
		Set tSource=tOldObj.Source_$C(13)_"; Edited copy of "_$G(pID(1))
		#; get rid of old content
		Do tOldObj.Clear()  Set tOldObj.Source=tSource
	}

	Set tData=$G(pRequest.Data("$IDXCONT",1))
	If $IsObject(tData) {
		Set tTempObj=..ImportFromLibraryStream(tData,.tSC)
	} Else {
		Set tTempObj=..ImportFromString(tData,.tSC)
	}
	If $$$ISERR(tSC)||'$IsObject(tTempObj) {
		If '$IsObject(tTempObj) {
			Set pErrorMsg=pErrorMsg_" Failed to import E1238 message text"
			Set:$$$ISERR(tSC) pErrorMsg=pErrorMsg_" - Status "_$$$StatusDisplayString(tSC)
			Quit $$$NULLOREF
		}
		Set pErrorMsg=pErrorMsg_$$$StatusDisplayString(tSC)
	}
	Set tOldObj.Separators=tTempObj.Separators
	Set tSC=tOldObj.CopyValues(tTempObj,"()","()","set","")
	If $$$ISERR(tSC) {
		Set pErrorMsg=pErrorMsg_"Failed to update E1238 message content - Status "_" "_$$$StatusDisplayString(tSC)
		Quit $$$NULLOREF
	}
	Set:$$$ISOK(tSC) tSC=tOldObj.%Save() ;  needed to prevent TempObj's segment data from dying with it.
	Quit tOldObj
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Operation.FTPOperation">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>HPRIM.EDI.E1238.Operation.Standard</Super>
<System>4</System>
<TimeChanged>64175,60603</TimeChanged>
<TimeCreated>59318,79308.949</TimeCreated>

<Property name="Filename">
<Description><![CDATA[
Name of file to output the document(s) to. May include timestamp specifiers. The %f specifier if present will be
replaced with the name of the document's original source stream. (stripped of characters illegal in filenames).<p>
See the method Ens.Util.File.CreateTimestamp() for documentation of timestamping options.]]></Description>
<Type>%String</Type>
<InitialExpression>"%f_%Q"</InitialExpression>
<Required>1</Required>
<Parameter name="MAXLEN" value="1000"/>
<Parameter name="MINLEN" value="1"/>
</Property>

<Parameter name="SETTINGS">
<Type>%String</Type>
<Default>Filename:Basic</Default>
</Parameter>

<Parameter name="ADAPTER">
<Default>EnsLib.FTP.OutboundAdapter</Default>
</Parameter>

<Property name="%TempStream">
<Type>%IO.FileStream</Type>
</Property>

<Method name="OnInit">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..%TempStream=..%TempStreamNewObject()
 	Do ..%TempStream.Open("","RWN",,"",.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit ##super()
]]></Implementation>
</Method>

<Method name="OnMessage">
<Description>
This method is for File and FTP Operations: per-message output with no reply. TCP and HTTP Operations
can receive reply messages.</Description>
<FormalSpec>pRequest:HPRIM.EDI.E1238.Document,*pResponse:HPRIM.EDI.E1238.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Output the main Document
	Set tSeparators=$S($L(..Separators)>=4:..Separators, 1:pRequest.Separators)
	Set tFilename=..Adapter.CreateTimestamp(##class(%File).GetFilename($P(pRequest.Source,$C(13))),..Filename)
	$$$sysTRACE("About to "_$S(..Adapter.Overwrite:"Store",1:"Append")_" ASTM document "_pDocument.%Id()_" / "_pDocument_" by FTP at "_..Adapter.fixSvrPath(..Adapter.%LastSetFilePath,1)_pFilename)
	Set tSC=..Adapter.PutStream(tFilename,pRequest,tSeparators)  Quit:$$$ISERR(tSC) tSC
	$$$sysTRACE("After writing ASTM document "_pRequest_"/"_pRequest.%Id()_" by FTP")
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Operation.FileOperation">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>HPRIM.EDI.E1238.Operation.Standard</Super>
<System>4</System>
<TimeChanged>64176,56348.5095</TimeChanged>
<TimeCreated>59318,79308.949</TimeCreated>

<Property name="Filename">
<Description><![CDATA[
Name of file to output the document(s) to. May include timestamp specifiers. The %f specifier if present will be 
replaced with the name of the document's original source stream. (stripped of characters illegal in filenames).<p>
See the method Ens.Util.File.CreateTimestamp() for documentation of timestamping options.]]></Description>
<Type>%String</Type>
<InitialExpression>"%f_%Q"</InitialExpression>
<Required>1</Required>
<Parameter name="MAXLEN" value="1000"/>
<Parameter name="MINLEN" value="1"/>
</Property>

<Property name="ASegmentsEnabled">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="MaxSegmentSize">
<Type>%Integer</Type>
<InitialExpression>220</InitialExpression>
<Parameter name="MAXVAL" value="500"/>
<Parameter name="MINVAL" value="20"/>
</Property>

<Property name="FileOK">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="OKSpec">
<Type>%String</Type>
<InitialExpression>"ok"</InitialExpression>
<Parameter name="MAXLEN" value="10"/>
</Property>

<Parameter name="SETTINGS">
<Type>%String</Type>
<Default><![CDATA[Filename:Basic,FileOK:Basic,OKSpec:Basic,ASegmentsEnabled:Advanced,MaxSegmentSize:Advanced,ReplyCodeActions,RetryInterval,AlertRetryGracePeriod:Alerting,FailureTimeout,QueueCountAlert:Alerting,QueueWaitAlert:Alerting,SendSuperSession,ThrottleDelay,AlertOnError:Alerting,InactivityTimeout:Alerting,BusinessPartner:Info:partnerSelector,AlertGroups:Alerting:selector?multiSelect=1&context={Ens.ContextSearch/ProductionAlertGroups?productionName=@productionId}]]></Default>
</Parameter>

<Parameter name="ADAPTER">
<Default>EnsLib.File.OutboundAdapter</Default>
</Parameter>

<Method name="OnMessage">
<Description>
This method is for File and FTP Operations: per-message output with no reply. TCP and HTTP Operations
can receive reply messages.</Description>
<FormalSpec>pRequest:HPRIM.EDI.E1238.Document,*pResponse:HPRIM.EDI.E1238.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Output the main Document
	set tSC=0
	set tSeparators=$S($L(..Separators)>=5:..Separators, 1:pRequest.Separators)
	set tFilename=..Adapter.CreateFilename(##class(%File).GetFilename($P(pRequest.Source,$C(13))),..Filename)
		
	if ('..ASegmentsEnabled)
	{
		Set tSC=..Adapter.PutStream(tFilename,pRequest,tSeparators)  Quit:$$$ISERR(tSC) tSC
		$$$sysTRACE("After "_$S(..Adapter.Overwrite:"storing",1:"appending")_" E1238 document "_pRequest_"/"_pRequest.%Id()_" to file "_tFilename)
	}
	else
	{
		
		set inputStream = ##class(%Stream.GlobalCharacter).%New()
		set outputStream = ##class(%Stream.GlobalCharacter).%New()
		set nbL=0
		$$$LOGINFO("separators:"_pRequest.Separators)
		$$$LOGINFO("first separator:"_$extract(pRequest.Separators,1,1))
		do pRequest.OutputToLibraryStream(.inputStream)
		do inputStream.Rewind()
		while ('inputStream.AtEnd) {
			set line = inputStream.ReadLine()
			do:($extract(line,1,2))'=("L"_$extract(pRequest.Separators,1,1)) ..getLinesWithASegments(line,.outputStream,.nbL)
		}
		set nbL=nbL+1
    	set lastLine="L|1||1|"_nbL
		Set tSC = outputStream.WriteLine(lastLine)
		
		Set tSC=..Adapter.PutStream(tFilename,outputStream)  Quit:$$$ISERR(tSC) tSC
		$$$sysTRACE("After "_$S(..Adapter.Overwrite:"storing",1:"appending")_" E1238 document "_pRequest_"/"_pRequest.%Id()_" to file "_tFilename)
	}
	if (tSC && ..FileOK)
	{
		s fileOKName = $P(tFilename,".",1)_"."_..OKSpec
		s emptyStream = ##class(%Stream.GlobalCharacter).%New()
		s tSC = ..Adapter.PutStream(fileOKName,emptyStream)  Quit:$$$ISERR(tSC) tSC
		$$$sysTRACE("After "_$S(..Adapter.Overwrite:"storing",1:"appending")_" ACK to file "_tFilename)
	}
	
	return tSC
]]></Implementation>
</Method>

<Method name="getLinesWithASegments">
<FormalSpec><![CDATA[ligne:%String(MAXLEN=""),&stream:%GlobalCharacterStream,&nbL:%Integer]]></FormalSpec>
<Implementation><![CDATA[
	
	if $length(ligne)>..MaxSegmentSize {
		set ligne1=$extract(ligne,1,..MaxSegmentSize)
		set tSC = stream.WriteLine(ligne1)
		set nbL=nbL+1
		for i=1:1:$length(ligne)\..MaxSegmentSize {
			set deb=(i*..MaxSegmentSize)+(1*i)
			set fin=deb+..MaxSegmentSize
			set ligneA="A|"_$extract(ligne,deb,fin)
			set tSC = stream.WriteLine(ligneA)
			set nbL=nbL+1
		}
		set deb=fin+1
		set fin=$length(ligne)
		set ligneA="A|"_$extract(ligne,deb,$length(ligne))
	} else {
		set tSC = stream.WriteLine(ligne)
		set nbL=nbL+1
	}
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Operation.Standard">
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>HPRIME1238</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessOperation</Super>
<System>4</System>
<TimeChanged>64175,60603</TimeChanged>
<TimeCreated>59318,79308.949</TimeCreated>

<Property name="Separators">
<Description><![CDATA[
String of separator characters to use in encoding outbound documents. Order is Field separator, Repeat separator, ComponentSeparator, Escape separator.<p>
Empty string means use the default values of the outbound document.]]></Description>
<Type>%String</Type>
<InitialExpression>$$$E1238DefSeparators</InitialExpression>
<Parameter name="MAXLEN" value="5"/>
</Property>

<Property name="SearchTableClass">
<Description><![CDATA[
Store a set of searchable properties in SearchTable records associated with each document processed.<p>
These records will be of the named SearchTable class, if any.]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="100"/>
</Property>

<Parameter name="SETTINGS">
<Default>Separators,SearchTableClass::selector?context={Ens.ContextSearch/SearchTableClasses?host=HPRIM.EDI.E1238.Operation.Standard},LineTerminator:Test</Default>
</Parameter>

<Property name="Validation">
<Description>
Comma-separated string specifying types of Validation to perform; make it a Setting in your subclass if you override OnValidate() and need to provide options</Description>
<Type>%String</Type>
</Property>

<UDLText name="T">
<Content><![CDATA[/* override default value */
]]></Content>
</UDLText>

<Property name="FailureTimeout">
<Description>
How long to keep retrying before giving up and returning an error code</Description>
<Type>%Numeric</Type>
<InitialExpression>-1</InitialExpression>
<Parameter name="MINVAL" value="-1"/>
</Property>

<Parameter name="IndexReplies">
<Description>
If SearchTableClass is set, use it to index any replies (including ACKs unless IndexACKs=false)</Description>
<Type>%Boolean</Type>
<Default>0</Default>
</Parameter>

<Method name="OnValidate">
<Description>
Override this method to implement your own custom method for validating of an incoming Document</Description>
<FormalSpec>pDoc:EnsLib.EDI.Document,pValSpec:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 0
]]></Implementation>
</Method>

<Method name="validateAndIndex">
<FormalSpec>pDoc:EnsLib.EDI.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ""=..Validation||'$zobjmethod($this,"OnValidate",pDoc,..Validation,.tSC) { /* no default validation */ }
	Set:'$D(tSC) tSC=$$$OK
	If $$$ISERR(tSC) {
		Set ..SuspendMessage=1
		Do ..SendAlert(##Class(Ens.AlertRequest).%New($LB(..%ConfigName,"Suspended document "_pDoc.%Id()_" because it failed validation using spec '"_..Validation_"' with error "_$$$StatusDisplayString(tSC))))
		Quit tSC
	}
	If ""'=..SearchTableClass {
		TRY {		
			Set tSCStore=$zobjclassmethod(..SearchTableClass,"IndexDoc",pDoc)
			If $$$ISERR(tSCStore) $$$LOGWARNING("Failed to construct SearchTable entries for document "_pDoc_"/"_pDoc.%Id()_" with DocType='"_pDoc.DocType_"' using class '"_..SearchTableClass_"' "_$$$StatusDisplayString(tSCStore))
		} CATCH errobj { $$$LOGWARNING("Failed to invoke SearchTable method "_..SearchTableClass_".IndexDoc() for message "_pDoc_"/"_pDoc.%Id()_" with DocType='"_pDoc.DocType_"' : "_errobj.AsSystemError()) }
	}
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Operation.TCPOperation">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>HPRIM.EDI.E1238.Operation.Standard</Super>
<System>4</System>
<TimeChanged>64175,60604</TimeChanged>
<TimeCreated>59318,79308.949</TimeCreated>

<Parameter name="ADAPTER">
</Parameter>

<Property name="PartnerService">
<Description>
The name of an ASTM service to which outbound messages will be forwarded for sending
to a remote ASTM device.  Additionally the IP address of the remote ASTM device may
be appended after a colon if the service allows connections from multiple remote
devices. Services with JobPerConnection = true will not receive messages from this
operation unless the IP address is appended.  Services with JobPerConnection = false
will work with just the service name entered here.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
</Property>

<Property name="ResponseTimeout">
<Description>
In the case a synchronous response is called for by the sender, this value governs how long this Operation should wait for a response from the instrument via the PartnerService.
A value of -1 means to wait forever and not fail.  Note that this may prevent un-forced shutdown of this Operation.</Description>
<Type>%Numeric</Type>
<InitialExpression>-1</InitialExpression>
</Property>

<Parameter name="SETTINGS">
<Default><![CDATA[PartnerService:Basic:selector?context={Ens.ContextSearch/ProductionItems?services=1&productionName=@productionId}]]></Default>
</Parameter>

<Method name="OnInit">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:""'=..PartnerService&&(""=$G($$$DispatchNameToConfigName($P(..PartnerService,":")))) $$$ERROR($$$EnsErrGeneral,"Configured PartnerService '"_..PartnerService_"' is not registered to run")
	If ""'=$P(..PartnerService,":",2,99) {
		Set tItem=##class(Ens.Host).GetShadowInstance($P(..PartnerService,":"))
		Quit:""=tItem.Adapter.JobPerConnection&&("!"'=$E(tItem.Adapter.AllowedIPAddresses)) $$$ERROR($$$EnsErrGeneral,"Can only send to PartnerService '"_..PartnerService_"' if it uses JobPerConnection or if a remote IP address is appended to its name")
	}
	Quit:'$classmethod($$$ConfigClassName($P(..PartnerService,":")),"%Extends","HPRIM.EDI.E1238.Service.TCPService") $$$ERROR($$$EnsErrGeneral,"Configured Partner Service '"_..PartnerService_"' does not extend HPRIM.EDI.E1238.Service.TCPService")
	Quit ##super()
]]></Implementation>
</Method>

<Method name="OnMessage">
<FormalSpec>pRequest:HPRIM.EDI.E1238.Document,*pResponse:%Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pResponse=$$$NULLOREF
	Set tSC=..validateAndIndex(pRequest)  Quit:$$$ISERR(tSC) tSC

	If ""'=$P(..PartnerService,":",2,99) || (""=..%RequestHeader.ReturnQueueName) {
	}
	Set tServiceQueue=$S(
	   ""'=$P(..PartnerService,":",2,99):..PartnerService
	  ,$P(pRequest.Envelope,":")=..PartnerService:pRequest.Envelope
	  ,$P(pRequest.Source,":")=..PartnerService:$P(pRequest.Source,$C(13))
	  ,1:..PartnerService)
	Quit:""=tServiceQueue $$$ERROR($$$EnsErrGeneral,"Unable to determine PartnerService to which to forward ASTM document "_pRequest_"/"_pRequest.%Id())

	#; Output the main Document
	Set tSC=..EnQueueToService(tServiceQueue,pRequest,..%RequestHeader,.tNewRequestHeader)
	Quit:$$$ISERR(tSC)||(""=..%RequestHeader.ReturnQueueName) tSC

	#; Wait (no timeout) for response to come back
	$$$catTRACE("protocol","Waiting for a response from the remote instrument connected to the ASTM partner service '"_tServiceQueue_"' with timeout "_..ResponseTimeout)
	Set tSC=..DeQueueFromService(.pResponse,.tResponseHeader,tNewRequestHeader,..ResponseTimeout)
	Set:$$$ISERR(tSC)&&$$$StatusEquals(tSC,$$$EnsErrInConnectionLost,$$$EnsErrTCPReadTimeoutExpired) ..Retry=1
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnQueueToService">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTargetQueueName:%String,pRequest:HPRIM.EDI.E1238.Document,pOriginalHeader:Ens.MessageHeader,*pNewHeader:Ens.MessageHeader</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ##class(Ens.MessageHeader).NewRequestMessage(.pNewHeader,pRequest,pOriginalHeader.SessionId) Quit:$$$ISERR(tSC) tSC
	Set pNewHeader.CorrespondingMessageId = pOriginalHeader.%Id()
	Set pNewHeader.SourceConfigName = pOriginalHeader.TargetConfigName
	Set pNewHeader.TargetConfigName = $P(pTargetQueueName,":")
	Set pNewHeader.SourceBusinessType = $$$eHostTypeOperation
	Set pNewHeader.TargetBusinessType = $$$eHostTypeService
	Set pNewHeader.TargetQueueName = pTargetQueueName
	Set:""'=pOriginalHeader.ReturnQueueName pNewHeader.ReturnQueueName = $$$queueSyncCallQueueName
	Set pNewHeader.Description = "ASTM forwarded message"
	Quit ##class(Ens.Queue).EnQueue(pNewHeader)
]]></Implementation>
</Method>

<Method name="DeQueueFromService">
<Description>
Code copied from the second half of Ens.Queue:queueRequestSync()</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pResponse:HPRIM.EDI.E1238.Document,*pResponseHeader:Ens.MessageHeader,pRequestHeader:Ens.MessageHeader=$$$NULLOREF,pTimeout:%Numeric=-1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	While 1 {
		Set tSC = ##class(Ens.Queue).DeQueue($$$queueSyncCallQueueName,.tResponseHeader,pTimeout,.tIsTimedOut,0)  Quit:$$$ISERR(tSC)
		Quit:tIsTimedOut 
		Continue:$IsObject(tResponseHeader)=0
		If tResponseHeader.CorrespondingMessageId=pRequestHeader.%Id() {
			If tResponseHeader.IsError {
				Set tSC=tResponseHeader.ErrorStatus
				Do tResponseHeader.SetStatus($$$eMessageStatusCompleted)
				Quit
			}
			If tResponseHeader.MessageBodyClassName'="" {
				Set pResponse=$classmethod(tResponseHeader.MessageBodyClassName,"%OpenId",tResponseHeader.MessageBodyId,,.tSC)
				If pResponse=$$$NULLOREF Set tSC=$$$EnsError($$$EnsErrGeneral,"Could not open MessageBody "_tResponseHeader.MessageBodyId_" for MessageHeader #"_tResponseHeader.%Id()_" with body class "_tResponseHeader.MessageBodyClassName_":"_$$$StatusDisplayString(tSC)) Quit
			}
			Do tResponseHeader.SetStatus($$$eMessageStatusCompleted)
			Quit
		}
		$$$sysTRACE("Out-of-band message '"_tResponseHeader.%Id()_"' discarded")
		Do tResponseHeader.SetStatus($$$eMessageStatusDiscarded)
	}
	Set tSC2 = ##class(Ens.Queue).Delete($$$queueSyncCallQueueName,"*")
	Quit tSC
]]></Implementation>
</Method>

<Method name="IOLogDiscard">
<Description>
Add discarded characters to IO Archive</Description>
<Internal>1</Internal>
<FormalSpec>pSC:%Status,pNote:%String,pDiscard:%GlobalCharacterStream</FormalSpec>
<Implementation><![CDATA[
	Set tIOLogEntry = ..IOLogEntry, ..IOLogEntry=$$$NULLOREF ; Save a separate entry for the unexpected input
	$$$NEWOUTIOLOGENTRY(pSC,pNote,$$$CurrentMethod,"%GlobalCharacterStream")
	$$$CLOSEIOLOGENTRY($$$OK,"",pDiscard)
	Set ..IOLogEntry = tIOLogEntry
]]></Implementation>
</Method>

<Method name="OnGetConnections">
<Description>
Return an array of connections for drawing lines on the config diagram</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pArray:%String,pItem:Ens.Config.Item</FormalSpec>
<Implementation><![CDATA[
	Do ##super(.pArray,pItem)
	If pItem.GetModifiedSetting("PartnerService",.tValue) {
		Set pArray($ZStrip($P(tValue,":"),"<>W"))=""
	}
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.PackedDocument">
<Super>HPRIM.EDI.E1238.Document</Super>
<TimeChanged>64176,41977.172867</TimeChanged>
<TimeCreated>63789,49755.887621</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id$</Default>
</Parameter>

<Property name="Separators">
<Description>
All 5 Separators as a String,FLDSEP_REPSEP_COMSEP_ESCSEP. Increased to maxlen 5 for E1238 (sysmex mostly)</Description>
<Type>%String</Type>
<Transient>1</Transient>
<Parameter name="MAXLEN" value="5"/>
<Parameter name="MINLEN" value="5"/>
</Property>

<Property name="FrameByRow">
<Description><![CDATA[
Set to 0 to break message into 240 char chunks, ignoring segment boundaries.<br/>
If set to 1 then use the normal E1238 document method to send to IO Stream - only break segments into 240 character chunks.
<br/>only required for sending out E1238 messages from Ensemble
]]></Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ChunkSize">
<Description><![CDATA[
Max Size of E1238 frame - usually 240 characters. Sysmex SUIT system use value >4000<br/>
only required for sending out E1238 messages from Ensemble]]></Description>
<Type>%Integer</Type>
<InitialExpression>240</InitialExpression>
</Property>

<Method name="OutputToIOStream">
<FormalSpec><![CDATA[pIOStream:%IO.I.CharacterStream,pSeparators:%String,&pDoFraming:%Integer=0,pResponseTimeout:%Numeric=-1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// initial setup for write
	#define ABS(%n)	$S(%n>=0:%n,1:-%n)
	Set tSC=$$$OK  Set pDoFraming=$S(pDoFraming>7:2, pDoFraming<-7:-2, 1:pDoFraming)
	Set tSeparators=$S(""=$G(pSeparators):..Separators, 1:pSeparators)  Set:""=tSeparators tSeparators=$$$E1238DefSeparators
	Do:'$D($$$vaM("runtimeIndex"))&&$D($$$vaM("runtimePath")) ..buildRuntimeIndexFromPath()
	SET $ZT="Trap"

	// flag set to use default chunking
	if ..FrameByRow {
		// copied from parent classes:
		
		For i=1:1:$G($$$vaM("runtimeIndex")) {
			Set tSeg=..getSegmentByIndex(i)
			//Set tSC=tSeg.OutputToIOStream(pIOStream, tSeparators, .pDoFraming, .pResponseTimeout)
			Set data=tSeg.GetValueAt("",.pSeparators)
			if $e(data,*)'=$c(13) set data=data_$c(13)
			Set j=0 While data'="" {
				Set tDone=(tSeg.ID=""||$D(tSeg.DataArray)||'$D($$$vaSegmentGbl(tSeg.ID,j+1)))

				If 'pDoFraming { Do pIOStream.Write(data,,.tSC)  Set data="" }
				Else {
					Set tFrameNum=$$$ABS(pDoFraming)-1
					Set tChunk=$E(data,1,..ChunkSize), data=$E(data,..ChunkSize+1,*)
					Set tChunk=tFrameNum_tChunk_$S(""=data&&tDone:$$$ETX,1:$$$ETB)
					Do pIOStream.Write($$$STX_tChunk_$$$CHKSUM(tChunk)_$C(13,10),(pDoFraming<0),.tSC)
					If pDoFraming<0 {
						While 1 {
							If pResponseTimeout=-1 {
								Read tACK#1
							} Else {
								Read tACK#1:pResponseTimeout  Set tTimedOut='$Test
								If tTimedOut Set tSC=$$$ERROR($$$EnsErrTCPReadTimeoutExpired,pResponseTimeout,"A2.2 Frame ACK","binary")  Quit
							}
							Quit:$$$ACK=tACK
							Continue:$C(13,10)[tACK
							Set tSC=$$$ERROR($$$EnsErrGeneral,"Received unexpected A2.2 Frame ACK character: Ascii "_$A(tACK))
							Quit
						}
						Set pDoFraming=-1-(tFrameNum+1#8)
					} Else {
						Set pDoFraming=1+(tFrameNum+1#8)
					}
				}
				Quit:$$$ISERR(tSC)
				if ""=data&&'tDone {
					set j=j+1,data=$G($$$vaSegmentGbl(tSeg.ID,j))
					if $e(data,*)'=$c(13) set data=data_$c(13)
				}

			}
			Do:$$$ISOK(tSC)&&'pDoFraming pIOStream.Write($C(10),,.tSC)

			Do ..commitSegmentByIndex(i)
		}
		
	} else {
		// send whole message as chunks
	
		Set data = ""
		Set tIOStream=##Class(%IO.MetaCharacterStream).%New(##class(%Stream.GlobalCharacter).%New())
		Set tIOStream.LineTerminator=$c(13)
	
		; output segments to stream without framing...
		For i=1:1:$G($$$vaM("runtimeIndex")) { Set tSeg=..getSegmentByIndex(i)		
			s tsc=tSeg.OutputToIOStream(tIOStream,tSeparators, 0, .pResponseTimeout)
			Do ..commitSegmentByIndex(i)
		}
	
		do tIOStream.Rewind()
		Set i=1 While 'tIOStream.AtEnd {

			If 'pDoFraming {
				set data=tIOStream.Read()
				Do pIOStream.Write(data,,.tSC)  Set data="" 
				}
		
			Else {
				Set tFrameNum=$$$ABS(pDoFraming)-1
				Set tChunk=$tr(tIOStream.Read(..ChunkSize),$c(10),"")
				Set tChunk=tFrameNum_tChunk_$S(tIOStream.AtEnd:$$$ETX,1:$$$ETB)
				Do pIOStream.Write($$$STX_tChunk_$$$CHKSUM(tChunk)_$C(13,10),(pDoFraming<0),.tSC)
				If pDoFraming<0 {
					While 1 {
						If pResponseTimeout=-1 {
							Read tACK#1
						} Else {
							Read tACK#1:pResponseTimeout  Set tTimedOut='$Test
							If tTimedOut Set tSC=$$$ERROR($$$EnsErrTCPReadTimeoutExpired,pResponseTimeout,"A2.2 Frame ACK","binary")  Quit
						}
						Quit:$$$ACK=tACK
						Continue:$C(13,10)[tACK
						Set tSC=$$$ERROR($$$EnsErrGeneral,"Received unexpected A2.2 Frame ACK character: Ascii "_$A(tACK))
						Quit
					}
					Set pDoFraming=-1-(tFrameNum+1#8)
				} Else {
					Set pDoFraming=1+(tFrameNum+1#8)
				}
			}
			Quit:$$$ISERR(tSC)
		}
	}
	
	// clean up buffer
	If $$$ISOK(tSC) {
		If pDoFraming { Do pIOStream.Write($$$EOT,1,.tSC) }
		Else { 
			if '..FrameByRow Do pIOStream.Write($C(10),,.tSC)
			Do pIOStream.Flush(.tSC)
			}
	}
	
Exit
	Quit tSC
Trap
	Set $ZT="", tZE=$ZE, tSC=$$$SystemError
	Goto Exit
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>PackedDocumentDefaultData</DefaultData>
<Data name="PackedDocumentDefaultData">
<Subscript>"PackedDocument"</Subscript>
<Value name="1">
<Value>FrameByRow</Value>
</Value>
<Value name="2">
<Value>ChunkSize</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="HPRIM.EDI.E1238.PackedParser">
<Description>
Parser for all segments in single frame</Description>
<Super>HPRIM.EDI.E1238.Parser</Super>
<TimeChanged>64175,60538</TimeChanged>
<TimeCreated>63789,49793.599691</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id$</Default>
</Parameter>

<UDLText name="T">
<Content><![CDATA[
// 13/9/12 added extra ENQ read for Horriba if conflict (similar to SIS)

]]></Content>
</UDLText>

<Method name="ParseIOStream">
<Description>
Parse a complete E1238 document from the stream</Description>
<FormalSpec><![CDATA[pIOStream:%IO.I.CharacterStream,*pDocument:HPRIM.EDI.E1238.Document,&pFrameNum:%Integer=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	Set (tSC,tSC1)=$$$OK, (pDocument,tDoc)=$$$NULLOREF, ..%Stream=pIOStream, tLine=""
	Set tStartTimeout=..StartTimeout
	Set tSubIndex=0, tSegDone=1, tSTX=..%ServiceInterface.%GetParameter("EOTOPTIONAL") ; force on expected TCP framing for this special kind of parse
	Set:'tSTX pFrameNum=1 ; reset Frame counter unless in EOTOPTIONAL mode
	
	#; Process any preceding stuff in the stream
	Set tSC=..%ServiceInterface.OnPreDocument(pIOStream,.tLine)
	if $$$ISERR(tSC)||(""=tLine&&pIOStream.AtEnd) quit tSC

	#; Read any data lines to end, just to make sure there is an actual document beginning there
	Set tFS=""
	Set (tSegName,tFirstSeg)=""
	While 'pIOStream.AtEnd && (tFirstSeg'="H") {
		Set tSC=..ReadSegment(pIOStream,tStartTimeout,.pFrameNum,.tLine,.tEOT,.tSTX)  Quit:$$$ISERR(tSC)||tEOT
		Set tStartTimeout=..ReadTimeout ; already started so go to read mode
		if $l(tLine) {
			Set tFS=$E($ZStrip($E(tLine,1,1+$$$MAXSEGNAME),"*AN")) ; separator is first non-alphanumeric char
			Set (tSegName,tFirstSeg)=$S(""=tFS:"", 1:$P(tLine,tFS))
			if tFirstSeg'="H" {
				$$$catTRACE("parse","Before H segment, discarded  '"_$$$MapCtlChars(tLine)_"'")
			}
		}
	}
	set tSegmentIds=""

	if $$$ISOK(tSC) && (tFirstSeg="H") {
	
		Set ..%SegmentCount=0
		
		// pg 17/2/11
		Set tSeparators=$E(tFS_$P(tLine,tFS,2),1,5)
        Set:$L(tSeparators)<5 tSeparators=tSeparators_$E($$$E1238DefSeparators,$L(tSeparators)+1,5)

		set tSegmentIds=""
		#; Store the data for all segments
		while $$$ISOK(tSC) && 'tEOT {  ; while
			set tSegmentIds=tSegmentIds_..StoreSegment(tLine,tSeparators)
			$$$catTRACE("parse","Got Segment "_..%SegmentCount_" '"_$$$MapCtlChars(tLine)_"'")
			Set tSC=..ReadSegment(pIOStream,tStartTimeout,.pFrameNum,.tLine,.tEOT,.tSTX)
		} 
		
		; loop through segments, processing documents
		set tLastSeg="",tSegStart=1
		for i=1:1:..%SegmentCount {
			set tSegInd=$lg(tSegmentIds,i)
			Set tDocPos=pIOStream.Name_$C(13,10)_", segment "_tSegInd_", @Line "_..%LineCount
			set tLine=$e($$$vaSegmentGbl(tSegInd),$l(tSeparators)+1,*)
			Set tSegName=$P($E(tLine,1,$$$MAXSEGNAME),tFS)

			//PG 17/2/11
			If tSegName'?1.3U {
				$$$LOGWARNING("Badly formed segment name '"_tSegName_"' at "_tDocPos_" ("_$$$MapCtlChars(tLine)_")")
				Quit
			}
			if tSegName="L" {
				Set tDoc=##class(HPRIM.EDI.E1238.Document).%New($LB($li(tSegmentIds,tSegStart,i),tSeparators,tDocPos))
				If '$IsObject(tDoc) Set tSC=%objlasterror Quit
				Set ..%CurrentDocument=tDoc

				#; Count the documents we encounter, nested
				Set tTypeName=tDoc.Name  Set:""=tTypeName tTypeName="?"
		
				#; Notify the Service of the new document beginning
				Set tSC1=..%ServiceInterface.OnDocumentStart(tDoc,tDocPos,tSC)  Quit:$$$ISERR(tSC1) // Fatal Error
	  			
				Set tSC1=..%ServiceInterface.OnDocumentEnd(tDoc,tDocPos,tSC1)  Quit:$$$ISERR(tSC1) // Fatal Error
				set tSegStart=i+1
	
			}
		} ; done doc
		if $$$ISERR(tSC) q tSC

		
		#; Process any trailing stuff in the stream
		Set tSC1=..%ServiceInterface.OnPostDocument(pIOStream,"")		
		
	} ; end if $l(tLine)
	Set:$$$ISERR(tSC1)&&(tSC'=tSC1) tSC=$$$ADDSC(tSC,tSC1)
	If $IsObject(tDoc) {
		Set ..%CurrentDocument=$$$NULLOREF
		Set pDocument=tDoc
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="StoreSegment">
<Description>
Save segment text in global</Description>
<FormalSpec>seg:%String,tSeparators:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	set tXSeg=$l(seg,$c(13)),tList=""
	for i=1:1:tXSeg {
		#; save the segment and add it to the message
		Set xseg=$p(seg,$c(13),i)
		if $l(xseg) {
			Set tIndex=$I($$$vaSegmentGbl)
			Set $$$vaSegmentGbl(tIndex)=tSeparators_xseg, ..%SegmentCount=..%SegmentCount+1
			set tList=tList_$lb(tIndex)
		}
	}
	quit tList
]]></Implementation>
</Method>

<Method name="ReadSegment">
<FormalSpec><![CDATA[pIOStream:%IO.I.CharacterStream,pTimeout:%Numeric,&pFrameNum:%Integer,*pLine:%String,*pEOT:%Boolean,*pSTX:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pLine="", pEOT=0,tSC=$$$OK
	While 'pIOStream.AtEnd {
		#; Read 1 char
		Set tTimeout=pTimeout, tFresh=pIOStream.Read(1,.tTimeout,.tSC)  Quit:$$$ISERR(tSC)
		
		// add another read if we get ENQ first 13/09/12 pg
		if tFresh=$$$ENQ s tFresh=pIOStream.Read(1,.tTimeout,.tSC)  Quit:$$$ISERR(tSC)

		If (pTimeout&&(tTimeout=pTimeout)) { Set tSC=$$$ERROR($$$EnsErrTCPReadTimeoutExpired,pTimeout,"A2.2 <STX>","binary")  Quit }
		If $$$EOT=tFresh {
			Set pLine=pLine_tFresh, pEOT=1
			If $$$EOT'=pLine { $$$LOGWARNING("Got extra line with EOT at "_pIOStream.Name_" @Line "_..%LineCount_" : '"_$$$MapCtlChars(pLine)_"'") }
			Else { $$$catTRACE("parse","Got EOT at "_pIOStream.Name_" @Line "_..%LineCount) }
			Quit
		} ElseIf $$$STX'=tFresh && pSTX {
			If "01234567"[tFresh && ..%ServiceInterface.%GetParameter("EOTOPTIONAL") {
				Set tFresh=$$$STX_tFresh ; in case we already got it in place of ENQ
			} Else {
				Set tSC=$$$ERROR($$$EnsErrGeneral,"Unexpected A2.2 frame STX character: Ascii "_$$$MapCtlChar(tFresh))
				Quit
			}
		}
		Continue:$C(13,10)[tFresh

		#; Read rest of line
		Kill tZB  Set tTimeout=pTimeout, tFresh=tFresh_$tr(pIOStream.ReadLine(32767,.tTimeout,.tSC,.tZB),$c(0))  Quit:$$$ISERR(tSC)
		If (pTimeout&&(tTimeout=pTimeout)) { Set tSC=$$$ERROR($$$EnsErrTCPTerminatedReadTimeoutExpired,pTimeout,"A2.2 <LF>",$$$MapCtlChars(pLine_tFresh))  Quit }
		Set:""'=tFresh||(""'=tZB) ..%LineCount=..%LineCount+1, ..%CharCount=..%CharCount+$L(tFresh)+$L(tZB)

		If $$$STX=$E(tFresh) {
			Set pSTX=1
			$$$catTRACE("parse","Got STX frame line #"_..%LineCount_" '"_$$$MapCtlChars(tFresh)_"'")
			If (""'=tZB) { Write $$$ACK,*-3 }
			Else { Set tSC=$$$ERROR($$$EnsErrGeneral,"Received incomplete A2.2 segment '"_$$$MapCtlChars(tFresh)_"' at "_pIOStream.Name_" @Line "_..%LineCount)  Quit }
			If pFrameNum'=$E(tFresh,2) { Set tSC=$$$ERROR($$$EnsErrGeneral,"Received bad A2.2 sequence number; expected "_pFrameNum_", got '"_$$$MapCtlChars($E(tFresh,2))_"' at "_pIOStream.Name_" @Line "_..%LineCount)  Quit }
			Set pFrameNum=(pFrameNum+1)#8
			Set tEOD=$L(tFresh)-3, tLine=$E(tFresh,3,tEOD-1)
			
			// ADDED IGNORE CHECKSUM PARAMETER FROM HOST SERVICE PG 30/4/12
			If $E(tFresh,tEOD+1,tEOD+2)'=$$$CHKSUM($E(tFresh,2,tEOD)) && '..%ServiceInterface.%GetParameter("IGNORECHECKSUM") { Set tSC=$$$ERROR($$$EnsErrGeneral,"Received bad A2.2 checksum "_$E(tFresh,tEOD+1,tEOD+2)_"; expected "_$$$CHKSUM($E(tFresh,2,tEOD))_", got '"_$$$MapCtlChars(tFresh)_"' at "_pIOStream.Name_" @Line "_..%LineCount)  Quit }
			//
			
			Set pLine=pLine_tLine
			If $$$ETX=$E(tFresh,tEOD) Set:$C(13)=$E(pLine,*) $E(pLine,$L(pLine))=""  Quit
			If $$$ETB'=$E(tFresh,tEOD) { Set tSC=$$$ERROR($$$EnsErrGeneral,"Received bad A2.2 frame character; expected ETX(3) or ETB(23), got "_$$$MapCtlChar($E(tFresh,tEOD))_" in '"_$$$MapCtlChars(tFresh))  Quit }
			If $Case($E(tFresh,tEOD+3,*),$C(13):0,"":0,:1) { Set tSC=$$$ERROR($$$EnsErrGeneral,"Found extra junk at end of A2.2 frame in '"_$$$MapCtlChars(tFresh)_"' at "_pIOStream.Name_" @Line "_..%LineCount)  Quit }
		} Else {
			Set pLine=..stripWhitespace(tFresh)
			$$$catTRACE("parse","Got raw line #"_..%LineCount_" '"_pLine_"'")
			Quit
		}
	}
	Set:""=pLine&&pIOStream.AtEnd pEOT=1
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Parser">
<Description>
This is the ASTM Intemmrchange parser</Description>
<ClassType/>
<IncludeCode>HPRIME1238</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeChanged>64175,60538</TimeChanged>
<TimeCreated>59803,48988.51097</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// Public Properties

]]></Content>
</UDLText>

<Property name="StartTimeout">
<Description>
Number of seconds to wait for the start of a document to be available on the input stream</Description>
<Type>%Numeric</Type>
<InitialExpression>5</InitialExpression>
<Parameter name="MINVAL" value="-1"/>
</Property>

<Property name="ReadTimeout">
<Description>
Number of seconds to wait for each read of document data inside a started document to be available on the input stream</Description>
<Type>%Numeric</Type>
<InitialExpression>5</InitialExpression>
<Parameter name="MINVAL" value="-1"/>
</Property>

<Property name="Done">
<Type>%Boolean</Type>
<Calculated>1</Calculated>
<ReadOnly>1</ReadOnly>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Private State Properties

]]></Content>
</UDLText>

<Property name="%Stream">
<Type>%IO.I.CharacterStream</Type>
</Property>

<Property name="%SegmentCount">
<Description>
Count of Segments tallied during parse of a TransactionSet</Description>
<Type>%Integer</Type>
</Property>

<Property name="%LineCount">
<Type>%Integer</Type>
</Property>

<Property name="%CharCount">
<Type>%Integer</Type>
</Property>

<Property name="%ServiceInterface">
<Description>
The config provider</Description>
<Type>EnsLib.EDI.ServiceInterface</Type>
</Property>

<Property name="%CurrentDocument">
<Description>
The current Document</Description>
<Type>EnsLib.EDI.Document</Type>
</Property>

<Property name="%CurrentParentSegIndex">
<Description>
The segment position within the current parent Document</Description>
<Type>%String</Type>
</Property>

<Property name="%CurrentParents">
<Description>
List of enclosing parent objects ordered from outermost to immediate
 As EnsLib.EDI.Document </Description>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="%ParentIds">
<Description>
List of enclosing parent objects ordered from immediate to outermost</Description>
<Type>%String</Type>
</Property>

<Property name="%NumChildren">
<Description>
List of counts of nested documents, ordered from outer to innermost</Description>
<Type>%Integer</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Framing">
<Description>
See your HL7 Config Items for a description of accepted values.</Description>
<Type>%String</Type>
</Property>

<Property name="IgnoreBlankLines">
<Description>
Don't consider a blank line to indicate the end of a document</Description>
<Type>%Boolean</Type>
</Property>

<Property name="%inFraming">
<Description>
pre-parse of Framing setting</Description>
<Type>%String</Type>
</Property>

<Property name="%outFraming">
<Description>
Framing to use on output if input framing is "Flexible"</Description>
<Type>%String</Type>
</Property>

<Property name="%LookaheadLine">
<Description>
Lookahead line left over from previous document parse</Description>
<Type>%String</Type>
</Property>

<Property name="%LookaheadLineTerminator">
<Description>
Lookahead buffer for line terminator of unframed MSH</Description>
<Type>%String</Type>
</Property>

<Property name="%LookaheadLineIsNew">
<Description>
Lookahead buffer for line terminator of unframed MSH</Description>
<Type>%Boolean</Type>
</Property>

<Property name="%EndBlock">
<Description>
EndBlock character(s) to look for as message end marker</Description>
<Type>%String</Type>
</Property>

<Property name="DefCharEncoding">
<Description><![CDATA[
Default Character Encoding to use when reading or writing E1238 messages. <p/>
If MSH field 18 (Character Set) is empty, this encoding will be used. Choices you can use for this setting include:<p/>
<ul>
<li>Native - use the default character encoding of the installed locale of the Ensemble server</li>
<li>latin1 - the ISO Latin1 8-bit encoding; this is the default</li>
<li>ISO-8859-1 - the ISO Latin1 8-bit encoding</li>
<li>UTF-8 - the Unicode 8-bit encoding</li>
<li>Unicode - the Unicode 16-bit encoding  (Little-Endian)</li>
<li>UnicodeBig - the Unicode 16-bit encoding (Big-Endian)</li>
<li>Any other NLS definitions installed on this Ensemble server</li>
<li>@&lt;ttable&gt; - &lt;ttable&gt; means a raw InterSystems character translation table name. A prefix of '@' means to use the named table.</li>
</ul>
Putting ! before the encoding name will force the use of the named encoding and will ignore any value found in MSH:18. <p/>]]></Description>
<Type>%String</Type>
</Property>

<Property name="RememberFlex">
<Description>
Set this if you want to make an interface that is set to Framing='Flexible' continue with the Framing style it detects in the first message it receives.
This can increase performance, reduce latency due to timeouts and ensure consistent behavior after initialization.
However, it will also reduce the ability of the interface to interpret changing input formats in successive messages from the same source or from different sources on sequential connections.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="DoneGet">
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[('$IsObject(..%Stream)||..%Stream.AtEnd)
]]></Implementation>
</Method>

<Method name="ReadSegment">
<FormalSpec><![CDATA[pIOStream:%IO.I.CharacterStream,pTimeout:%Numeric,&pFrameNum:%Integer,*pLine:%String,*pEOT:%Boolean,&pSTX:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pLine="", pEOT=0
	While 'pIOStream.AtEnd {
		#; Read 1 char
		Set tTimeout=pTimeout, tFresh=pIOStream.Read(1,.tTimeout,.tSC)  Quit:$$$ISERR(tSC)
		If (pTimeout&&(tTimeout=pTimeout)) { Set tSC=$$$ERROR($$$EnsErrTCPReadTimeoutExpired,pTimeout,"ASTM <STX>","binary")  Quit }
		If $$$EOT=tFresh {
			Set pLine=pLine_tFresh, pEOT=1
			If $$$EOT'=pLine { $$$LOGWARNING("Got extra line with EOT at "_pIOStream.Name_" @Line "_..%LineCount_" : '"_$$$MapCtlChars(pLine)_"'") }
			Else { $$$catTRACE("parse","Got EOT at "_pIOStream.Name_" @Line "_..%LineCount) }
			Quit
		} ElseIf $$$STX'=tFresh && pSTX {
			If ..%ServiceInterface.%GetParameter("EOTOPTIONAL") {
				If "01234567"[tFresh {
					Set tFresh=$$$STX_tFresh ; in case we already got it in place of ENQ
				} ElseIf $$$ENQ=tFresh {
					Write $$$ACK,*-3
					Set pFrameNum=1
					$$$LOGWARNING("Unexpected ASTM ENQ when expecting STX character at "_pIOStream.Name_" @Line "_..%LineCount_" : '"_$$$MapCtlChars(pLine)_"'; ACK'ing and continuing to wait for segment data")
					Continue
				} Else {
					Set tSC=$$$ERROR($$$EnsErrGeneral,"Unexpected ASTM character in place of STX: Ascii "_$$$MapCtlChar(tFresh))
					Quit
				}
			} Else {
				Set tSC=$$$ERROR($$$EnsErrGeneral,"Unexpected ASTM character in place of frame STX: Ascii "_$$$MapCtlChar(tFresh))
				Quit
			}
		}
		Continue:$C(13,10)[tFresh

		#; Read rest of line
		Kill tZB  Set tTimeout=pTimeout, tFresh=tFresh_pIOStream.ReadLine(32767,.tTimeout,.tSC,.tZB)  Quit:$$$ISERR(tSC)
		If (pTimeout&&(tTimeout=pTimeout)) { Set tSC=$$$ERROR($$$EnsErrTCPTerminatedReadTimeoutExpired,pTimeout,"ASTM <LF>",$$$MapCtlChars(pLine_tFresh))  Quit }
		Set:""'=tFresh||(""'=tZB) ..%LineCount=..%LineCount+1, ..%CharCount=..%CharCount+$L(tFresh)+$L(tZB)

		If $$$STX=$E(tFresh) {
			Set pSTX=1
			Set:tZB=$C(13,10) tFresh=tFresh_$C(13), tZB=$C(10)
			$$$catTRACE("parse","Got STX frame line #"_..%LineCount_" '"_$$$MapCtlChars(tFresh)_"'")
			If (""'=tZB) { Write $$$ACK,*-3 }
			Else { Set tSC=$$$ERROR($$$EnsErrGeneral,"Received incomplete ASTM segment '"_$$$MapCtlChars(tFresh)_"' at "_pIOStream.Name_" @Line "_..%LineCount)  Quit }
			If pFrameNum'=$E(tFresh,2) { Set tSC=$$$ERROR($$$EnsErrGeneral,"Received bad ASTM sequence number; expected "_pFrameNum_", got '"_$$$MapCtlChars($E(tFresh,2))_"' at "_pIOStream.Name_" @Line "_..%LineCount)  Quit }
			Set pFrameNum=(pFrameNum+1)#8
			Set tEOD=$L(tFresh)-3, tLine=$E(tFresh,3,tEOD-1)
			If $E(tFresh,tEOD+1,tEOD+2)'=$$$CHKSUM($E(tFresh,2,tEOD)) { Set tSC=$$$ERROR($$$EnsErrGeneral,"Received bad ASTM checksum "_$E(tFresh,tEOD+1,tEOD+2)_"; expected "_$$$CHKSUM($E(tFresh,2,tEOD))_", got '"_$$$MapCtlChars(tFresh)_"' at "_pIOStream.Name_" @Line "_..%LineCount)  Quit }
			Set pLine=pLine_tLine
			If $$$ETX=$E(tFresh,tEOD) Set:$C(13)=$E(pLine,*) $E(pLine,$L(pLine))=""  Quit
			If $$$ETB'=$E(tFresh,tEOD) { Set tSC=$$$ERROR($$$EnsErrGeneral,"Received bad ASTM frame character; expected ETX(3) or ETB(23), got "_$$$MapCtlChar($E(tFresh,tEOD))_" in '"_$$$MapCtlChars(tFresh)_"' at "_pDocPos)  Quit }
			If $Case($E(tFresh,tEOD+3,*),$C(13):0,"":0,:1) { Set tSC=$$$ERROR($$$EnsErrGeneral,"Found extra junk at end of ASTM frame in '"_$$$MapCtlChars(tFresh)_"' at "_pIOStream.Name_" @Line "_..%LineCount)  Quit }
		} Else {
			Set pLine=..stripWhitespace(tFresh)
			$$$catTRACE("parse","Got raw line #"_..%LineCount_" '"_pLine_"'")
			Quit
		}
	}
	Set:""=pLine&&pIOStream.AtEnd pEOT=1
	Quit tSC
]]></Implementation>
</Method>

<Method name="ParseIOStream">
<Description>
Parse a complete ASTM document from the stream</Description>
<FormalSpec><![CDATA[pIOStream:%IO.I.CharacterStream,*pDocument:HPRIM.EDI.E1238.Document,&pFrameNum:%Integer=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$ASSERT($IsObject(pIOStream))
	Set (tSC,tSC1)=$$$OK, (pDocument,tDoc)=$$$NULLOREF, ..%Stream=pIOStream, tLine=""
	Set tStartTimeout=..StartTimeout
	Set tSubIndex=0, tSegDone=1, tSTX=..%ServiceInterface.%GetParameter("EOTOPTIONAL") ; force on expected TCP framing for this special kind of parse
	Set:'tSTX pFrameNum=1 ; reset Frame counter unless in EOTOPTIONAL mode
	Do { ; While 0
		#; Process any preceding stuff in the stream
		Set tSC=..%ServiceInterface.OnPreDocument(pIOStream,.tLine)  Quit:$$$ISERR(tSC)||(""=tLine&&pIOStream.AtEnd)

		#; Read any blank lines to end, just to make sure there is an actual document beginning there
		While ""=tLine && 'pIOStream.AtEnd {
			Set tSC=..ReadSegment(pIOStream,tStartTimeout,.pFrameNum,.tLine,.tEOT,.tSTX)  Quit:$$$ISERR(tSC)||tEOT
			Set tStartTimeout=..ReadTimeout ; already started so go to read mode
		}
		Quit:""=tLine
		$$$catTRACE("parse","Got first Segment line '"_$$$MapCtlChars(tLine)_"'")
		Set ..%SegmentCount=0
		Set tFS=$E($ZStrip($E(tLine,1,1+$$$MAXSEGNAME),"*AN")) ; separator is first non-alphanumeric char
		Set (tSegName,tFirstSeg)=$S(""=tFS:"", 1:$P(tLine,tFS))
		Set tSeparators=tFS_$P(tLine,tFS,2)
        Set:$L(tSeparators)<5 tSeparators=tSeparators_$E($$$E1238DefSeparators,$L(tSeparators)+1,5)

		#; Store the data for the first segment
		Set tIndex=$I($$$vaSegmentGbl), $$$vaSegmentGbl(tIndex)=tSeparators_tLine, tLine="", ..%SegmentCount=..%SegmentCount+1
		
		#; Instantiate a document to hold the segment and any to follow
		Set tDocPos=pIOStream.Name_$S(..%LineCount<=2:"", 1:$C(13,10)_", @Line "_..%LineCount)
		Set tDoc=##class(HPRIM.EDI.E1238.Document).%New($LB($LB(tIndex),tSeparators,tDocPos))  If '$IsObject(tDoc) Set tSC=%objlasterror Quit
		Set ..%CurrentDocument=tDoc, tSegNum=2 ; tSegNum is current segment of current document

		Set tTypeName=tDoc.Name  Set:""=tTypeName tTypeName="?"
		
		#; Notify the Service of the new document beginning
		Set tSC1=..%ServiceInterface.OnDocumentStart(tDoc,tDocPos,tSC)  Quit:$$$ISERR(tSC1) // Fatal Error
	  
		#; Parse the rest of the segments in the current document
		#;$$$catTRACE("parse","tDoc="_tDoc)
		Set (tEOF,iRef,iRefSegId)=0
		Set i = 0
		While $$$ISOK(tSC)&&(""'=tLine||'(pIOStream.AtEnd||tEOF)) { ; loop over segs in the doc
			If ""=tLine {
				#; Read a segment line buffer
				Set tSC=..ReadSegment(pIOStream,..ReadTimeout,.pFrameNum,.tLine,.tEOT,.tSTX)  Quit:$$$ISERR(tSC)||tEOT
			}
			$$$catTRACE("parse","Got next Segment line '"_$$$MapCtlChars(tLine)_"'")
			Set tPrevSeg=tSegName, tSegName=$P($E(tLine,1,$$$MAXSEGNAME),tFS)
			Set tDocPos=pIOStream.Name_$C(13,10)_", segment "_tSegNum_", @Line "_..%LineCount
			// BSU - modified
			If (tSegName'?1U)&&(tSegName'?3U) {
				$$$LOGWARNING("Badly formed segment name '"_tSegName_"' in message "_tDoc.%Id()_" at "_tDocPos_" ("_$$$MapCtlChars(tLine)_")")
				Quit
			}	
			#; save the segment and add it to the message
			Set tIndex=$I($$$vaSegmentGbl)
			Set $$$vaSegmentGbl(tIndex)=tSeparators_tLine, tLine="", tSegNum=tSegNum+1, ..%SegmentCount=..%SegmentCount+1
			Set $$$vaMobj(tDoc,"runtimeIndex")=$$$vaMobj(tDoc,"runtimeIndex")+1, $$$vaMobja(tDoc,"runtimeIndex",$$$vaMobj(tDoc,"runtimeIndex"))=tIndex

			#; Quit if not interactive and at document end segment
			Quit:('tSTX||..%ServiceInterface.%GetParameter("EOTOPTIONAL"))&&(tSegName="L")&&(tFirstSeg="H")
			s i = i+1
		} ; done doc
		Quit:$$$ISERR(tSC)

		Set tDocPos=pIOStream.Name_$C(13,10)_", @Line "_..%LineCount
		Set tSC1=..%ServiceInterface.OnDocumentEnd(tDoc,tDocPos,tSC1)  Quit:$$$ISERR(tSC1) // Fatal Error
		
		#; Process any trailing stuff in the stream
		Set tSC1=..%ServiceInterface.OnPostDocument(pIOStream,"")
	} While 0
	Set:$$$ISERR(tSC1)&&(tSC'=tSC1) tSC=$$$ADDSC(tSC,tSC1)
	If $IsObject(tDoc) {
		Set ..%CurrentDocument=$$$NULLOREF
		Set pDocument=tDoc
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ParseFramedIOStream">
<Description>
Method used by countedTCPAdapter to correctly read ASTM segments</Description>
<FormalSpec><![CDATA[pIOStream:%IO.I.CharacterStream,&pDocument:HPRIM.EDI.E1238.Document,pInbound:%Boolean=0,&pIOLogEntry:Ens.Util.IOLog=$$$NULLOREF]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$ASSERT($IsObject(pIOStream))
	Set (tSC,tSC1)=$$$OK, (pDocument,tDoc)=$$$NULLOREF, ..%Stream=pIOStream, tLine=""
	Set tStartTimeout=..StartTimeout
	Set tSubIndex=0, tSegDone=1, tSTX=..%ServiceInterface.%GetParameter("EOTOPTIONAL") ; force on expected TCP framing for this special kind of parse
	Set:'tSTX pFrameNum=1 ; reset Frame counter unless in EOTOPTIONAL mode
	Do { ; While 0
		#; Process any preceding stuff in the stream
		Set tSC=..%ServiceInterface.OnPreDocument(pIOStream,.tLine)  Quit:$$$ISERR(tSC)||(""=tLine&&pIOStream.AtEnd)

		#; Read any blank lines to end, just to make sure there is an actual document beginning there
		While ""=tLine && 'pIOStream.AtEnd {
			Set tSC=..ReadSegment(pIOStream,tStartTimeout,.pFrameNum,.tLine,.tEOT,.tSTX)  Quit:$$$ISERR(tSC)||tEOT
			Set tStartTimeout=..ReadTimeout ; already started so go to read mode
		}
		Quit:""=tLine
		$$$catTRACE("parse","Got first Segment line '"_$$$MapCtlChars(tLine)_"'")
		Set ..%SegmentCount=0
		Set tFS=$E($ZStrip($E(tLine,1,1+$$$MAXSEGNAME),"*AN")) ; separator is first non-alphanumeric char
		Set (tSegName,tFirstSeg)=$S(""=tFS:"", 1:$P(tLine,tFS))
		Set tSeparators=tFS_$P(tLine,tFS,2)
        Set:$L(tSeparators)<5 tSeparators=tSeparators_$E($$$E1238DefSeparators,$L(tSeparators)+1,5)

		#; Store the data for the first segment
		Set tIndex=$I($$$vaSegmentGbl), $$$vaSegmentGbl(tIndex)=tSeparators_tLine, tLine="", ..%SegmentCount=..%SegmentCount+1
		
		#; Instantiate a document to hold the segment and any to follow
		Set tDocPos=pIOStream.Name_$S(..%LineCount<=2:"", 1:$C(13,10)_", @Line "_..%LineCount)
		Set tDoc=##class(HPRIM.EDI.E1238.Document).%New($LB($LB(tIndex),tSeparators,tDocPos))  If '$IsObject(tDoc) Set tSC=%objlasterror Quit
		Set ..%CurrentDocument=tDoc, tSegNum=2 ; tSegNum is current segment of current document

		Set tTypeName=tDoc.Name  Set:""=tTypeName tTypeName="?"
		
		#; Notify the Service of the new document beginning
		Set tSC1=..%ServiceInterface.OnDocumentStart(tDoc,tDocPos,tSC)  Quit:$$$ISERR(tSC1) // Fatal Error
	  
		#; Parse the rest of the segments in the current document
		#;$$$catTRACE("parse","tDoc="_tDoc)
		Set (tEOF,iRef,iRefSegId)=0
		Set i = 0
		While $$$ISOK(tSC)&&(""'=tLine||'(pIOStream.AtEnd||tEOF)) { ; loop over segs in the doc
			If ""=tLine {
				#; Read a segment line buffer
				Set tSC=..ReadSegment(pIOStream,..ReadTimeout,.pFrameNum,.tLine,.tEOT,.tSTX)  Quit:$$$ISERR(tSC)||tEOT
			}
			$$$catTRACE("parse","Got next Segment line '"_$$$MapCtlChars(tLine)_"'")
			Set tPrevSeg=tSegName, tSegName=$P($E(tLine,1,$$$MAXSEGNAME),tFS)
			Set tDocPos=pIOStream.Name_$C(13,10)_", segment "_tSegNum_", @Line "_..%LineCount
			// BSU - modified
			If (tSegName'?1U)&&(tSegName'?3U) {
				$$$LOGWARNING("Badly formed segment name '"_tSegName_"' in message "_tDoc.%Id()_" at "_tDocPos_" ("_$$$MapCtlChars(tLine)_")")
				Quit
			}	
			#; save the segment and add it to the message
			Set tIndex=$I($$$vaSegmentGbl)
			Set $$$vaSegmentGbl(tIndex)=tSeparators_tLine, tLine="", tSegNum=tSegNum+1, ..%SegmentCount=..%SegmentCount+1
			Set $$$vaMobj(tDoc,"runtimeIndex")=$$$vaMobj(tDoc,"runtimeIndex")+1, $$$vaMobja(tDoc,"runtimeIndex",$$$vaMobj(tDoc,"runtimeIndex"))=tIndex

			#; Quit if not interactive and at document end segment
			Quit:('tSTX||..%ServiceInterface.%GetParameter("EOTOPTIONAL"))&&(tSegName="L")&&(tFirstSeg="H")
			s i = i+1
		} ; done doc
		Quit:$$$ISERR(tSC)

		Set tDocPos=pIOStream.Name_$C(13,10)_", @Line "_..%LineCount
		Set tSC1=..%ServiceInterface.OnDocumentEnd(tDoc,tDocPos,tSC1)  Quit:$$$ISERR(tSC1) // Fatal Error
		
		#; Process any trailing stuff in the stream
		Set tSC1=..%ServiceInterface.OnPostDocument(pIOStream,"")
	} While 0
	Set:$$$ISERR(tSC1)&&(tSC'=tSC1) tSC=$$$ADDSC(tSC,tSC1)
	If $IsObject(tDoc) {
		Set ..%CurrentDocument=$$$NULLOREF
		Set pDocument=tDoc
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="applyFraming">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFraming:%String,pFlexDefault:%String="xxf"</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tFramLC=$ZCVT(pFraming,"L")
	Quit $Case($E(tFramLC,1,5),
		"none":"x",
		"flexi":pFlexDefault,
		"mllp":$C($$$E1238DefStartBlockAscii)_"x"_$C($$$E1238DefEndBlockAscii,$$$E1238DefEndDataCRAscii),
		"llp":$C($$$E1238DefStartBlockAscii)_"D21"_$C($$$E1238DefEndDataCRAscii)_"x"_$C($$$E1238DefEndBlockAscii,$$$E1238DefEndDataCRAscii)_"LxxLLP",
		"msgen":"xx<->", "mllpm":$C($$$E1238DefStartBlockAscii)_"x"_$C($$$E1238DefEndBlockAscii,$$$E1238DefEndDataCRAscii)_"xx<->",
		"ascii":$Case(tFramLC,"asciicr":"x"_$C(13),"asciilf":"x"_$C(10),"asciicrlf":"x"_$C(10),:$$framchars($E(tFramLC,6,*))),
		:$S("mllp"=$E(tFramLC,1,4):$$framchars($E(tFramLC,5,*))_$C($$$E1238DefEndDataCRAscii),
			1:$$framchars(tFramLC)))
framchars(str)
	#; Transform a string of the form nn/mm into $C(nn)_"x"_$C(mm) as before- and after- framing chars
	#; If it is just nn, make it "x"_nn because a lone framing char comes after.
	Set tPiece=$P(str,"/")
	Set tStr="" For i=1:1:$L(tPiece,",") { Set tItem=$P(tPiece,",",i)  Continue:""=tItem
		Set tStr=tStr_$C(+tItem)
	}
	Set tPiece=$P(str,"/",2)
	If ""=tPiece&&("/"'=$E(str,*)) {
		If (tStr=$C(0)) && (0'=$E(str)) { Set tStr=pFlexDefault }
		Else { Set tStr="x"_tStr }
	}
	Else {
		Set tStr=tStr_"x"
		For i=1:1:$L(tPiece,",") { Set tItem=$P(tPiece,",",i)  Continue:""=tItem
			Set tStr=tStr_$C(+tItem)
		}
		Set:"x"=$E(tStr,*) $E(tStr,$L(tStr))=""
	}
	Quit tStr
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec>initvalue:%CacheString</FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..%ServiceInterface=initvalue
	Do ..Reset()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="stripWhitespace">
<Description>
Strip off leading whitespace from the line</Description>
<FormalSpec>pLine:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	For i=1:1 { Quit:i>$L(pLine)||($C(13,10,9,32)'[$E(pLine,i)) }
	Quit $E(pLine,i,*)
]]></Implementation>
</Method>

<Method name="mapCtlChars">
<ClassMethod>1</ClassMethod>
<FormalSpec>s:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set so=""
	For i=1:1 { Set c=$E(s,i)  Quit:""=c  Set so=so_$Case(c,$C(2):"<STX>",$C(3):"<ETX>",$C(4):"<EOT>",$C(5):"<ENQ>",$C(6):"<ACK>",$C(23):"<ETB>",$C(13):"<CR>",$C(10):"<LF>",:c) }
	Quit so
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*Method Reset()
{
	Do ..ResetPosition()
	Set ..%Stream =$$$NULLOREF
}*/
]]></Content>
</UDLText>

<Method name="Reset">
<Implementation><![CDATA[
	Set (..%LookaheadLine,..%LookaheadLineTerminator,..%LookaheadLineIsNew)=""
	Do ..ResetPosition()
	Set ..%Stream =$$$NULLOREF
	Set (..%inFraming,..%outFraming) = "uninitialized"
	Set ..%EndBlock=""
]]></Implementation>
</Method>

<Method name="ResetPosition">
<Implementation><![CDATA[
	Set (..%SegmentCount,..%LineCount,..%CharCount)=0
	Set ..%CurrentDocument=$$$NULLOREF
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Schema">
<Description>
VDoc Schema classmethods and queries</Description>
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>HPRIME1238</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<System>4</System>
<TimeChanged>64175,60539</TimeChanged>
<TimeCreated>59269,41535.544</TimeCreated>

<Query name="DocStructures">
<Description><![CDATA[
Returns a list of available DocTypes for the corresponding document class. <br/>
The DocType is returned as the first column in the result set. <br/>
The <var>Category</var> parameter can be used to restrict the list. <br/>
If <var>Category</var> is: <br/>
 0 - return only DocTypes in standard categories <br/>
 + - return only DocTypes in user-defined categories <br/>
 empty - return DocTypes from all categories <br/>
 a category name - return only DocTypes in the named category <br/>
 a partial name suffixed with '%' - return only DocTypes in categories matching the partial category name <br/>
 other - return nothing <br/>
If <var>IncludeBase</var> is: <br/>
 0 - return only DocTypes defined in the current schema category itself <br/>
 1 - return all DocTypes in the current schema category's base category in addition to those defined in the current category itself <br/>]]></Description>
<Type>%Query</Type>
<FormalSpec>Category:%String="",IncludeBase:%Boolean=0</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="DocStructure:%String,Description:%String,IsStandard:%Boolean"/>
</Query>

<Method name="DocStructuresExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Category:%String="",IncludeBase:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set k="" For { Set k=$O($$$vaSchemaGbl(k)) Quit:""=k
		Set Std=+$G($$$vaSchemaDescGbl(k,"std"))
		If $Case(Category,"0":Std,"+":'Std,"":1,:$S("%"=$E(Category,$L(Category)):$ZCVT($E(Category,1,$L(Category)-1),"L")=$E($ZCVT(k,"L"),1,$L(Category)-1), 1:$ZCVT(Category,"L")=$ZCVT(k,"L"))) {
			Set iVer=$I(qHandle("ver")), qHandle("ver",$S(Std:iVer,1:"u"_iVer))=k ; sort standard ones first
		}
	}
	Set qHandle="", qHandle("ver")=$O(qHandle("ver","")), qHandle("IncludeBase")=IncludeBase  Set:""'=qHandle("ver") qHandle("base")=qHandle("ver",qHandle("ver"))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="DocStructuresFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>DocStructuresExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill Row Set Row=""
	While ""'=$G(qHandle("ver")) {
		While ""'=$G(qHandle("base")) {
			While 1 {
				Set qHandle=$O($$$vaSchemaGbl(qHandle("base"),"DS",qHandle))
				Quit:""=qHandle||'$D(qHandle("seen",qHandle))
			}
			Quit:""'=qHandle
			Quit:'qHandle("IncludeBase")
			Set qHandle("base")=$G($$$vaSchemaGbl(qHandle("base"),"base"))
			Quit:""=qHandle("base")
		}
		Quit:""'=qHandle
		Set qHandle("ver")=$O(qHandle("ver",qHandle("ver")))  Set:""'=qHandle("ver") qHandle("base")=qHandle("ver",qHandle("ver"))  Kill qHandle("seen")
	}
	If ""=$G(qHandle("ver")) Set AtEnd=1  Quit $$$OK
	Set:qHandle("IncludeBase") qHandle("seen",qHandle)=""
	Set tCategory=qHandle("ver",qHandle("ver"))
	Set tDesc=..GetDescription("DS:"_tCategory_":"_qHandle)
	Set tStd=+$G($$$vaSchemaDescGbl(tCategory,"std"))
	Set Row=$LB(tCategory_":"_qHandle,tDesc,tStd)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="DocStructuresClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>DocStructuresFetch</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill qHandle
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="TypeCategories">
<Type>%Query</Type>
<FormalSpec>Standard:%String=""</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Category:%String,Description:%String,IsStandard:%Boolean,Base:%String"/>
</Query>

<Method name="TypeCategoriesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Standard:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set k="" For { Set k=$O($$$vaSchemaGbl(k)) Quit:""=k
		Set Std=+$G($$$vaSchemaDescGbl(k,"std"))
		If $Case(Standard,"0":Std,"+":'Std,"":1,:$ZCVT(Standard,"L")=$E($ZCVT(k,"L"),1,$L(Standard))) {
			Set iVer=$I(qHandle("ver")), qHandle("ver",$S(Std:iVer,1:"u"_iVer))=k ; sort standard ones first
		}
	}
	Set qHandle="", qHandle("ver")=$O(qHandle("ver",""))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="TypeCategoriesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>TypeCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill Row Set Row=""
	If ""=$G(qHandle("ver")) Set AtEnd=1  Quit $$$OK
	Set tCategory=qHandle("ver",qHandle("ver"))
	Set qHandle("ver")=$O(qHandle("ver",qHandle("ver")))
	Set tDesc=$G($$$vaSchemaDescGbl(tCategory))
	Set tStd=+$G($$$vaSchemaDescGbl(tCategory,"std"))
	Set tBase=$G($$$vaSchemaGbl(tCategory,"base"))
	Set Row=$LB(tCategory,tDesc,tStd,tBase)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="TypeCategoriesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>TypeCategoriesFetch</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill qHandle
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="SegTypes">
<Description><![CDATA[
Returns a list of schema categories and segment types and segment fields for the corresponding document class. <br/>
The <var>Category</var> and <var>Level</var> parameters can be used to restrict the list. <br/>
If <var>Category</var> is: <br/>
 0 - return only standard categories <br/>
 + - return only user-defined categories <br/>
 empty - return all categories <br/>
 a category name - return only SegTypes in the named category <br/>
 a category name:segment type name - return only information about the named SegType <br/>
 a partial name suffixed with '%' - return only SegTypes in categories matching the partial category name <br/>
 other - return nothing <br/>
If <var>Level</var> is: <br/>
 0 - return all segment names <br/>
 n - return the given number of levels of nested field names within each segment <br/>
 empty - return all levels of nested field names within each segment <br/>
If <var>IncludeBase</var> is: <br/>
 0 - return only segment names defined in the current schema category itself <br/>
 1 - return all segment names in the current schema category's base category in addition to those defined in the current category itself <br/>]]></Description>
<Type>%Query</Type>
<FormalSpec>Category:%String="",Level:%String="",IncludeBase:%Boolean=0</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="SegType:%String,Field:%String,Description:%String,IsStandard:%Boolean"/>
</Query>

<Method name="SegTypesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Category:%String="",Level:%String="",IncludeBase:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set CatSeg=$P(Category,":",2,$L(Category,":")), Category=$P(Category,":",1)
	Set k="" For { Set k=$O($$$vaSchemaGbl(k)) Quit:""=k
		Set Std=+$G($$$vaSchemaDescGbl(k,"std"))
		If $Case(Category,"0":Std,"+":'Std,"":1,:$S("%"=$E(Category,$L(Category)):$ZCVT($E(Category,1,$L(Category)-1),"L")=$E($ZCVT(k,"L"),1,$L(Category)-1), 1:$ZCVT(Category,"L")=$ZCVT(k,"L"))) {
			Set iVer=$I(qHandle("ver")), qHandle("ver",$S(Std:iVer,1:"u"_iVer))=k ; sort standard ones first
		}
	}
	Set qHandle("ver")=0, qHandle("seg")="", qHandle("fldkey")="", qHandle("Level")=Level, qHandle("CatSeg")=CatSeg
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SegTypesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>SegTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill Row Set Row=""
	If ""=$G(qHandle("ver")) Set AtEnd=1  Quit $$$OK
	
	For {
		If ""=qHandle("seg") {
			Set qHandle("ver")=$O(qHandle("ver",qHandle("ver")))  Quit:""=qHandle("ver")
		}
		If $Case(qHandle("Level"), 0:1, :""=qHandle("fldkey")) {
			If ""'=qHandle("CatSeg") {
				Set qHandle("seg")=$S(qHandle("seg")="":qHandle("CatSeg"), 1:"")
			} Else {
				Set qHandle("seg")=$O($$$vaSchemaGbl(qHandle("ver",qHandle("ver")),"SS",qHandle("seg")))
			}
			Continue:""=qHandle("seg")
			Quit:""'=qHandle("seg")&&(0=qHandle("Level"))
			Set tSC=..getFieldsContentArray(.tSegFields,"source",qHandle("ver",qHandle("ver")),qHandle("seg"),qHandle("Level"))
			#; ignore tSC error - make do with what we got
			Merge qHandle("flds")=tSegFields
			Set qHandle("fldkey")="qHandle(""flds""", qHandle("fld")=""
		}
		Set tFld="" For {
			Set tCnt=$G(@(qHandle("fldkey")_")"),0)
			Set qHandle("fld")=qHandle("fld")+1
			If qHandle("fld") > tCnt { ; pop up a level
				If qHandle("fldkey")="qHandle(""flds""" Set qHandle("fldkey")=""  Quit
				Set tLen=$L(qHandle("fldkey"),",")
				Set qHandle("fld")=$P(qHandle("fldkey"),",",tLen)
				Set qHandle("fldkey")=$P(qHandle("fldkey"),",",1,tLen-1)
			} Else {
				Set qFldDown=qHandle("fldkey")_","_qHandle("fld")
				If $G(@(qFldDown_")"),0) { ; has subfields; push down a level
					Set qHandle("fldkey")=qFldDown, qHandle("fld")=""
				}
				Set tFld=$$fldName(qFldDown) Quit
			}
		}
		Quit:""'=tFld
		Kill qHandle("flds")
	}
	If ""=$G(qHandle("ver")) Set AtEnd=1  Quit $$$OK
	Set tCategory=qHandle("ver",qHandle("ver"))
	If qHandle("Level")=0 {
		Set tFld="", tDesc=..GetDescription("SS:"_tCategory_":"_qHandle("seg"))
	}
	Set tStd=+$G($$$vaSchemaDescGbl(tCategory,"std"))
	Set Row=$LB(tCategory_":"_qHandle("seg"),tFld,tDesc,tStd)
	Quit $$$OK
fldName(qFld)
	Set tName="", tLen=$L(qFld,",")
	For i=2:1:tLen {
		Set tName=tName_"."_@($P(qFld,",",1,i)_",""name"")")
	}
	Set tDesc=$S(tLen=2:..GetDescription("SS:"_qHandle("ver",qHandle("ver"))_":"_qHandle("seg"),$P(qFld,",",tLen))
			, 1:..GetDescription(@($P(qFld,",",1,tLen-1)_",""type"")"),$P(qFld,",",tLen)))
	Quit $E(tName,2,*)
]]></Implementation>
</Method>

<Method name="SegTypesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>SegTypesFetch</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill qHandle
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetContentArray">
<Description>
Get all properties for a given document structure</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pContents,pMode:%String,pType:%String="",pLevel:%Integer,pIncludeBase:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:$G(pLevel)'=1||($G(pMode)'="source") ..buildContentArray(.pContents,.pMode,pType,.pLevel)
	Set tStructCategory=$P(pType,":"), tStructName=$P(pType,":",2)
	If (tStructCategory="")||(tStructName="") Quit $$$ERROR($$$EnsErrGeneral,"Document Structure '"_pType_"' must have form 'category:name'.")
	Set tBaseCat=tStructCategory, tSC=$$$OK
	For {
		If ""=$G($$$vaSchemaGbl(tBaseCat,"DS",tStructName)) Set tSC=$$$ERROR($$$EnsErrGeneral,"Document Structure '"_pType_"' not defined.")  Quit
		If '$D($$$vaSchemaGbl(tBaseCat,"DS",tStructName,"array")) Set tSC=$$$ERROR($$$EnsErrGeneral,"No content array is built for Document Structure '"_pType_"'.")  Quit
		Quit:$$$ISOK(tSC)||'pIncludeBase
		Set tBaseCat=$G($$$vaSchemaGbl(tBaseCat,"base"))
		Quit:""=tBaseCat
		Set tSC=$$$OK ; go around and try again on base schema
	} Quit:$$$ISERR(tSC) tSC
	Set tRef=$G(pContents)
	If $Case($E($G(pContents)),"%":1,"^":1,:0) { Kill @pContents  Merge @pContents=$$$vaSchemaGbl(tBaseCat,"DS",tStructName,"array") }
	Else { Kill pContents  Merge pContents=$$$vaSchemaGbl(tBaseCat,"DS",tStructName,"array") }
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="buildContentArray">
<Description>
Get all properties for a given document structure</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pContents,pMode:%String="source",pType:%String,pLevel:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStructCategory=$P(pType,":"), tStructName=$P(pType,":",2)
	If (tStructCategory="")||(tStructName="") Quit $$$ERROR($$$EnsErrGeneral,"Document Structure '"_pType_"' must have form 'category:name'.")
	Set tSchema=$G($$$vaSchemaGbl(tStructCategory,"DS",tStructName))
	Quit:""=tSchema $$$ERROR($$$EnsErrGeneral,"Document Structure '"_pType_"' not defined.")
	Set tSC=$$$OK
	Do ..getSegsContentArray(.pContents,$ZCVT(pMode,"L"),tStructCategory,tSchema,"",pLevel,.tSC)
	Quit tSC
]]></Implementation>
</Method>

<Method name="getSegsContentArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pContents,pMode:%String,pCategory:%String,pSchema:%String,pPrevSeg:%String,pLevel:%Integer,*pSC:%Status=$$$OK</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tRef=$G(pContents)
	If ("%"=$E(tRef)||("^"=$E(tRef))) { Kill @tRef }
	Else {
		Kill pContents  Set tRef="%local"  New %local
	}
	#; Walk through the segment structure of the document
	Set iProp=0
	For iSeg=1:1:$L(pSchema,"~") { Set tSeg=$P(pSchema,"~",iSeg)  Continue:""=tSeg
		If ""'=$ZStrip(tSeg,"*P") { Set tSegCategory=$P(tSeg,":"), tSeg=$P(tSeg,":",2) } Else { Set tSegCategory="" }
		Set tCat=$Case(tSeg,"[":1,"{":1,"<":3,"]":-1,"}":-1,"|":-3,">":-3,:0)
		If 0=tCat {
			Set tName=tSeg, tSegNames(tName)=$G(tSegNames(tName))+1 ; count duplicate seg names at this level
			Set:+$G(tSegNames(tName))>1 tName=tName_"i"_tSegNames(tName) ; append i<n> if needed
			Set iProp=iProp+1
			If pLevel>1||'pLevel {
				Set tSC1=..getFieldsContentArray(.tFldContents,pMode,tSegCategory,tSeg,pLevel)  Set:pSC'=tSC1 pSC=$$$ADDSC(pSC,tSC1)
				Merge @tRef@(iProp)=tFldContents  Kill tFldContents
			}
			Set @tRef@(iProp,"name")=tName
			Set @tRef@(iProp,"type")="SS:"_tSegCategory_":"_tSeg
		} Else { ; 0'=tCat
			// Tweak stuff for artificial Choice List schema #<~||~||~>>
			If ("#"=pPrevSeg) {
				If -3=tCat {
					Set tCat=$Case(tSeg,">":-2,"|":+3,:tCat)
				}
			} Else {
				If "<"=tSeg { Set tSeg="#", tCat=2, iSeg=iSeg-1 } ; Artificially descend an extra level "#" before "<"
				ElseIf -3=tCat {
					Set iSeg=iSeg-$Case(tSeg,">":1,"|":1,:0) ; Ascend from bottom level, double up each "|" or ">" - to extra-exit, or to enter a new branch
				}
			}
			If tCat>0 {
				Set iSeg=iSeg+..getSegsContentArray(.tGrpContents,pMode,pCategory,$P(pSchema,"~",iSeg+1,$L(pSchema,"~")),tSeg,pLevel,.pSC)
				If tGrpContents {
					Set tName=tGrpContents(1,"name")
					Set tType=tGrpContents(1,"type")
					Set iProp=iProp+1
					If tGrpContents=1 {
						Merge @tRef@(iProp)=tGrpContents(1)
					} Else { ; > 1
						Merge @tRef@(iProp)=tGrpContents
						Set tExt=$S("("=tSeg:"union",1:"grp")
						Set tName=$P(tName,"(")_tExt
						Set tType=$P(tType,"(")_tExt
					}
				}
				Kill tGrpContents
				Set tOptArr=(")"=$E(tName,*))  Set:tOptArr tName=$P(tName,"(",1,$L(tName,"(")-1) ; unwind returned optional array
				Set tSegNames(tName)=$G(tSegNames(tName))+1 ; count duplicate seg names at this level
				Set:+$G(tSegNames(tName))>1 tName=tName_"i"_tSegNames(tName) ; append i<n> if needed
				Set:"{"=tSeg||tOptArr tName=tName_"()"
				Set:"{"=tSeg tType=tType_"()"
				Set @tRef@(iProp,"name")=tName
				Set @tRef@(iProp,"type")=tType
				Set:"["=tSeg @tRef@(iProp,"opt")=1
			} Else { ; tCat < 0
				Quit
			}
		}
	}
	Set @tRef=iProp
	Merge:tRef="%local" pContents=%local
	Quit iSeg
]]></Implementation>
</Method>

<Method name="getFieldsContentArray">
<Description>
Given a segment type, extract the content array for the fields (items)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pContents,pMode:%String,pCategory:%String,pSeg:%String,pLevel:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pContents  Set tSC=$$$OK
	Set tSegType=$P(pSeg,"i")
	If $D($$$vaSchemaGbl(pCategory,"SS",tSegType))#2=0 {
		If "DocsRef"=$E(tSegType,$L(tSegType)-$L("DocsRef")+1,$L(tSegType)) Set pContents=0  Quit $$$OK
		Quit $$$ERROR($$$EnsErrGeneral,"Unknown segment type '"_pCategory_":"_tSegType_"'")
	}
	Set tSchema=$$$vaSchemaGbl(pCategory,"SS",tSegType)

	For iFld=1:1:$LL(tSchema) { Set tFld=$LG(tSchema,iFld)  Continue:""=tFld
		Set tType=$LI(tFld,1)
		Set tTypeCategory=$P(tType,":"), tType=$P(tType,":",2)
		Set tRep=$Case($LI(tFld,2),"+":1,"*":1,"&":1,:0)
		Set tRepCount=$LI(tFld,3)
		Set tRepCount=$S('tRep:"", 1:"("_tRepCount_")")
		Set tName="" For  Set tName=$O($$$vaSchemaGbl(pCategory,"SS",tSegType,"names",tName))  Quit:""=tName||(iFld=$$$vaSchemaGbl(pCategory,"SS",tSegType,"names",tName))
		Set pContents(iFld,"name")=":"_tName_$S('tRep:"", 1:"()")
		If ""=tType {
			Set:""'=tRepCount pContents(iFld,"type")=tRepCount
		} Else {
			Set pContents(iFld,"type")="CS:"_tTypeCategory_":"_tType_tRepCount
			If pLevel>=2||'pLevel {
				Set tSC1=..getComponentsContentArray(.tFldContents, pMode, tTypeCategory, tType, pLevel)  Set:tSC'=tSC1 tSC=$$$ADDSC(tSC,tSC1)
				Merge pContents(iFld)=tFldContents  Kill tFldContents
			}
		}
	}
	Set pContents=iFld
	Quit tSC
]]></Implementation>
</Method>

<Method name="getComponentsContentArray">
<Description>
Get the components of a ComponentStructure / Type</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pContents,pMode:%String,pCategory:%String,pComponentStructType:%String,pLevel:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pContents  Set tSC=$$$OK
	Set tSchema=$S(""=pCategory:"",1:$G($$$vaSchemaGbl(pCategory,"CS",pComponentStructType)))
	Quit:""=tSchema $$$ERROR($$$EnsErrGeneral,"Unknown component structure type '"_pCategory_":"_pComponentStructType)

	For iComp=1:1:$LL(tSchema) { Continue:'$LD(tSchema,iComp)  Set tType=$LI(tSchema,iComp)
		Set tTypeCategory=$P(tType,":"), tType=$P(tType,":",2)
		Set tName="" For  Set tName=$O($$$vaSchemaGbl(pCategory,"CS",pComponentStructType,"names",tName))  Quit:""=tName||(iComp=$$$vaSchemaGbl(pCategory,"CS",pComponentStructType,"names",tName))
		Set pContents(iComp,"name")=tName
		If ""'=tType {
			Set pContents(iComp,"type")="CS:"_tTypeCategory_":"_tType
			If pLevel>=3||'pLevel {
				Set tSC1=..getComponentsContentArray(.tCompContents, pMode, tTypeCategory, tType)  Set:tSC'=tSC1 tSC=$$$ADDSC(tSC,tSC1)
				Merge pContents(iComp)=tCompContents   Kill tCompContents
			}
		}
	}
	Set pContents=iComp
	Quit tSC
]]></Implementation>
</Method>

<Method name="ElementExists">
<ClassMethod>1</ClassMethod>
<FormalSpec>pElementSpec:%String=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tClass=$ZCVT($P(pElementSpec,":",1),"U"), tCat=$P(pElementSpec,":",2), tElem=$P(pElementSpec,":",3)
	Quit:((""=tClass)||(""=tCat)||(""=tElem)) 0
	Quit ($D($$$vaSchemaGbl(tCat,tClass,tElem))#2'=0)
]]></Implementation>
</Method>

<Method name="GetDescription">
<Description>
Get the description of an item or an indexed piece of an item</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pElementSpec:%String,pItem:%Integer=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tClass=$ZCVT($P(pElementSpec,":",1),"U")
	Set tCategory=$P(pElementSpec,":",2)  Set:""=tCategory tCategory="E1394"
	Set tElem=$P(pElementSpec,":",3)
	Quit:(""=tClass)||(""=tElem) "" ; Must specify ""Class:Category:Element""
	Set tDesc=$S(""=pItem:$G($$$vaSchemaDescGbl(tCategory,tClass,tElem)), 1:$G($$$vaSchemaDescGbl(tCategory,tClass,tElem,pItem)))
	If ""=tDesc {
		Set tBaseCat=$G($$$vaSchemaGbl(tCategory,"base"))
		Set pItem(tCategory)=""
		Set:""'=tBaseCat&&'$D(pItem(tBaseCat)) tDesc=..GetDescription(tClass_":"_tBaseCat_":"_$P(pElementSpec,":",3,$L(pElementSpec,":")),.pItem)
	}
	Quit tDesc
]]></Implementation>
</Method>

<Method name="GetAlias">
<Description>
This method computes the Alias string for a property name, given the property's node in the Content Array.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pContentArrayName:%String,pArrayPos:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSeg=1,tAlias=""  For i=1:1:$L(pArrayPos,",") {
		Set tPiece=@(pContentArrayName_"("_$P(pArrayPos,",",1,i)_",""name"")")
		If tSeg && ($G(@(pContentArrayName_"("_$P(pArrayPos,",",1,i)_",""type"")"))["SS:") {
			Set tAlias=tAlias_"."_tPiece
		} else {
			Set tAlias=tAlias_$S(tSeg:":",1:".")_$P(pArrayPos,",",i)_$S(")"=$E(tPiece,$L(tPiece)):"("_$P(tPiece,"(",2),1:"")
			Set:tSeg tSeg=0
		}
	}
	Quit $E(tAlias,2,$L(tAlias))
]]></Implementation>
</Method>

<Method name="ResolveSchemaTypeToDocType">
<Description>
Given a Schema category and a Document TypeName string, return the corresponding DocType (document structure)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSchemaCategory:%String,pTypeName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK
	If ((pSchemaCategory="")||(pTypeName="")) Set pStatus=$$$ERROR($$$EnsErrGeneral,"Empty category '"_pSchemaCategory_"' or type name '"_pTypeName_"'")  Quit ""
	Quit pSchemaCategory_":"_pTypeName
]]></Implementation>
</Method>

<Method name="BuildCategoryMaps">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCategory:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK, tDocStructName="" For { Set tDocStructName=$O($$$vaSchemaGbl(pCategory,"DS",tDocStructName))  Quit:""=tDocStructName
		Set tSC=..buildDocStructureMap(pCategory,tDocStructName)  Quit:$$$ISERR(tSC)
	}
	Set tSegment="" For { Set tSegment=$O($$$vaSchemaGbl(pCategory,"SS",tSegment))  Quit:tSegment=""
		Set tSC=..buildSegmentStructureMap(pCategory,tSegment)  Quit:$$$ISERR(tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="buildDocStructureMap">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCategory:%String,pDocStructName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tContentArrayName=$Name($$$vaSchemaGbl(pCategory,"DS",pDocStructName,"array"))
	Set tSC=..buildContentArray(tContentArrayName,,pCategory_":"_pDocStructName,1)
	Do ..buildDocStructureMapLoop(tContentArrayName,.tSchemaPathMap,"","=")
	Set index=$O(@tContentArrayName@(""),-1)
	Set tSchemaPathMap("leftoversegs()")="="_(+index+1)_",*|:Any"
	Kill $$$vaSchemaGbl(pCategory,"DS",pDocStructName,"map")
	Merge $$$vaSchemaGbl(pCategory,"DS",pDocStructName,"map")=tSchemaPathMap
	Quit tSC
]]></Implementation>
</Method>

<Method name="buildDocStructureMapLoop">
<ClassMethod>1</ClassMethod>
<FormalSpec>pContentArrayName:%String,pSchemaPathMap:%String,pNamePrefix:%String,pValuePrefix:%String</FormalSpec>
<Implementation><![CDATA[
	Set padding=$L($O(@pContentArrayName@("name"),-1))
	Set index="" For { Set index=$O(@pContentArrayName@(index))  Quit:""=index  Continue:index'=+index
		Set value=$TR($J(index,padding)," ","0")
		If @pContentArrayName@(index,"name")["()" set value=value_",*"
		If '$G(@pContentArrayName@(index)) {
			Set segtype=$TR($P(@pContentArrayName@(index,"type"),":",2,99),"()")
			Set pSchemaPathMap(pNamePrefix_@pContentArrayName@(index,"name"))=pValuePrefix_value_"|"_segtype
		} Else {
			Set nestedref=$S(pContentArrayName[")":$E(pContentArrayName,1,$L(pContentArrayName)-1)_","_index_")",1:pContentArrayName_"("_index_")")
			Set nameprefix=pNamePrefix_@pContentArrayName@(index,"name")
			Do ..buildDocStructureMapLoop(nestedref,.pSchemaPathMap,nameprefix_".",pValuePrefix_value_",")
		}
	}
]]></Implementation>
</Method>

<Method name="buildSegmentStructureMap">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCategory:%String,pSegmentType:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill $$$vaSchemaGbl(pCategory,"SS",pSegmentType,"map")
	Set struct=$G($$$vaSchemaGbl(pCategory,"SS",pSegmentType))
	Quit:""=struct $$$OK
	Kill names Set name="" For { Set name=$O($$$vaSchemaGbl(pCategory,"SS",pSegmentType,"names",name))  quit:name=""
		Set names($$$vaSchemaGbl(pCategory,"SS",pSegmentType,"names",name))=name
	}
	Set tSC=$$$OK
	For i=1:1:$LL(struct) {
		Continue:'$D(names(i))
		Set ifrepeating=$LI($LI(struct,i),6)
		Set tSSMap($ZCVT(names(i),"L"))=i_$s(ifrepeating:"()",1:"")
		Set cs=$LG($LI(struct,i),1)
		If cs'="" {
			Kill subarray
			Set tSC=..buildComponentStructMap($p(cs,":",1),$p(cs,":",2),.subarray) Quit:$$$ISERR(tSC)
			Set name="" For { Set name=$O(subarray(name))  Quit:name=""
				Set tSSMap($ZCVT(names(i)_"."_name,"L"))=tSSMap($ZCVT(names(i),"L"))_"."_subarray(name)
			}
		}
	}
	Merge:$$$ISOK(tSC) $$$vaSchemaGbl(pCategory,"SS",pSegmentType,"map")=tSSMap
	Quit tSC
]]></Implementation>
</Method>

<Method name="buildComponentStructMap">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocTypeCategory,pTypeName,pCSMap</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set struct=$G($$$vaSchemaGbl(pDocTypeCategory,"CS",pTypeName))
	Quit:""=struct $$$OK
	Kill names Set name="" For { Set name=$O($$$vaSchemaGbl(pDocTypeCategory,"CS",pTypeName,"names",name))  Quit:""=name
		Set names($$$vaSchemaGbl(pDocTypeCategory,"CS",pTypeName,"names",name))=name
	}
	Set tSC=$$$OK
	For i=1:1:$LL(struct) {
		Continue:'$D(names(i))
		Set pCSMap(names(i))=i
		Set cs=$LI(struct,i)
		If cs'="" {
			Kill subarray
			Set tSC=..buildComponentStructMap($P(cs,":",1),$p(cs,":",2),.subarray)  Quit:$$$ISERR(tSC)
			Set name="" For { Set name=$O(subarray(name))  Quit:name=""
				Set pCSMap(names(i)_"."_name)=pCSMap(names(i))_"."_subarray(name)
			}
		}
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.SchemaDocument">
<Description>
Abstract Document used to load ASTM schema definition into Studio.</Description>
<ClassType/>
<IncludeCode>HPRIME1238</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Studio.AbstractDocument</Super>
<System>4</System>
<TimeChanged>64175,60539</TimeChanged>
<TimeCreated>59324,43163.752025</TimeCreated>

<Projection name="RegisterExtension">
<Type>%Projection.StudioDocument</Type>
<Parameter name="DocumentExtension" value="E1238"/>
<Parameter name="DocumentNew" value="0"/>
<Parameter name="DocumentType" value="xml"/>
</Projection>

<Parameter name="EXTENSION">
<Default>.E1238</Default>
</Parameter>

<Method name="Load">
<Description><![CDATA[
Load the E1238 schema definition Name into the stream Code<br>]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	Do {
		If ".E1238"'=$ZCVT($E(..Name,*-3,*),"U") Set tSC=$$$ERROR($$$GeneralError,"Invalid E1238 schema filename '"_..Name_"'")  Quit
		Set tSC=##class(HPRIM.EDI.E1238.SchemaXML).Export($E(..Name,1,*-4),..Code)
	} While(0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$SystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="Save">
<Description>
Save the E1238 schema definition document.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	Do {
		#; Find old Category name in ..Code
		Do ..Code.Rewind()
		Set (tLine,tOldCat)="" While tLine'["<Category " { Set tLine=..Code.ReadLine(,.tSC) Quit:..Code.AtEnd }
		Set f=$F(tLine,"name=") Set:f tOldCat=$P($E(tLine,f+1,*),$E(tLine,f))
		Do ..Code.Rewind()
		Set tStream=##class(Ens.Util.XML.Reader).ChangeXMLStreamEncoding(..Code,"") Do tStream.Rewind()
		Set tCatName=$E(..Name,1,*-4)  If ".E1238"'=$ZCVT($E(..Name,*-3,*),"U") Set tSC=$$$ERROR($$$EnsErrGeneral,"Schema "_..Name_" is not an ASTM schema")  Quit
		tstart
		Set tSC = ##class(HPRIM.EDI.E1238.SchemaXML).Import(tStream,,tCatName)
		If $$$ISOK(tSC) {
			#; Schema loaded ok, let's commit it - but first fix name if needed
			Do:tOldCat'=tCatName ..Code.Clear(), ##class(HPRIM.EDI.E1238.SchemaXML).Export(tCatName,..Code)
			tcommit
		} Else {
			#; Rollback the schema update			
			trollback
		}
	} While(0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$SystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="Delete">
<Description><![CDATA[
Delete the E1238 schema definition <var>name</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:$ZCVT($E(name,*-3,*),"U")'=".E1238" $$$ERROR($$$GeneralError,"Invalid E1238 filename")
	set category=$e(name,1,*-4)
	kill $$$vaSchemaGbl(category)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="TimeStamp">
<Description>
Return the timestamp of schema category 'name' in %TimeStamp format, i.e. $zdatetime($horolog,3).
This is used to determine if the category has been updated on the server and so needs reloading into Studio.
So the format should be $zdatetime($horolog,3), or "" if the category does not exist.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[
	if $ZCVT($E(name,*-3,*),"U")'=".E1238" set tSC=$$$ERROR($$$GeneralError,"Invalid E1238 filename") quit ""
	set ts=$G($$$vaSchemaGbl($E(name,1,*-4),"time"))
	quit ##class(Ens.DataType.UTC).LogicalToOdbc($S(""=ts:ts,1:$ZDT(ts,3,,3)))
]]></Implementation>
</Method>

<Method name="CompileTime">
<Description>
Return the compile time of routine 'name' in %TimeStamp format. The format should be $zdatetime($horolog,3),
or "" if the routine does not exist.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[..TimeStamp(.name)
]]></Implementation>
</Method>

<Method name="Exists">
<Description>
Return 1 if the given schema definition document exists and 0 if it does not.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	if $ZCVT($E(name,*-3,*),"U")'=".E1238" quit 0
	set category=$E(name,1,*-4)
	quit ''$data($$$vaSchemaGbl(category))
]]></Implementation>
</Method>

<Query name="List">
<Type>%Query</Type>
<FormalSpec>Directory:%String,Flat:%Boolean,System:%Boolean</FormalSpec>
<Parameter name="ROWSPEC" value="name:%String,modified:%TimeStamp,size:%Integer,directory:%String"/>
</Query>

<Method name="ListExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Directory:%String,Flat:%Boolean,System:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if $g(Directory)'="" set qHandle="" quit $$$OK
	set index=$I(^CacheTemp)
	set cat="" for  set cat=$O($$$vaSchemaGbl(cat)) quit:cat=""  set ^CacheTemp(index,cat)=""
	set qHandle=$LB(index,"")
	quit $$$OK
]]></Implementation>
</Method>

<Method name="ListFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>ListExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set Row="",AtEnd=0
	set tempnode=$LG(qHandle,1),cat=$LG(qHandle,2)
	if (tempnode="") set Row="",AtEnd=1 quit $$$OK
	set cat=$O(^CacheTemp(tempnode,cat))
	set $LI(qHandle,2)=cat
	If cat="" Set AtEnd=1 Quit $$$OK
	set Row=$LB(cat_".AST",$G(^CacheTemp(tempnode,cat,"time")),0,"")
	if $O(^CacheTemp(tempnode,cat))="" set AtEnd=1
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ListClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>ListExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tempnode=$LG(qHandle,1)
	if tempnode'="" kill ^CacheTemp(tempnode)
	set qHandle=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ExportToXML">
<Description>
Export this document to the current device in XML format</Description>
<FormalSpec>flags:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..Code.LineTerminator=$c(10)
	Do ..Code.Rewind()
	Do ..Code.ReadLine()  // omit xml header
	While '(..Code.AtEnd) {
		Write ..Code.Read(16000)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ImportFromXML">
<Description>
Import from the stream in XML format</Description>
<FormalSpec>stream:%RegisteredObject,flags:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..Code.Clear()
	Do ..Code.CopyFrom(stream)
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.SchemaXML">
<ClassType/>
<IncludeCode>HPRIME1238</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%XML.SAX.ContentHandler</Super>
<System>4</System>
<TimeChanged>64175,60539</TimeChanged>
<TimeCreated>59799,47383.466421</TimeCreated>

<Property name="CatOnly">
<Description>
Flag to only check the category defined in the schema xml file</Description>
<Type>%Boolean</Type>
</Property>

<Property name="lastFileCategory">
<Description>
slot for remembering categories encountered in schema xml file</Description>
<Type>%String</Type>
</Property>

<Property name="forceCategory">
<Description>
slot for remembering forced category name</Description>
<Type>%String</Type>
</Property>

<Property name="Error">
<Description>
Error encountered inside xml import handler</Description>
<Type>%Status</Type>
<InitialExpression>$$$OK</InitialExpression>
</Property>

<Property name="Filename">
<Description>
Filename for use in constructing xml handler error messages</Description>
<Type>%String</Type>
</Property>

<Method name="Import">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFile:%String,*pCategoryImported:%String,pForceCategory:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set handler=..%New(), handler.forceCategory=$G(pForceCategory), pCategoryImported=""
	If '$IsObject(pFile) {
		Set handler.Filename=pFile
		Quit:'##class(%File).Exists(pFile) $$$ERROR($$$FileDoesNotExist,pFile)
		Set sc=##class(%XML.SAX.Parser).ParseFile(pFile,handler)  quit:$$$ISERR(sc) sc
	} Else {
		Set handler.Filename=$S(""'=pForceCategory:pForceCategory_".AST", ""'=$G(pCategoryImported):pCategoryImported_".AST", 1:pFile)
		Set sc=##class(%XML.SAX.Parser).ParseStream(pFile,handler)  quit:$$$ISERR(sc) sc
	}
	Set pCategoryImported=handler.lastFileCategory
	Quit handler.Error
]]></Implementation>
</Method>

<Method name="GetImportCategory">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFilename:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set handler=..%New()  Set handler.CatOnly=1
	set sc=##class(%XML.SAX.Parser).ParseFile(pFilename,handler)
	quit handler.lastFileCategory
]]></Implementation>
</Method>

<Method name="Export">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCategory:%String,pFile:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'$D($$$vaSchemaGbl(pCategory)) $$$ERROR($$$CacheError,"E1238 Schema Category <"_pCategory_"> does not exist in namespace "_$ZNSpace)
	If '$IsObject(pFile) {
		set tFilename=pFile
		set pFile=##class(%FileCharacterStream).%New()
		//set tSC=pFile.LinkToFile(tFilename)  Quit:$$$ISERR(tSC) tSC
		set pFile.Filename = tFilename
		set pFile.TranslateTable="UTF8"
		Set tEncoding="UTF-8"
	} Else {
		Set tEncoding=$S(pFile.%Extends("%IO.IParts.CharacterIO"):pFile.CharEncoding,
						pFile.%Extends("%FileCharacterStream"):$$MapExtCharset^%NLS(pFile.TranslateTable),
		 				1:"")
	}
#define escape(%text) $ZCVT(%text,"O","XML")

	Do pFile.WriteLine("<?xml version=""1.0"""_$S(""=tEncoding:"",1:" encoding="""_tEncoding_"""")_"?>")
	Do pFile.WriteLine("")
	Do pFile.Write("<Category name="""_pCategory_"""")
	set desc=$g($$$vaSchemaDescGbl(pCategory))
	if desc'="" Do pFile.Write(" description="""_desc_"""")
	set base=$g($$$vaSchemaGbl(pCategory,"base"))
	if base'="" Do pFile.Write(" base="""_base_"""")
	if +$g($$$vaSchemaDescGbl(pCategory,"std")) Do pFile.Write(" std=""1""")
	Do pFile.WriteLine(">")

	#; document structure
	if $d($$$vaSchemaGbl(pCategory,"DS")) Do pFile.WriteLine("")
	set ds="" for { set ds=$o($$$vaSchemaGbl(pCategory,"DS",ds)) quit:ds=""
		set definition=$g($$$vaSchemaGbl(pCategory,"DS",ds))
		set description=$g($$$vaSchemaDescGbl(pCategory,"DS",ds))
		Do pFile.Write("<DocumentStructure name='"_ds_"'")
		Do pFile.Write(" definition='"_$$$escape(..stripDefCategory(definition,pCategory,base))_"'")
		if description'="" Do pFile.Write(" description='"_$$$escape(description)_"'")
		Do pFile.WriteLine("/>")
	}
	#; segment structure
	if $d($$$vaSchemaGbl(pCategory,"SS")) Do pFile.WriteLine("")
	set ss="" for { set ss=$o($$$vaSchemaGbl(pCategory,"SS",ss)) quit:ss=""
		set definition=$g($$$vaSchemaGbl(pCategory,"SS",ss))
		set description=$g($$$vaSchemaDescGbl(pCategory,"SS",ss))
		Do pFile.Write("<SegmentStructure name='"_ss_"'")
		if description'="" Do pFile.Write(" description='"_$$$escape(description)_"'")
		Do pFile.WriteLine(">")
		for i=1:1:$LL(definition) { continue:'$LD(definition,i)
			Do pFile.Write("    <SegmentSubStructure piece='"_i_"'")
			Do pFile.Write(" description='"_$$$escape($g($$$vaSchemaDescGbl(pCategory,"SS",ss,i)))_"'")
			set altdesc=$g($$$vaSchemaDescGbl(pCategory,"SS",ss,i,"alt"))
			if altdesc'="" Do pFile.Write(" altdesc='"_$$$escape(altdesc)_"'")
			if $lg($li(definition,i),1)'="" Do pFile.Write(" componentstruct='"_..stripDefCategory($lg($li(definition,i),1),pCategory,base)_"'")
			if $lg($li(definition,i),2)'="" Do pFile.Write(" symbol='"_$$$escape($lg($li(definition,i),2))_"'")
			if $lg($li(definition,i),3)'="" Do pFile.Write(" repeatcount='"_$lg($li(definition,i),3)_"'")
			if +$lg($li(definition,i),4) Do pFile.Write(" length='"_$lg($li(definition,i),4)_"'")
			if $lg($li(definition,i),5)'="" Do pFile.Write(" required='"_$$$escape($lg($li(definition,i),5))_"'")
			if +$lg($li(definition,i),6) Do pFile.Write(" ifrepeating='"_$lg($li(definition,i),6)_"'")
			set codetable=$g($$$vaSchemaGbl(pCategory,"SS",ss,"tables",i))
			if codetable'="" Do pFile.Write(" codetable='"_..stripDefCategory(codetable,pCategory,base)_"'")
			Do pFile.WriteLine("/>")
		}
		Do pFile.WriteLine("</SegmentStructure>")
	}
	#; component structure
	if $d($$$vaSchemaGbl(pCategory,"CS")) Do pFile.WriteLine("")
	set cs="" for { set cs=$o($$$vaSchemaGbl(pCategory,"CS",cs)) quit:cs=""
		set definition=$g($$$vaSchemaGbl(pCategory,"CS",cs))
		set description=$g($$$vaSchemaDescGbl(pCategory,"CS",cs))
		Do pFile.Write("<ComponentStructure name='"_cs_"'")
		if description'="" Do pFile.Write(" description='"_$$$escape(description)_"'")
		Do pFile.WriteLine(">")
		for i=1:1:$LL(definition)  {
			Do pFile.Write("    <ComponentSubStructure piece='"_i_"'")
			Do pFile.Write(" description='"_$$$escape($g($$$vaSchemaDescGbl(pCategory,"CS",cs,i)))_"'")
			set altdesc=$g($$$vaSchemaDescGbl(pCategory,"CS",cs,i,"alt"))
			if altdesc'="" Do pFile.Write(" altdesc='"_$$$escape(altdesc)_"'")
			if $li(definition,i)'="" Do pFile.Write(" componentstruct='"_..stripDefCategory($li(definition,i),pCategory,base)_"'")
			set codetable=$g($$$vaSchemaGbl(pCategory,"CS",cs,"tables",i))
			if codetable'="" Do pFile.Write(" codetable='"_..stripDefCategory(codetable,pCategory,base)_"'")
			Do pFile.WriteLine("/>")
		}
		Do pFile.WriteLine("</ComponentStructure>")
	}
	#; code table
	if $d($$$vaSchemaGbl(pCategory,"CT")) Do pFile.WriteLine("")
	set ct="" for { set ct=$o($$$vaSchemaGbl(pCategory,"CT",ct)) quit:ct=""
		set definition=$g($$$vaSchemaGbl(pCategory,"CT",ct))
		set description=$g($$$vaSchemaDescGbl(pCategory,"CT",ct))
		Do pFile.Write("<CodeTable name='"_ct_"'")
		Do pFile.Write(" tabletype='"_definition_"'")
		if description'="" Do pFile.Write(" description='"_$$$escape(description)_"'")
		Do pFile.WriteLine(">")
		kill indexed
		set one="" For  { set one=$o($$$vaSchemaGbl(pCategory,"CT",ct,one)) Quit:one=""
			set indexed($$$vaSchemaGbl(pCategory,"CT",ct,one))=one
		}
		set i="" For  { set i=$o(indexed(i)) Quit:i=""
			Set description=$g($$$vaSchemaDescGbl(pCategory,"CT",ct,indexed(i)))
			Do pFile.Write("   <Enumerate")
			Do pFile.Write(" position='"_i_"'")
			Set tVal=indexed(i)  Set:$C(0)=tVal tVal=""
			Do pFile.Write(" value='"_$$$escape(tVal)_"'")
			If description'="" Do pFile.Write(" description='"_$$$escape(description)_"'")
			Do pFile.WriteLine("/>")
		}
		Do pFile.WriteLine("</CodeTable>")
	}
	Do pFile.WriteLine("")
	Do pFile.WriteLine("</Category>")
	Do:pFile.%Extends("%Library.FileStreamAdaptor") pFile.SaveStream()
	Quit $$$OK
]]></Implementation>
</Method>

<Property name="category">
</Property>

<Property name="base">
</Property>

<Property name="elementtype">
</Property>

<Property name="elementname">
</Property>

<Method name="startElement">
<FormalSpec>uri:%Library.String,localname:%Library.String,qname:%Library.String,attrs:%Library.List</FormalSpec>
<Implementation><![CDATA[
	for i=0:1:$LL(attrs)\5-1 set attribs($li(attrs,i*5+2))=$li(attrs,i*5+5)
	if localname="Category" {
		If ..CatOnly Set ..lastFileCategory=attribs("name")  ZTrap "GCAT"
		set ..category=$S(""'=..forceCategory:..forceCategory, 1:attribs("name")), ..forceCategory=""
		set ..base=$g(attribs("base"))
		set desc=$g(attribs("description"))
		set std=$g(attribs("std"))
		kill $$$vaSchemaGbl(..category)
		kill $$$vaSchemaDescGbl(..category)
		if ..base'="" set $$$vaSchemaGbl(..category,"base")=..base
		if desc'="" set $$$vaSchemaDescGbl(..category)=desc
		if $Case($ZCVT(std,"L"),"":0,0:0,"false":0,:1) set $$$vaSchemaDescGbl(..category,"std")=1
	} elseif localname="DocumentStructure" {
		if $g(attribs("description"))'="" set $$$vaSchemaDescGbl(..category,"DS",attribs("name"))=attribs("description")
		set $$$vaSchemaGbl(..category,"DS",attribs("name"))=$g(attribs("definition"))
	} elseif localname="SegmentStructure" {
 		set ..elementtype="SS"
		set ..elementname=attribs("name")
		if $g(attribs("description"))'="" set $$$vaSchemaDescGbl(..category,"SS",..elementname)=attribs("description")
		set $$$vaSchemaGbl(..category,"SS",..elementname)=""
	} elseif localname="SegmentSubStructure" {
		if ..elementtype'="SS" quit
		if $g(attribs("description"))'="" set $$$vaSchemaDescGbl(..category,"SS",..elementname,attribs("piece"))=attribs("description")
		if $g(attribs("altdesc"))'=""     set $$$vaSchemaDescGbl(..category,"SS",..elementname,attribs("piece"),"alt")=attribs("altdesc")
		if $g(attribs("codetable"))'=""   set $$$vaSchemaGbl(..category,"SS",..elementname,"tables",attribs("piece"))=attribs("codetable")
		set componentstructure=$g(attribs("componentstruct"))
		set definition=$lb(componentstructure,$g(attribs("symbol")),$g(attribs("repeatcount")),+$g(attribs("length")),$g(attribs("required")),+$g(attribs("ifrepeating")))
		set $li($$$vaSchemaGbl(..category,"SS",..elementname),attribs("piece"))=definition
		set propname=..fieldDescToName(attribs("description"),..elementname,attribs("piece"))
		set $$$vaSchemaGbl(..category,"SS",..elementname,"names",propname)=attribs("piece")
	} elseif localname="ComponentStructure" {
		set ..elementtype="CS"
		set ..elementname=attribs("name")
		if $g(attribs("description"))'="" set $$$vaSchemaDescGbl(..category,"CS",attribs("name"))=attribs("description")
		set $$$vaSchemaGbl(..category,"CS",attribs("name"))=""
	} elseif localname="ComponentSubStructure" {
		if ..elementtype'="CS" quit
		if $g(attribs("description"))'="" set $$$vaSchemaDescGbl(..category,"CS",..elementname,attribs("piece"))=attribs("description")
		if $g(attribs("altdesc"))'=""     set $$$vaSchemaDescGbl(..category,"CS",..elementname,attribs("piece"),"alt")=attribs("altdesc")
		if $g(attribs("codetable"))'="" set $$$vaSchemaGbl(..category,"CS",..elementname,"tables",attribs("piece"))=attribs("codetable")
		set definition=$g(attribs("componentstruct"))
		set $li($$$vaSchemaGbl(..category,"CS",..elementname),attribs("piece"))=definition
		set propname=..componentDescToName(attribs("description"),..elementname,attribs("piece"))
		set $$$vaSchemaGbl(..category,"CS",..elementname,"names",propname)=attribs("piece")
	} elseif localname="CodeTable" {
		set ..elementtype="CT"
		set ..elementname=attribs("name")
		set:""'=$g(attribs("description")) $$$vaSchemaDescGbl(..category,"CT",..elementname)=attribs("description")
		set:""'=$g(attribs("tabletype")) $$$vaSchemaGbl(..category,"CT",..elementname)=attribs("tabletype")
	} elseif localname="Enumerate" {
		if ..elementtype'="CT" quit
		set tVal=attribs("value")  Set:""=tVal tVal=$C(0)
		if $g(attribs("description"))'="" set $$$vaSchemaDescGbl(..category,"CT",..elementname,tVal)=attribs("description")
		set $$$vaSchemaGbl(..category,"CT",..elementname,tVal)=attribs("position")
	} elseif ..category_..lastFileCategory'="" {
		Set ..Error=$$$ERROR($$$CacheError,"unrecognized tag <"_localname_"> in load of schema "_..Filename)
	}
	quit
]]></Implementation>
</Method>

<Method name="fieldDescToName">
<ClassMethod>1</ClassMethod>
<FormalSpec>desc,elem,piece</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $ZStrip($ZCVT($TR(desc,"/'"_$C(8217)," "),"W"),"*P")
]]></Implementation>
</Method>

<Method name="componentDescToName">
<ClassMethod>1</ClassMethod>
<FormalSpec>desc,elem,piece</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $ZStrip($ZCVT($TR(desc,"/'"_$C(8217)," "),"W"),"*P")
]]></Implementation>
</Method>

<Method name="endElement">
<FormalSpec>uri:%Library.String,localname:%Library.String,qname:%Library.String</FormalSpec>
<Implementation><![CDATA[
	if localname="Category" {
		if $$$ISOK(..Error) {
			set ..Error=..addDefaultCategories(..category,..Filename)
			do ##class(HPRIM.EDI.E1238.Schema).BuildCategoryMaps(..category)
		}
		set $$$vaSchemaGbl(..category,"time")=$ZTS
		set ..lastFileCategory=..category
		set ..category=""
	} elseif localname="SegmentStructure" {
		set ..elementtype=""
		set ..elementname=""
	} elseif localname="ComponentStructure" {
		set ..elementtype=""
		set ..elementname=""
	} elseif localname="CodeTable" {
		set ..elementtype=""
		set ..elementname=""
	}
	quit
]]></Implementation>
</Method>

<Method name="addDefaultCategories">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCategory:%String,pFilename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc=$$$OK
	
	#; document structure
	set ds="" for { set ds=$o($$$vaSchemaGbl(pCategory,"DS",ds)) quit:ds=""
		set definition=$g($$$vaSchemaGbl(pCategory,"DS",ds))
		set:""'=definition $$$vaSchemaGbl(pCategory,"DS",ds)=..addDefaultCategory(definition,pCategory,"SS",.sc,pFilename)
	}
	#; segment structure
	set ss="" for { set ss=$o($$$vaSchemaGbl(pCategory,"SS",ss)) quit:ss=""
		set definition=$g($$$vaSchemaGbl(pCategory,"SS",ss))
		set did=0  for i=1:1:$LL(definition) { continue:'$LD(definition,i)
			set info=$li(definition,i)
			set componentstruct=$lg(info,1)
			set:""'=componentstruct $li(info,1)=..addDefaultCategory(componentstruct,pCategory,"CS",.sc,pFilename), $li(definition,i)=info, did=1
			set codetable=$g($$$vaSchemaGbl(pCategory,"SS",ss,"tables",i))
			set:""'=codetable $$$vaSchemaGbl(pCategory,"SS",ss,"tables",i)=..addDefaultCategory(codetable,pCategory,"CT",.sc,pFilename)
		}
		set:did $$$vaSchemaGbl(pCategory,"SS",ss)=definition
	}
	#; component structure
	set cs="" for { set cs=$o($$$vaSchemaGbl(pCategory,"CS",cs)) quit:cs=""
		set definition=$g($$$vaSchemaGbl(pCategory,"CS",cs))
		set did=0  for i=1:1:$LL(definition)  {
			set componentstruct=$li(definition,i)
			set:""'=componentstruct $li(definition,i)=..addDefaultCategory(componentstruct,pCategory,"CS",.sc,pFilename), did=1
			set codetable=$g($$$vaSchemaGbl(pCategory,"CS",cs,"tables",i))
			set:""'=codetable $$$vaSchemaGbl(pCategory,"CS",cs,"tables",i)=..addDefaultCategory(codetable,pCategory,"CT",.sc,pFilename)
		}
		set:did $$$vaSchemaGbl(pCategory,"CS",cs)=definition
	}
	quit:+$g($$$vaSchemaDescGbl(pCategory,"std")) $$$OK  ; don't report unresolved references in standard schema categories
	quit sc
]]></Implementation>
</Method>

<Method name="addDefaultCategory">
<Description>
Add categories to xml definitions for precise schema global definitions</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pValue:%String,pCategory:%String,pElementType:%String,&pSC:%Status=$$$OK,pFilename:%String]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	for i=1:1:$L(pValue,"~") { set one=$P(pValue,"~",i)  continue:""=one
		continue:one?1P
		set:":"=$E(one) $E(one)="" ; strip leading ':'
		set:".:"=$E(one,1,2) $E(one,1,2)="" ; strip leading '.:'
		set:"base:"=$E(one,1,$L("base:")) $E(one,1,$L("base:"))="" ; strip leading 'base:'
		if one'[":" {
			kill base  set base=pCategory, base(base)=1, tElemType=pElementType, one1=one
			set:"DocsRef"=$e(one,*-$L("DocsRef")+1,*) tElemType="MT", one1=$e(one,1,*-$L("DocsRef"))
			while ""'=base
				 && '$d($$$vaSchemaGbl(base,tElemType,one1))
				 && '("MT"=tElemType && ("ACK_"=$e(one,1,4)) && $d($$$vaSchemaGbl(base,"MT","ACK")))
				 && '("SS"=tElemType && $Case(one,"Zxx":1,"Hxx":1,:0)) {
				set base=$G($$$vaSchemaGbl(base,"base"))
				#; prevent circular references
				if ""=base||$d(base(base)) set base=""  quit
				set base(base)=1
			}
			set:""=base base="."
			set $P(pValue,"~",i)=base_":"_one
			set:"."=base&&$$$ISOK(pSC) pSC=$$$ERROR($$$CacheError,"Unresolved "_tElemType_" reference '"_one_"' in category "_pCategory_" in load of schema "_pFilename)
		}
	}
	quit pValue
]]></Implementation>
</Method>

<Method name="stripDefCategory">
<Description>
Strip schema global definition categories for concise xml format</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pValue:%String,pDefCategory:%String,pBase:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	for i=1:1:$L(pValue,"~") { set one=$P(pValue,"~",i)  continue:""=one
		continue:one?1P
		set:":"=$E(one) $E(one)="" ; strip leading ':'
		if one[":" {
			set oneCat=$P(one,":"),oneDoc=$P(one,":",2)
			if oneCat=pDefCategory { set $P(pValue,"~",i)=oneDoc }
			elseif oneCat=pBase { set $P(pValue,"~",i)="base:"_oneDoc }
		}
	}
	quit pValue
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.SearchTable">
<ClassType>persistent</ClassType>
<CompileAfter>HPRIM.EDI.E1238.Document</CompileAfter>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,Ens.VDoc.SearchTable</Super>
<System>4</System>
<TimeChanged>63619,34494.713098</TimeChanged>
<TimeCreated>59909,35503.94786</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="DOCCLASS">
<Default>HPRIM.EDI.E1238.Document</Default>
</Parameter>

<Parameter name="EXTENTSIZE">
<Default>4000000</Default>
</Parameter>

<UDLText name="T">
<Content><![CDATA[/* Re-declare indices because the superclass is abstract */
]]></Content>
</UDLText>

<Index name="indexValue">
<IdKey>1</IdKey>
<Properties>PropId,PropValue,DocId</Properties>
<Unique>1</Unique>
</Index>

<Index name="indexDocId">
<Properties>DocId,PropId,PropValue</Properties>
<Unique>1</Unique>
</Index>

<XData name="SearchSpec">
<XMLNamespace>http://www.intersystems.com/EnsSearchTable</XMLNamespace>
<Data><![CDATA[
<Items>
<Item DocType=""  PropName="Identifier" >Identifier</Item>
</Items>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^HPRIM.EDI.E1238.SearchTableD</DataLocation>
<DefaultData>SearchTableDefaultData</DefaultData>
<IdLocation>^HPRIM.EDI.E1238.SearchTableD</IdLocation>
<IndexLocation>^HPRIM.EDI.E1238.SearchTableI</IndexLocation>
<StreamLocation>^HPRIM.EDI.E1238.SearchTableS</StreamLocation>
<ExtentSize>4000000</ExtentSize>
<Data name="SearchTableDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="HPRIM.EDI.E1238.Segment">
<ClassType/>
<IncludeCode>HPRIME1238</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject,EnsLib.EDI.Segment</Super>
<System>4</System>
<TimeChanged>64175,60539</TimeChanged>
<TimeCreated>59803,48988.361492</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="FS">
<Description>
Field separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
</Property>

<Property name="SS">
<Description>
Field separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
</Property>

<Property name="RS">
<Description>
Repetition separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
</Property>

<Property name="ESC">
<Description>
Escape separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
</Property>

<Property name="CS">
<Description>
Component separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
</Property>

<Property name="Separators">
<Description>
All 5 Separators as a single String</Description>
<Type>%String</Type>
<InitialExpression>$$$E1238DefSeparators</InitialExpression>
<Parameter name="MAXLEN" value="5"/>
<Parameter name="MINLEN" value="5"/>
</Property>

<Property name="DataArray">
<Description>
Local copy of segment data decomposed into multidimensional array</Description>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="DocTypeCategory">
<Description>
the Category portion of the DocType</Description>
<Type>%String</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="DocTypeName">
<Description>
the Name portion of the DocType ( name [ ! required fields] - ordinal )</Description>
<Type>%String</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="FullSize">
<Description><![CDATA[
Size in bytes of the segment content (even if >32k)]]></Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="%Cloned">
<Description>
Were we cloned from another Segment object? (If so, we won't be responsible for deleting the underlying segment ID data node if any)</Description>
<Type>%Boolean</Type>
<Internal>1</Internal>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="PokeDocType">
<CodeMode>expression</CodeMode>
<FormalSpec>pDocType:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..DocTypeSet(pDocType)
]]></Implementation>
</Method>

<Method name="DocTypeSet">
<FormalSpec>pDocType:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%DocType=pDocType
	Set i%DocTypeCategory=$P(i%DocType,":",1)
	Set i%DocTypeName=$P(i%DocType,":",2)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FSGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$FLDSEP(..Separators)
]]></Implementation>
</Method>

<Method name="SSGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$SSSEP(..Separators)
]]></Implementation>
</Method>

<Method name="RSGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$REPSEP(..Separators)
]]></Implementation>
</Method>

<Method name="ESCGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$ESCSEP(..Separators)
]]></Implementation>
</Method>

<Method name="CSGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$COMSEP(..Separators)
]]></Implementation>
</Method>

<Method name="FSSet">
<FormalSpec>newval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $$$FLDSEP(i%Separators)=$E(newval_$$$E1238DefFS)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SSSet">
<FormalSpec>newval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $$$SSSEP(i%Separators)=$E(newval_$$$E1238DefSS)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="RSSet">
<FormalSpec>newval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $$$REPSEP(i%Separators)=$E(newval_$$$E1238DefRS)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ESCSet">
<FormalSpec>newval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $$$ESCSEP(i%Separators)=$E(newval_$$$E1238DefESC)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CSSet">
<FormalSpec>newval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $$$COMSEP(i%Separators)=$E(newval_$$$E1238DefCS)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SeparatorsSet">
<FormalSpec>newvalue:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%Separators=$E(newvalue,1,5)
	Set:$L(newvalue)<5 i%Separators=i%Separators_$E($$$E1238DefSeparators,$L(newvalue)+1,5)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FullSizeGet">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set data=..GetValueAt("")
	If data=""||(..ID="")||$D(..DataArray)||'$D($$$vaSegmentGbl(..ID,1)) {
		Set len=$L(data)
	} Else {
		Set len=$L(data)
		For i=1:1 { Quit:'$D($$$vaSegmentGbl(..ID,i),data)
			Set len=len+$L(data)
		}
	}
	Quit len
]]></Implementation>
</Method>

<Method name="init">
<FormalSpec>pSegID:%String,pMutable:%Boolean,pDocType:%String,pSegData:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..DocType=pDocType
	If pSegID="" {
		If ""=pSegData {
			Set i%IsMutable=1
		} Else {
			#; If SegData supplied, use that
			Set i%IsMutable=+pMutable
			Set tSC=..decomposeData(pSegData)  Quit:$$$ISERR(tSC) tSC
			Set ..Separators=pSegData
		}
		Quit $$$OK
	}
	#; Verify that segment exists
	Set data=$G($$$vaSegmentGbl(pSegID))
	Quit:""=data $$$ERROR($$$EnsErrGeneral,"Segment "_pSegID_" does not exist")
	Set i%ID=pSegID, i%IsMutable=+pMutable, i%%Cloned=''pSegData
	Set ..Separators=data
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnConstructClone">
<FormalSpec><![CDATA[object:%RegisteredObject,deep:%Boolean=0,&cloned:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%IsMutable=1, i%%Cloned=1
	Set:$D(..DataArray) i%ID=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SaveData">
<Description>
Compose the segment and store it at a new ID</Description>
<FormalSpec>pSeparators:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $D(..DataArray) && (""=..ID || ..IsMutable) {
		Set tSeparators=$S(""=$G(pSeparators):..Separators, 1:pSeparators)
		Set tIndex=$I($$$vaSegmentGbl)
		Set $$$vaSegmentGbl(tIndex)=$E(tSeparators,1,5)_..getAtFromArray("",tSeparators)
		Set i%ID=tIndex, i%IsMutable=0, i%%Cloned=0
	} Else { $$$ASSERT(+..ID=..ID&&(..ID>0)) }
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OutputToDevice">
<FormalSpec><![CDATA[pSeparators:%String,&pDoFraming:%Integer,pResponseTimeout:%Numeric=-1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tDeviceStream=##class(%IO.DeviceStream).AttachNew(,.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit ..OutputToIOStream(tDeviceStream, .pSeparators, .pDoFraming, .pResponseTimeout)
]]></Implementation>
</Method>

<Method name="OutputToLibraryStream">
<FormalSpec><![CDATA[pLibStream:%Stream.Object,pSeparators:%String,&pDoFraming:%Integer,pResponseTimeout:%Numeric=-1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=$S(pLibStream.%Extends("%IO.I.CharacterStream"):pLibStream,1:##Class(%IO.MetaCharacterStream).%New(pLibStream))
	Quit ..OutputToIOStream(tIOStream, .pSeparators, .pDoFraming, .pResponseTimeout)
]]></Implementation>
</Method>

<Method name="OutputToString">
<FormalSpec><![CDATA[pSeparators:%String,&pDoFraming:%Integer,pResponseTimeout:%Numeric=-1,*pStatus:%Status]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=##Class(%IO.StringStream).%New()
	Set pStatus = ..OutputToIOStream(tIOStream, .pSeparators, .pDoFraming, .pResponseTimeout)
	Do tIOStream.Rewind()
	Quit tIOStream.Read()
]]></Implementation>
</Method>

<Method name="OutputToIOStream">
<Description>
Convert segments back to Stream</Description>
<FormalSpec><![CDATA[pIOStream:%IO.I.CharacterStream,pSeparators:%String,&pDoFraming:%Integer=0,pResponseTimeout:%Numeric=-1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define ABS(%n)	$S(%n>=0:%n,1:-%n)
	Set tSC=$$$OK, $ZT="Trap"
	Set data=..GetValueAt("",.pSeparators)
	Set i=0 While data'="" {
		Set tDone=(..ID=""||$D(..DataArray)||'$D($$$vaSegmentGbl(..ID,i+1)))

		If 'pDoFraming { Do pIOStream.Write(data,,.tSC)  Set data="" }
		Else {
			Set tFrameNum=$$$ABS(pDoFraming)-1
			Set tChunk=$E(data,1,240), data=$E(data,241,*)
			Set tChunk=tFrameNum_tChunk_$S(""=data&&tDone:$S($C(13)=$E(tChunk,*):"",1:$C(13))_$$$ETX,1:$$$ETB)
			Do pIOStream.Write($$$STX_tChunk_$$$CHKSUM(tChunk)_$C(13,10),(pDoFraming<0),.tSC)
			If pDoFraming<0 {
				While 1 {
					If pResponseTimeout=-1 {
						Read tACK#1
					} Else {
						Read tACK#1:pResponseTimeout  Set tTimedOut='$Test
						If tTimedOut Set tSC=$$$ERROR($$$EnsErrTCPReadTimeoutExpired,pResponseTimeout,"ASTM Frame ACK","binary")  Quit
					}
					Quit:$$$ACK=tACK
					Continue:$C(13,10)[tACK
					Set tSC=$$$ERROR($$$EnsErrGeneral,"Received unexpected E1238 Frame ACK character: Ascii "_$A(tACK))
					Quit
				}
				Set pDoFraming=-1-(tFrameNum+1#8)
			} Else {
				Set pDoFraming=1+(tFrameNum+1#8)
			}
		}
		Quit:$$$ISERR(tSC)
		Set:""=data&&'tDone i=i+1, data=$G($$$vaSegmentGbl(..ID,i))
	}
	// BSU - Ajout CR devant le LF
	Do:$$$ISOK(tSC)&&'pDoFraming pIOStream.Write($C(13,10),,.tSC)
Exit
	Quit tSC
Trap
	Set $ZT="", tZE=$ZE, tSC=$$$SystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="outputHTMLSeg">
<FormalSpec>pSeparators:%String,pSegNum:%String="",pSegPath:%String="",pDocument:EnsLib.EDI.Document=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..OutputToDevice(.pSeparators,,pSegNum,pSegPath,pDocument,"HPRIM.EDI.E1238.Util.FormatHTML")
]]></Implementation>
</Method>

<Method name="outputHTMLSegZen">
<FormalSpec>pSeparators:%String,pSegNum:%String="",pSegPath:%String="",pDocument:EnsLib.EDI.Document=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..OutputToDevice(.pSeparators,,pSegNum,pSegPath,pDocument,"HPRIM.EDI.E1238.Util.FormatHTMLZen")
]]></Implementation>
</Method>

<Method name="ImportFromString">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pString:%String,*pStatus:%Status,pSeparators:%String,&pConfigItem:%String="",pIOFormatClassname:%String]]></FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Segment</ReturnType>
<Implementation><![CDATA[
	If ""'=$G(pIOFormatClassname) {
		Set tIOStream=##Class(%IO.StringStream).%New(pString)
		Set tSeg=..ImportFromIOStream(tIOStream,.pStatus,.pSeparators,.pIOFormatClassname)
		Quit:$$$IsdefObject(tSeg)||$$$ISERR(pStatus) $G(tSeg)
		// Else assume it abdicated and continue to decomposeData()
	}
	Set tSeg=..%New()
	Set tSeparators=$S(""=$G(pSeparators):tSeg.Separators, 1:pSeparators)
	Set pStatus=tSeg.decomposeData(tSeparators_pString)
	Quit:$$$ISERR(pStatus) $$$NULLOREF
	Quit tSeg
]]></Implementation>
</Method>

<Method name="ImportFromIOStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.I.CharacterStream,*pStatus:%Status=$$$OK,pSeparators:%String,pIOFormatClassname:%String=""</FormalSpec>
<ReturnType>HPRIM.EDI.E1238.Document</ReturnType>
<Implementation><![CDATA[
	Quit:""'=pIOFormatClassname&&$classmethod(pIOFormatClassname,"ImportSegment",.tSeg,.pStatus,pIOStream,.pSeparators) tSeg
	Set tString=pIOStream.Read()
	Quit ..ImportFromString(tString,.pStatus,.pSeparators)
]]></Implementation>
</Method>

<Method name="ReadRawDataStream">
<Description><![CDATA[
Read a field from a >32k segment, or the whole segment, into a stream. Note that this will return the entire remainder of the segment, not stopping at the end of the field specified in pPropertyPath]]></Description>
<FormalSpec><![CDATA[&pStream:%Stream.Object,pPropertyPath:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set:'$$$IsdefObject(pStream) pStream=$zobjclassmethod($S(""'=$G(pStream):pStream, 1:"%Library.GlobalCharacterStream"),"%New")

	Set tMarker=..GetValueAt(pPropertyPath,,.tSC)  Quit:$$$ISERR(tSC) tSC
	If pStream.%Extends("%IO.I.Stream") {
		Do pStream.Write(tMarker,.tSC)  Quit:$$$ISERR(tSC) tSC
	} Else {
		Set tSC=pStream.Write(tMarker)  Quit:$$$ISERR(tSC) tSC
	}
	Set data0=$S(""=..ID:".", 1:$$$vaSegmentGbl(..ID))
	Quit:""=..ID||($F(data0,tMarker,5)-1<$L(data0)) tSC
	For i=1:1 { Quit:'$D($$$vaSegmentGbl(..ID,i),data)
		If pStream.%Extends("%IO.I.Stream") {
			Do pStream.Write(data,.tSC)  Quit:$$$ISERR(tSC)
		} Else {
			Set tSC=pStream.Write(data)  Quit:$$$ISERR(tSC)
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="StoreRawDataStream">
<Description><![CDATA[
Write a >32k field or whole segment stream to a segment. Note that this renders the segment immutable after completing, and therefore works only once per segment.]]></Description>
<FormalSpec>pStream:%Stream.Object,pPropertyPath:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define MAXSEGSTR	32767
	Set tSC=$$$OK, i=0, tMarker=..ESC_".stream"_..ESC
	If pStream.%Extends("%IO.I.Stream") {
		Set chunk=pStream.Read($$$MAXSEGSTR,,.tSC)  Quit:$$$ISERR(tSC) tSC
	} Else {
		Set chunk=pStream.Read($$$MAXSEGSTR,.tSC)  Quit:$$$ISERR(tSC) tSC
	}
	Set tSC=..SetValueAt(tMarker,pPropertyPath)  Quit:$$$ISERR(tSC) tSC
	Set tSC=..SaveData()  Quit:$$$ISERR(tSC) tSC
	Kill ..DataArray
	Set data=$$$vaSegmentGbl(..ID)
	Set pos=$F(data,tMarker,5) Quit:'pos $$$ERROR($$$EnsErrGeneral,"Unable find stream store location in segment")
	Set data2=$E(data,pos,*)

	Set chunkpos=pos-$L(tMarker), chunkmax=$$$MAXSEGSTR-(chunkpos-1)
	Set $E($$$vaSegmentGbl(..ID),chunkpos,$L(data))=$E(chunk,1,chunkmax)

	Set i=0,prevchunk="",tLast2=0 For {
		Set:""=chunk&&'tLast2 tLast2=1
		Set chunk=$S(chunkmax-$L(prevchunk)>$L(chunk):"", 1:$E(chunk,chunkmax-$L(prevchunk)+1,*))
		Set chunkpos=$L($S('i:$$$vaSegmentGbl(..ID),1:$$$vaSegmentGbl(..ID,i)))+1
		If chunkpos>$$$MAXSEGSTR { Set i=i+1, chunkpos=1, chunkmax=$$$MAXSEGSTR }
		Else { Set chunkmax=$$$MAXSEGSTR-(chunkpos-1) }
		
		If tLast2 {
			Set prevchunk=""
			Quit:data2_chunk=""
			Set:data2'="" chunk=data2, data2=""
		} Else {
			Set prevchunk=chunk
			If pStream.%Extends("%IO.I.Stream") {
				Set chunk=pStream.Read($$$MAXSEGSTR,,.tSC)  Quit:$$$ISERR(tSC)
			} Else {
				Set chunk=pStream.Read($$$MAXSEGSTR,.tSC)  Quit:$$$ISERR(tSC)
			}
		}
		If 'i {
			Set $$$vaSegmentGbl(..ID)=$$$vaSegmentGbl(..ID)_prevchunk_$E(chunk,1,chunkmax-$L(prevchunk))
		} Else {
			Set $$$vaSegmentGbl(..ID,i)=$G($$$vaSegmentGbl(..ID,i))_prevchunk_$E(chunk,1,chunkmax-$L(prevchunk))
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetValueAt">
<Description>
pPropertyPath is of syntax: field [ ( array ) ] [ . component ]
Returns the value at the specified property path. pSeparators is used to specify the
separators to be used when a non-atomic value is returned.
All property path elements must be either name or index.</Description>
<FormalSpec>pPropertyPath:%String,pSeparators:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If (..ID="")||$D(..DataArray) {
		Quit ..getAtFromArray(.pPropertyPath,.pSeparators,.pStatus)
	} Else {
		Quit ..getAtFromGlobal(.pPropertyPath,.pSeparators,.pStatus)
	}
]]></Implementation>
</Method>

<Method name="GetNextIndex">
<Description>
Gets the next index in an array</Description>
<FormalSpec><![CDATA[pPath:%String,pIndex:%String,&pStatus:%Status=$$$OK]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If $E(pPath,*-1,*)'="()" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Can't iterate on PropertyPath '"_pPath_"'")  Quit ""
	Set field=$E(pPath,1,*-2)
	If +field'=field {
		If field="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Can't iterate on empty PropertyPath")  Quit ""
		Set field=$S((..DocTypeCategory="")||(..DocTypeName=""):"", 1:$G($$$vaSchemaGbl(..DocTypeCategory,"SS",..DocTypeName,"map",$ZCVT(field,"L"))))
		If $E(field,*-1,*)'="()" Set pStatus=$$$ERROR($$$EnsErrGeneral,"PropertyPath '"_field_"' is not an array property")  Quit ""
		Set field=$E(field,1,*-2)
		If +field'=field Set pStatus=$$$ERROR($$$EnsErrGeneral,"Unrecognized Property Index '"_field_"'")  Quit ""
	}
	If $Case(..Name,"H":0,:1) Set field=field+1
	If '$D(..DataArray) Set pStatus=..decompose() Quit:$$$ISERR(pStatus) ""
	Quit $O(..DataArray(field,pIndex))
]]></Implementation>
</Method>

<Method name="SetValueAt">
<Description><![CDATA[
Sets the value at the specified property path.
pPropertyPath is of syntax: field [ ( array ) ] [ . component ]
All property path elements must be either name or index. pKey is used to append an array index to the value at
the given property path. pAction corresponds to the actions in the DTL <assign> statement.]]></Description>
<FormalSpec>pValue:%String,pPropertyPath:%String="",pAction:%String="set",pKey:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Segment is immutable")
	Set:$Case(pAction,"remove":1,"clear":1,:'($D(pValue)#2)) pValue=""
	If '$D(..DataArray) Set tSC=..decompose()  Quit:$$$ISERR(tSC) tSC
	Set i%ID="" ; clear the ID because we are no longer referring to it
	If pKey'="" Set pPropertyPath=pPropertyPath_"("_pKey_")"
	Set tSC=..parsePropertyPath(pPropertyPath,.field,.array,.component,.subcomponent)  Quit:$$$ISERR(tSC) tSC
	
	If $Case(..Name,"H":1,:0) {
		If field=2 Set ..FS=pValue Quit $$$OK
		If field=3 Set ..Separators=..FS_pValue Quit $$$OK
		If field'="",field>1 Set field=field-1
	}
	Set data=pValue
	If field="" {
		Kill:pAction'="append" ..DataArray
		Set data1=data
		For i=1:1:$L(data1,..FS) { Set data2=$P(data1,..FS,i)
			For j=1:1:$L(data2,..RS) { Set data3=$P(data2,..RS,j)
				For k=1:1:$L(data3,..SS) { Set data4=$P(data3,..CS,k)
					For l=1:1:$L(data4,..CS) { Set ..DataArray(i,j,k,l)=$S(pAction="append":$G(..DataArray(i,j,k,l)),1:"")_$P(data4,..CS,l) }
				}
			}
		}
	} ElseIf array="" {
		Kill:pAction'="append" ..DataArray(field)
		Set data2=data
		For j=1:1:$L(data2,..RS) { Set data3=$P(data2,..RS,j)
			For k=1:1:$L(data3,..SS) { Set data4=$P(data3,..CS,k)
					For l=1:1:$L(data4,..CS) { Set ..DataArray(field,j,k,l)=$S(pAction="append":$G(..DataArray(i,j,k,l)),1:"")_$P(data4,..CS,l) }
				}
		}
	} ElseIf component="" {
		Kill:pAction'="append" ..DataArray(field,array)
		Set data3=data
		For k=1:1:$L(data3,..SS) { Set data4=$P(data3,..SS,k)
			For l=1:1:$L(data4,..CS) { Set ..DataArray(field,array,k,l)=$S(pAction="append":$G(..DataArray(field,array,k,l)),1:"")_$P(data4,..CS,l) }
		}
	} ElseIf subcomponent="" {
		Kill:pAction'="append" ..DataArray(field,array,component)
		Set data4=data
		For l=1:1:$L(data4,..SS) { Set ..DataArray(field,array,component,l)=$S(pAction="append":$G(..DataArray(field,array,component,l)),1:"")_$P(data4,..SS,l) }
	} Else {
		Set ..DataArray(field,array,component,subcomponent)=$S(pAction="append":$G(..DataArray(field,array,component,subcomponent)),1:"")_data
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CopyValues">
<FormalSpec>pSource:HPRIM.EDI.E1238.Segment,pSourcePath:%String,pTargetPath:%String,pAction:%String,pKey:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSourceWild=$F(pSourcePath,"()"), tTargetWild=$F(pTargetPath,"()")
	If tSourceWild||tTargetWild {
		Set tSourceHead=$E(pSourcePath,1,tSourceWild-3), tSourceTail=$E(pSourcePath,tSourceWild,*)
		Set tTargetHead=$E(pTargetPath,1,tTargetWild-3), tTargetTail=$E(pTargetPath,tTargetWild,*)
		If tSourceWild {
			Set i="" For { Set i=pSource.GetNextIndex(tSourceHead_"()",i,.tSC) Quit:i=""
				Set tSourceNewPath=tSourceHead_"("_(i)_")"_tSourceTail
				Set tTargetNewPath=$S(tTargetWild:tTargetHead_"("_(i)_")"_tTargetTail,1:pTargetPath)
				Set tSC=..CopyValues(pSource,tSourceNewPath,tTargetNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
			}
		} Else {
			Set i="" For { Set i=..GetNextIndex(tTargetHead_"()",i,.tSC) Quit:i=""
				Set tTargetNewPath=tTargetHead_"("_(i)_")"_tTargetTail
				Set tSC=..CopyValues(pSource,pSourcePath,tTargetNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
			}
		}
	} Else {
		Set tSC=..SetValueAt(pSource.GetValueAt(pSourcePath),pTargetPath,pAction,pKey)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="decompose">
<Description>
Decompose the segment from a single string into a multidimensional array</Description>
<CodeMode>expression</CodeMode>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
$S($D(..DataArray):$$$ERROR($$$EnsErrGeneral,"array data already exists")
	,""=..ID:$$$OK
	, 1:..decomposeData($$$vaSegmentGbl(..ID)))
]]></Implementation>
</Method>

<Method name="decomposeData">
<FormalSpec>pData:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set FS=$$$FLDSEP(pData), SS = $$$SSSEP(pData), CS=$$$COMSEP(pData), RS=$$$REPSEP(pData), ESC=$$$ESCSEP(pData), data1=$E(pData,6,*)
	Set tName=$P(data1,FS)
	For i=1:1:$L(data1,FS) { Set data2=$P(data1,FS,i)
		If tName="H"&&(i=2) { ; separators
			Set ..DataArray(i,1,1)=FS_$P(data1,FS,i) ; don't try to decompose repeat & component separators
			Continue
		}
		For j=1:1:$L(data2,RS) { Set data3=$P(data2,RS,j)
			For k=1:1:$L(data3,SS) { Set data4=$P(data3,SS,k)
				For l=1:1:$L(data4,CS) { Set ..DataArray(i,j,k,l)=$P(data4,CS,l) }
			}
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getAtFromGlobal">
<FormalSpec>pPropertyPath:%String="",pSeparators:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set data=$$$vaSegmentGbl(..ID)
	If ""=$G(pSeparators) { Set tSeparators=$E(data,1,5) }
	Else {
		Set tSeparators=$E(pSeparators,1,5)
		Set:$E(data,1,5)'=tSeparators data=..replaceSeparators(data,tSeparators)
	}
	Set FS=$$$FLDSEP(data), SS= $$$SSSEP(data), RS=$$$REPSEP(data), ESC=$$$ESCSEP(data), CS=$$$COMSEP(data),data=$E(data,6,*)
	If ""=pPropertyPath Set pStatus=$$$OK  Quit data
	Set pStatus=..parsePropertyPath(pPropertyPath,.field,.array,.component,.subcomponent)  Quit:$$$ISERR(pStatus) ""
	Set tName=$P(data,FS)
	If $Case(tName,"H":1,:0) {
		Quit:field=1 tName
		Quit:field=2 FS
		Quit:field=3 $E(tSeparators,2,4)
		Quit:field="*" $L(data,FS)
		Set:field'="" field=field-1
	}
	If field'="" Set data=$S(field="*":$L(data,FS)-1,1:$P(data,FS,field))
	If array'="" Set data=$S(array="*":$L(data,RS),1:$P(data,RS,array))
	If component'="" Set data=$S(component="*":$L(data,SS),1:$P(data,SS,component))
	If subcomponent'="" Set data=$S(subcomponent="*":$L(data,CS),1:$P(data,CS,subcomponent))
	Quit data
]]></Implementation>
</Method>

<Method name="getAtFromArray">
<FormalSpec>pPropertyPath:%String="",pSeparators:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSeparators=$S(""=$G(pSeparators):..Separators, 1:$E(pSeparators,1,5))
	Set FS=$$$FLDSEP(tSeparators), SS =$$$SSSEP(tSeparators), RS=$$$REPSEP(tSeparators), CS=$$$COMSEP(tSeparators)
	Set pStatus=..parsePropertyPath(pPropertyPath,.I,.J,.K,.L)  Quit:$$$ISERR(pStatus) ""
	Set tName=$G(..DataArray(1,1,1,1))
	If $Case(tName,"H":1,:0) {
		Quit:I=1 tName
		Quit:I=2 FS
		Quit:I=3 $E(tSeparators,2,5)
		Quit:I="*" $O(..DataArray(""),-1)
		If I="" {
			Set data=tName_tSeparators, tCount=$O(..DataArray(""),-1)
			For i=3:1:tCount Set data=data_FS_..GetValueAt(i,tSeparators)
			Quit data
		}
		Set I=I-1
	}
	Set lasti=$O(..DataArray(""),-1)
	If I="*" {
		Set data=lasti-1
	} Else {
		Set data=""
		For i=1:1:lasti {
			If I'="",i'=I Continue
			If I="",i>1 Set data=data_FS
			Set lastj=$O(..DataArray(i,""),-1)
			If J="*" Set data=lastj Quit
			For j=1:1:lastj {
				If J'="",j'=J Continue
				If J="",j>1 Set data=data_RS
				Set lastk=$O(..DataArray(i,j,""),-1)
				If K="*" Set data=lastk Quit
				For k=1:1:lastk {
					If K'="",k'=K Continue
					If K="",k>1 Set data=data_SS
					Set lastl=$O(..DataArray(i,j,k,""),-1)
					If L="*" Set data=lastl Quit
					For l=1:1:lastl {
						If L'="",l'=L Continue
						If L="",l>1 Set data=data_CS
						Set value=$G(..DataArray(i,j,k,l))
						Set:tSeparators'=..Separators value=$E(..replaceSeparators(..Separators_value,tSeparators),6,*)
						Set data=data_value
					}
				}
			}
		}
	}
	Quit data
]]></Implementation>
</Method>

<Method name="Escape">
<FormalSpec>pData</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..EscapeEx(pData,..Separators)
]]></Implementation>
</Method>

<Method name="Unescape">
<FormalSpec>pData</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..UnescapeEx(pData,..Separators)
]]></Implementation>
</Method>

<Method name="EscapeEx">
<ClassMethod>1</ClassMethod>
<FormalSpec>pData,pSeparators,pEscapeChar</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tEscape=$g(pEscapeChar,$$$ESCSEP(pSeparators))
	Set replace($C(10))=tEscape_"X0A"_tEscape
	Set replace($C(13))=tEscape_"X0D"_tEscape
	Set replace($$$FLDSEP(pSeparators))=tEscape_"F"_tEscape
	Set replace($$$REPSEP(pSeparators))=tEscape_"R"_tEscape
	Set replace($$$COMSEP(pSeparators))=tEscape_"S"_tEscape
	Set replace($$$SSSEP(pSeparators))=tEscape_"T"_tEscape
	Set replace($$$ESCSEP(pSeparators))=tEscape_"E"_tEscape
	Quit $$replaceArray^EnsUtil(pData,.replace)
]]></Implementation>
</Method>

<Method name="UnescapeEx">
<ClassMethod>1</ClassMethod>
<FormalSpec>pData,pSeparators,pEscapeChar</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tEscape=$g(pEscapeChar,$$$ESCSEP(pSeparators))
	Set replace(tEscape_"X0A"_tEscape)=$c(10)
	Set replace(tEscape_"X0D"_tEscape)=$c(13)
	Set replace(tEscape_".br"_tEscape)=$C(13)
	Set replace(tEscape_"F"_tEscape)=$$$FLDSEP(pSeparators)
	Set replace(tEscape_"R"_tEscape)=$$$REPSEP(pSeparators)
	Set replace(tEscape_"S"_tEscape)=$$$COMSEP(pSeparators)
	Set replace(tEscape_"T"_tEscape)=$$$SSSEP(pSeparators)
	Set replace(tEscape_"E"_tEscape)=$$$ESCSEP(pSeparators)
	Quit $$replaceArrayLeftToRight^EnsUtil(pData,.replace,5)
]]></Implementation>
</Method>

<Method name="parsePropertyPath">
<Description>
Given a property path, determine the Field, Array, and Component positions</Description>
<FormalSpec>pPropertyPath:%String,*pField:%Integer,*pArray:%Integer,*pComponent:%Integer,*pSubcomponent:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//initial signature pPropertyPath As %String, Output pField As %Integer, Output pSubField As %Integer, Output pArray As %Integer, Output pComponent As %Integer, Output pSubcomponent As %Integer
	Set pField=$P($P(pPropertyPath,".",1),"(",1)
	Set pArray=$P($P($P(pPropertyPath,".",1),"(",2),")",1)
	Set pComponent=$P(pPropertyPath,".",2)
	Set pSubcomponent=$P(pPropertyPath,".",3)

	If pField'="",pField'="*",pField'=0,+pField'=pField {
		Set index=$ZCVT(pField_$S(pComponent="":"",1:"."_pComponent)_$S(pSubcomponent="":"",1:"."_pSubcomponent),"L")
		Set newspec=$S((..DocTypeCategory="")||(..DocTypeName=""):"", 1:$G($$$vaSchemaGbl(..DocTypeCategory,"SS",..DocTypeName,"map",index)))
		If newspec="" Quit $$$ERROR($$$EnsErrGeneral,"PropertyPath '"_pPropertyPath_"' is invalid.")
		Set pField=$P($P(newspec,".",1),"(",1)
		Set pComponent=$P(newspec,".",2)
		Set pSubcomponent=$P(newspec,".",3)
	}
	If +pField=pField Set pField=pField+1
	If pArray="",pComponent'="" Set pArray=1
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="replaceSeparators">
<ClassMethod>1</ClassMethod>
<FormalSpec>pInputData,oSeparators</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set iSeparators=$e(pInputData,1,5)
	Set mSeparators=$c(1,2,3,4,5)
	set tData=$e(pInputData,6,*)
	Set tData=$tr(tData,iSeparators,mSeparators)
	Set tData=..UnescapeEx(tData,iSeparators,$$$ESCSEP(mSeparators))
	Set tData=..EscapeEx(tData,oSeparators,$$$ESCSEP(mSeparators))
	Quit oSeparators_$tr(tData,mSeparators,oSeparators)
]]></Implementation>
</Method>

<Method name="OutputHTML">
<Description>
Display Segment as HTML, using DocType info if available</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	&html<
	<table border="0" cellspacing="0" cellpadding="0" cols="2" width="100%"><tr><td align="center"><div class="Text" style="margin: 3px;">>
	If ""'=..DocType {
		Set tDesc=##class(HPRIM.EDI.E1238.Schema).GetDescription("SS:"_..DocType)
		&html<ASTM <b>#($ZCVT(..Name,"O","HTML"))#</b> Segment, DocType = '<a#($S(""=tDesc:"",1:" title='"_$ZCVT(tDesc,"O","HTML")_"'")_##class(HPRIM.EDI.E1238.Util.FormatHTML).getSegLink(..DocType))#><b>#($ZCVT(..DocType,"O","HTML"))#</b></a>'
			<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#($S(""=tDesc:"", 1:"'<b><i>"_$ZCVT(tDesc,"O","HTML")_"</i></b>', "))#>
	} Else {
		&html<ASTM <b>#($ZCVT(..Name,"O","HTML"))#</b> Segment, DocType = <b>''</b>>
	}
	&html<</div></td></tr></table>>
	&html<<table class="EDIDocumentTable" BORDER="0" CELLSPACING="0" CELLPADDING="0">>
	&html<<TR CLASS="EDIDocumentTableRow"><TD CLASS="EDIDocumentTableExpandor">&nbsp;</TD>>
	Set tSC=..outputHTMLSeg()  Quit:$$$ISERR(tSC)
	&html<</TR>>
	&html<</table>>
	Write:$$$ISERR(tSC) $ZCVT($$$StatusDisplayString(tSC),"O","HTML")
	Quit tSC
]]></Implementation>
</Method>

<Method name="OutputHTMLZen">
<Description>
Display Segment as HTML, using DocType info if available</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set tVDocTxt = $$$Text("ASTM")
	Set tSegTxt = $$$Text("Segment")
	Set tDocTypeTxt = $$$Text("DocType")
	&html<
	<table border="0" cellspacing="0" cellpadding="0" cols="2" width="100%"><tr><td align="left"><div class="Text" style="margin: 3px;">>
	If ""'=..DocType {
		Set tDesc=##class(HPRIM.EDI.E1238.Schema).GetDescription("SS:"_..DocType)
		&html<#(tVDocTxt)# <b>#($ZCVT(..Name,"O","HTML"))#</b> #(tSegTxt)#, #(tDocTypeTxt)# = 
			'<a#($S(""=tDesc:"",1:" title='"_$ZCVT(tDesc,"O","HTML")_"'")_##class(HPRIM.EDI.E1238.Util.FormatHTMLZen).getSegLink(..DocType))#><b>#($ZCVT(..DocType,"O","HTML"))#</b></a>'
			<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#($S(""=tDesc:"", 1:"'<b><i>"_$ZCVT(tDesc,"O","HTML")_"</i></b>', "))#>
	} Else {
		&html<#(tVDocTxt)# <b>#($ZCVT(..Name,"O","HTML"))#</b> #(tSegTxt)#, #(tDocTypeTxt)# = <b>''</b>>
	}
	&html<</div></td></tr></table>>
	&html<<table class="EDIDocumentTable" BORDER="0" CELLSPACING="0" CELLPADDING="0">>
	&html<<TR CLASS="EDIDocumentTableRow"><TD CLASS="EDIDocumentTableExpandor">&nbsp;</TD>>
	Set tSC=..outputHTMLSegZen()  Quit:$$$ISERR(tSC)
	&html<</TR>>
	&html<</table>>
	Write:$$$ISERR(tSC) $ZCVT($$$StatusDisplayString(tSC),"O","HTML")
	Quit tSC
]]></Implementation>
</Method>

<Method name="DumpMaps">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set DocType=..DocType w ! zw DocType
	Set ID=..ID w ! zw ID
	If ..DocTypeCategory'="",..DocTypeName'=""	Merge MapArray=$$$vaSchemaGbl(..DocTypeCategory,"SS",..DocTypeName,"map") w ! zw MapArray
	Merge DataArray=..DataArray w ! zw DataArray
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetContentArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pContents,pMode:%String,pDocType:%String,pLevel:%Integer,pIncludeBase:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tRef=$G(pContents)
	If ("%"=$E(tRef)||("^"=$E(tRef))) {
		Set tSC=##class(HPRIM.EDI.E1238.Schema).getFieldsContentArray(.local,.pMode,$P(pDocType,":",1),$P(pDocType,":",2),$S('pLevel:0,1:pLevel+2))
		Merge @tRef=local
		Quit tSC
	} Else {
		Quit ##class(HPRIM.EDI.E1238.Schema).getFieldsContentArray(.pContents,.pMode,$P(pDocType,":",1),$P(pDocType,":",2),$S('pLevel:0,1:pLevel+2))
	}
]]></Implementation>
</Method>

<Query name="EnumerateDocTypes">
<Description><![CDATA[
Returns a list of available DocTypes for this document class. <br/>
The DocType is returned as the first column in the result set. <br/>
The <var>Category</var> parameter can be used to restrict the list. <br/>
If <var>Category</var> is: <br/>
 0 - return only DocTypes in standard categories <br/>
 + - return only DocTypes in user-defined categories <br/>
 empty - return DocTypes from all categories <br/>
 a category name - return only DocTypes in the named category <br/>
 a partial name suffixed with '%' - return only DocTypes in categories matching the partial category name <br/>
 other - return nothing <br/>
If <var>IncludeBase</var> is: <br/>
 0 - return only DocTypes defined in the current schema category itself <br/>
 1 - return all DocTypes in the current schema category's base category in addition to those defined in the current category itself <br/>]]></Description>
<Type>%Query</Type>
<FormalSpec>Category:%String="",IncludeBase:%Boolean=0</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Type:%String"/>
</Query>

<Method name="EnumerateDocTypesExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary,Category:%String,IncludeBase:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(HPRIM.EDI.E1238.Schema).SegTypesExecute(.qHandle,.Category,0,.IncludeBase)
]]></Implementation>
</Method>

<Method name="EnumerateDocTypesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>EnumerateDocTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##class(HPRIM.EDI.E1238.Schema).SegTypesFetch(.qHandle,.Row,.AtEnd)
	Set:""'=$G(Row) Row=$LB($LG(Row))
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateDocTypesClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateDocTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(HPRIM.EDI.E1238.Schema).SegTypesClose(.qHandle)
]]></Implementation>
</Method>

<Query name="EnumerateTypeCategories">
<Description><![CDATA[
Returns a list of document type schema categories for the document class.<br>
The Standard parameter can be used to restrict the list.<br>
If Standard is:
 0 - return only standard categories
 + - return only user-defined categories
 empty - return all categories
 a category name - return only the named category
 a partial name suffixed with '%' - return only categories matching the partial category name
 other - return nothing]]></Description>
<Type>%Query</Type>
<FormalSpec>Standard:%String=""</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Category:%String,Description:%String,IsStandard:%Boolean,Base:%String"/>
</Query>

<Method name="EnumerateTypeCategoriesExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary,Standard:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(HPRIM.EDI.E1238.Schema).TypeCategoriesExecute(.qHandle, Standard)
]]></Implementation>
</Method>

<Method name="EnumerateTypeCategoriesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>EnumerateTypeCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##class(HPRIM.EDI.E1238.Schema).TypeCategoriesFetch(.qHandle,.Row,.AtEnd)
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateTypeCategoriesClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateTypeCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(HPRIM.EDI.E1238.Schema).TypeCategoriesClose(.qHandle)
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Service.FileService">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>HPRIM.EDI.E1238.Service.Standard</Super>
<System>4</System>
<TimeChanged>64176,64611.078507</TimeChanged>
<TimeCreated>59449,55308.277931</TimeCreated>

<Parameter name="ADAPTER">
<Default>EnsLib.File.InboundAdapter</Default>
</Parameter>

<Property name="ReplyTargetConfigNames">
<Description>
ConfigName(s) of the operations or processes to which reply messages should be forwarded.</Description>
<Type>%String</Type>
</Property>

<Parameter name="SETTINGS">
<Default><![CDATA[ReplyTargetConfigNames::selector?multiSelect=1&context={Ens.ContextSearch/ProductionItems?targets=1&productionName=@productionId}]]></Default>
</Parameter>

<Parameter name="OpenTimeout">
<Type>%Numeric</Type>
<Default>5</Default>
</Parameter>

<Parameter name="ReadTimeout">
<Type>%Numeric</Type>
<Default>1</Default>
</Parameter>

<Method name="OnInit">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##super()  Quit:$$$ISERR(tSC) tSC
	Set (..%Parser.StartTimeout,..%Parser.ReadTimeout)=..#ReadTimeout
	If $$$XOR(""=..ReplyTargetConfigNames,"Never"=..ReplyMode) {
		If ""=..ReplyTargetConfigNames { $$$LOGWARNING("No Reply Target Config Name configured for ReplyMode '"_..ReplyMode_"'") }
		Else { $$$LOGWARNING("Reply Target ConfigName(s) '"_..ReplyTargetConfigNames_"' configured for ReplyMode '"_..ReplyMode_"'") }
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnProcessInput">
<FormalSpec>pFileStream:%CharacterStream,*pOutput:%RegisteredObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tInputFilename=$tr(pFileStream.Filename,"/","\"), tInputFilename=$p(tInputFilename,"\",$l(tInputFilename,"\")) 
	$$$sysTRACE("Got File "_tInputFilename)
	Set tIOStream=##class(%IO.FileStream).%New()
	Set tIOStream.LineTerminator=$C(13,10) ; override OS dependent default
	Do tIOStream.Open(pFileStream.Filename,,..#OpenTimeout,,.tSC)  Quit:$$$ISERR(tSC) tSC

	Do ..%Parser.Reset()

	While 'tIOStream.AtEnd { ; Loop over docs in the file
		Set tSC1=..%Parser.ParseIOStream(tIOStream)
		Set:$$$ISERR(tSC1) tSC=$$$ADDSC(tSC,tSC1)
		Quit:$$$StatusEquals(tSC1,$$$EnsErrGeneral) // !!! quit on fatal errors only
	}
	Do ..%Parser.Reset() ; release the file
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendReply">
<FormalSpec>pReplyDocument:EnsLib.EDI.Document,pOriginalDoc:EnsLib.EDI.Document=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ""=..ReplyTargetConfigNames {
		$$$sysTRACE("Reply "_$S($IsObject(pReplyDocument):"/"_pReplyDocument.%Id(),1:"")_" not sent because no Reply Target Config Name is configured")
		Quit $$$OK
	}
	Set pReplyDocument.IsMutable=0
	Set tSC=$$$OK  For iTarget=1:1:$L(..ReplyTargetConfigNames, ",") { Set tOneTarget=$ZStrip($P(..ReplyTargetConfigNames,",",iTarget),"<>W")  Continue:""=tOneTarget
		Set tSC1=..SendRequestAsync(tOneTarget,pReplyDocument) Quit:$$$ISERR(tSC)
		Set:$$$ISERR(tSC1) tSC=$$$ADDSC(tSC,tSC1)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnGetConnections">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pArray:%String,pItem:Ens.Config.Item</FormalSpec>
<Implementation><![CDATA[
	Do ##super(.pArray,pItem)
	If pItem.GetModifiedSetting("ReplyTargetConfigNames",.tValue) {
		For i=1:1:$L(tValue,",") { Set tOne=$ZStrip($P(tValue,",",i),"<>W")  Continue:""=tOne  Set pArray(tOne)="" }
	}
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Service.Standard">
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>HPRIME1238</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessService,EnsLib.EDI.ServiceInterface</Super>
<System>4</System>
<TimeChanged>64176,64918.093829</TimeChanged>
<TimeCreated>59318,79308.969</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="DOCCLASS">
<Type>%String</Type>
<Default>HPRIM.EDI.E1238.Document</Default>
</Parameter>

<Property name="TargetConfigNames">
<Description>
Configuration items to which to send Documents</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="SearchTableClass">
<Description><![CDATA[
Store a set of searchable properties associated with each ASTM document processed.<p>
These records will be stored in the named SearchTable class, if any.]]></Description>
<Type>%String</Type>
<InitialExpression>"HPRIM.EDI.E1238.SearchTable"</InitialExpression>
</Property>

<Property name="DocSchemaCategory">
<Description><![CDATA[
Category to apply to incoming E1238 document type names to produce a complete DocType specification.<p>
Combines with the document type name to produce a DocType assignment.<p>
This setting may also contain multiple comma-separated type names followed by = and then a 
DocTypeCategory or full DocType value to apply to documents declared as that type.<p>
A trailing asterisk (*) at the end of a given partial type Name will match any types with that beginning part.<p/>
An example: DocSchemaCategory='E1394, Q=E1394_Custom, M-*=PVT' <br>
Note that a DocType assignment may be needed for Validation or SearchTableClass indexing.]]></Description>
<Type>%String</Type>
<InitialExpression>"A2.2"</InitialExpression>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="ReplyMode">
<Description><![CDATA[
This is a 2-way interface; you can send outbound on it using a partner Business Operation. However if your target config item wishes to return an immediate response you can enable this by selecting ReplyMode='Application'.<br>
- Never : Do not send back any reply <br>
- Application : Wait for response from target config item and forward it back when it arrives]]></Description>
<Type>%String</Type>
<InitialExpression>"Never"</InitialExpression>
<Parameter name="DISPLAYLIST" value=",Never,Application"/>
<Parameter name="VALUELIST" value=",Never,App"/>
</Property>

<Property name="LocalApplicationID">
<Description><![CDATA[
Colon-separated Local ID:Qualifier codes representing this (receiving) facility and application.<p>
These are used in constructing reply document headers.<p>
The '@' symbol represents using the corresponding field from the incoming message.<p>
If your ID must contain a literal @ symbol, escape it with backslash: '\@']]></Description>
<Type>%String</Type>
<InitialExpression>"E1238Service:ENS"</InitialExpression>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Parameter name="SETTINGS">
<Default><![CDATA[TargetConfigNames:Basic:selector?multiSelect=1&context={Ens.ContextSearch/ProductionItems?targets=1&productionName=@productionId},SearchTableClass::selector?context={Ens.ContextSearch/SearchTableClasses?host=HPRIM.EDI.E1238.Service.Standard},LocalApplicationID,ReplyMode,DocSchemaCategory:Basic:selector?context={HPRIM.ContextSearch/SchemaCategories?host=HPRIM.EDI.E1238.Service.Standard}]]></Default>
</Parameter>

<Property name="Validation">
<Description>
Comma-separated string specifying types of Validation to perform; make it a Setting in your subclass if you override OnValidate() and need to provide options</Description>
<Type>%String</Type>
</Property>

<Parameter name="IndexReplies">
<Description>
If SearchTableClass is set, use it to index any reply documents</Description>
<Type>%Boolean</Type>
<Default>0</Default>
</Parameter>

<Property name="%Parser">
<Type>HPRIM.EDI.E1238.Parser</Type>
</Property>

<Method name="OnInit">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..%Parser=##class(HPRIM.EDI.E1238.Parser).%New($this)
	Set:""=..ReplyMode ..ReplyMode="Never"
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnProcessInput">
<Description>
Note: pDocIn is not declared as HPRIM.EDI.E1238.Document so that subclasses can handle other types and transform them before calling ##super().</Description>
<FormalSpec>pDocIn:%RegisteredObject,*pDocOut:%RegisteredObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	$$$ASSERT(0_"Subclass Responsibility")
]]></Implementation>
</Method>

<Method name="OnValidate">
<Description>
Override this method to implement your own custom method for validating of an incoming Document
Return non-zero to prevent default validation of the message (if any);</Description>
<FormalSpec>pDoc:EnsLib.EDI.Document,pValSpec:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 0
]]></Implementation>
</Method>

<Method name="OnResolveDocType">
<Description>
Override this method to implement your own custom method for resolving the DocType of an incoming Message
Returning nonzero means you are overriding the framework's standard DocType resolution.</Description>
<FormalSpec><![CDATA[pDoc:EnsLib.EDI.Document,&pDocType:%String]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 0
]]></Implementation>
</Method>

<Method name="standardOnProcessInput">
<FormalSpec>pDocIn:HPRIM.EDI.E1238.Document,*pDocOut:HPRIM.EDI.E1238.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK, pDocOut=$$$NULLOREF
	$$$ASSERT($$$IsdefObject(pDocIn) && pDocIn.%IsA("HPRIM.EDI.E1238.Document"))
	$$$sysTRACE("Got Document "_pDocIn_" / "_pDocIn.%Id())
	#; get accepted doc, resolve DocType
	Set tSCVal=..resolveAndIndex(pDocIn)
	Set tResponse=$$$NULLOREF
	If $$$ISOK(tSC)&&$$$ISOK(tSCVal)&&(""'=..TargetConfigNames) {
		Set pDocIn.IsMutable=0
		If $Case(..ReplyMode,"Never":1,:0) {
			$$$SyncCommitSet(tSyncCommit)
			For iTarget=1:1:$L(..TargetConfigNames, ",") { Set tOneTarget=$ZStrip($P(..TargetConfigNames,",",iTarget),"<>W")  Continue:""=tOneTarget
				$$$sysTRACE("Sending E1238 document "_pDocIn_"/"_pDocIn.%Id()_" from "_pDocIn.Source_" to '"_tOneTarget_"'")
				Set tSC1=..SendRequestAsync(tOneTarget,pDocIn)
				Set:$$$ISERR(tSC1) tSC=$$$ADDSC(tSC,tSC1)
			}
			$$$SyncCommitClear(tSyncCommit)
			If $$$ISOK(tSC) $$$sysTRACE("After async forwarding document "_pDocIn_"/"_pDocIn.%Id())
			If ..ReplyMode'="Never" {
				Set pDocOut=..reportReply(pDocIn,,.tSC)
			}
		} Else { ;  Application reply mode (either explicit or ISA-requested)
			If 1'=$L(..TargetConfigNames, ",") $$$LOGWARNING("More than one target config name specified for synchronous forwarding: "_..TargetConfigNames)
			$$$sysTRACE("Sending "_pDocIn_"/"_pDocIn.%Id()_" from "_pDocIn.Source_" to '"_..TargetConfigNames_"'")
			Set tSC=..SendRequestSync(..TargetConfigNames,pDocIn,.tResponse) Quit:$$$ISERR(tSC) tSC
			If '$IsObject(tResponse) { ; no reply message
				$$$sysTRACE("Not returning reply because SendRequestSync() of "_pDocIn_"/"_pDocIn.%Id()_" returned with no response object and status: "_$$$StatusDisplayString(tSC))
			} Else { 
				$$$sysTRACE("Returning reply document "_tResponse.%Id()_" ("_tResponse.Name_") received from document "_pDocIn.%Id()_" forwarded to "_..TargetConfigNames)
			}
		}
	} Else { ; not forwarding due to error or no target
		If $Case(..ReplyMode,"Never":0,:1) {
			If $$$ISOK(tSC)&&$$$ISOK(tSCVal) {
				$$$SyncCommitSet(tSyncCommit)
				Set pDocIn.IsMutable=0, tSC=pDocIn.%Save() ; save the document because we're going to reply to it.
				$$$SyncCommitClear(tSyncCommit)
				If $$$ISERR(tSC) {
					$$$LOGERROR("Failed to save document "_pDocIn_" / "_pDocIn.%Id()_" : "_$$$StatusDisplayString(tSC))
				}
			}
			$$$sysTRACE("Returning reply but not forwarding document "_pDocIn_"/"_pDocIn.%Id()_$S($$$ISERR(tSC):" status "_$$$StatusDisplayString(tSC),1:""))
			Set tSC=$$$ADDSC(tSC,tSCVal)
			Set pDocOut=..reportReply(pDocIn,,.tSC)
		} Else {
			$$$sysTRACE("Not returning reply for document "_pDocIn_"/"_pDocIn.%Id()_"; ReplyMode="_..ReplyMode_$S($$$ISERR(tSC):" status "_$$$StatusDisplayString(tSC),1:""))
		}
	}
	If $IsObject(tResponse) {
		Set pDocOut=..reportReply(pDocIn,tResponse,.tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="getReplyCode">
<FormalSpec>pMSH:HPRIM.EDI.E1238.Segment,pSC:%Status,pSCVal:%Status,pAppACK:%Boolean</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If pAppACK>-1&&$IsObject(pMSH) { Set tAckType=pMSH.GetValueAt($S(pAppACK:16,1:15)), tVersionID=pMSH.GetValueAt("12.1") }
	Else { Set (tAckType,tVersionID)="" }
	#; Choose the appropriate Status character
	Set tCode=$S($$$ISERR(pSCVal):"R", $$$ISERR(pSC):"E", 1:"A") ; Reject / Error / Accept
	#; Send no ACK if the MSH requests not to
	Quit:pAppACK>-1&&$Case(..ReplyMode,"Never":1,"Immed":pAppACK,"App":'pAppACK,"Msh":$Case(tAckType,"NE":1,"ER":(tCode="A"),"SU":(tCode'="A"),:0),:0) ""
	Quit "C"_tCode ; Commit / Application
]]></Implementation>
</Method>

<Method name="resolveAndIndex">
<Description>
Accept only specified document names; resolve DocType and perform requested validation if any</Description>
<FormalSpec>pDoc:EnsLib.EDI.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tDocType=..resolveDocType(pDoc)
	Do pDoc.PokeDocType(tDocType)

	#; Do further validation if required
	Set tSC=$$$OK
	If ""=..Validation||'..OnValidate(pDoc,..Validation,.tSC) {
		#; no default validation
	}
	Quit:$$$ISERR(tSC) tSC

	If ""'=..SearchTableClass {
		TRY {		
			Set tSCStore=$zobjclassmethod(..SearchTableClass,"IndexDoc",pDoc)
			If $$$ISERR(tSCStore) $$$LOGWARNING("Failed to construct SearchTable entries for document "_pDoc_"/"_pDoc.%Id()_" with DocType='"_pDoc.DocType_"' using class '"_..SearchTableClass_"' "_$$$StatusDisplayString(tSCStore))
		} CATCH errobj { $$$LOGWARNING("Failed to invoke SearchTable method "_..SearchTableClass_".IndexDoc() for message "_pDoc_"/"_pDoc.%Id()_" with DocType='"_pDoc.DocType_"' : "_errobj.AsSystemError()) }
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="resolveDocType">
<Description>
Return the DocType that this service will assign to this document</Description>
<FormalSpec>pDoc:HPRIM.EDI.E1238.Document,pMSH:HPRIM.EDI.E1238.Segment=$$$NULLOREF</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tDocType=pDoc.DocType
	If ""=tDocType {
		#; Match with the DocType specified if any in DocSchemaCategory for the received Document's type name
		Set tAcceptTypes=..DocSchemaCategory, tNameFound=pDoc.Name, tUNameFound=$ZCVT(tNameFound,"U")
		Set nTypes=$S(""=$ZStrip(tAcceptTypes,"<>W"):0, 1:$L(tAcceptTypes,","))
		Set (tVal,tDef)=""
		For i=1:1:nTypes { Set tType=$P(tAcceptTypes,",",i) Continue:""=tType
			Set tVal=$ZStrip($P(tType,"=",2),"<>W")
			Set tName=$ZStrip($P(tType,"=",1),"<>W"), tNameLen=$L(tName), tUName=$ZCVT(tName,"U")
			If ""=tVal {
				Set:""=tDef tDef=tName
			} Else {
				#; Quit on match; accept trailing wildcard also
				If tUNameFound=tUName
				 || ("*"=$E(tName,tNameLen) && ($E(tUName,1,tNameLen-1)=$E(tUNameFound,1,tNameLen-1))) {
					If tVal[":" { Set tDocType=tVal }
					Else { Set tDocType=##class(HPRIM.EDI.E1238.Schema).ResolveSchemaTypeToDocType(tVal,tNameFound) }
					Quit
				}
				Set tVal=""
			}
		}
		If ""'=tDocType {
			If tVal[":" {
				$$$sysTRACE("Using DocType='"_tDocType_"' for type name '"_tNameFound_"' matching '"_tUName_"' in DocSchemaCategory list; calling OnResolveDocType()")
			} Else {
				$$$sysTRACE("Using DocType='"_tDocType_"' from schema category '"_tVal_"' for type name '"_tNameFound_"' matching '"_tUName_"' in DocSchemaCategory list; calling OnResolveDocType()")
			}
		} ElseIf ""'=tDef {
			If tDef[":" {
				Set tDocType=tDef
				$$$sysTRACE("Using default DocType='"_tDocType_"' from DocSchemaCategory list '"_tAcceptTypes_"'; type name '"_tNameFound_"' not matched specifically; calling OnResolveDocType()")
			} Else {
				Set tDocType=tDef_":"_tNameFound
				$$$sysTRACE("Using DocType='"_tDocType_"' from default schema category in DocSchemaCategory list '"_tAcceptTypes_"'; type name '"_tNameFound_"' not matched specifically; calling OnResolveDocType()")
			}
		} Else {
			$$$sysTRACE("No match or default DocType found for type name '"_tNameFound_"' in DocSchemaCategory list '"_tAcceptTypes_"'; calling OnResolveDocType()")
		}
	} Else {
		$$$sysTRACE("Accepted document with DocType='"_tDocType_"'; calling OnResolveDocType()")
	}
	Set ttDocType=tDocType  If ..OnResolveDocType(pDoc,.ttDocType) {
		Set tDocType=$Get(ttDocType)
		$$$sysTRACE("OnResolveDocType returned DocType="_tDocType)
	}
	Quit tDocType
]]></Implementation>
</Method>

<Method name="reportReply">
<FormalSpec><![CDATA[pOriginalDoc:EnsLib.EDI.Document,pReplyCode:%String="",&pSC:%Status]]></FormalSpec>
<ReturnType>EnsLib.EDI.Document</ReturnType>
<Implementation><![CDATA[
	If $IsObject(pReplyCode) {
		Set tReplyDoc=pReplyCode, pSC=$$$OK
		$$$sysTRACE("Reporting reply document "_tReplyDoc_" for document "_pOriginalDoc_$S('$IsObject(pOriginalDoc):"",1:" / "_pOriginalDoc.%Id()))
	}
	If ""'=..SearchTableClass && $IsObject(tReplyDoc) && ..#IndexReplies {
		Set tSCStore=$zobjclassmethod(..SearchTableClass,"IndexDoc",tReplyDoc)
		If $$$ISERR(tSCStore) $$$LOGWARNING("Failed to construct SearchTable entries for reply document "_tReplyDoc_" / "_tReplyDoc.%Id()_" with DocType='"_tReplyDoc.DocType_"' using class '"_..SearchTableClass_"' "_$$$StatusDisplayString(tSCStore))
	}
	Quit:""=tReplyDoc $$$NULLOREF
	Do ..SendReply(tReplyDoc, pOriginalDoc)
	Quit $$$NULLOREF ; default behavior is not to return the reply doc from OnProcessInput()
]]></Implementation>
</Method>

<Method name="SendReply">
<FormalSpec>pReplyDocument:EnsLib.EDI.Document,pOriginalDoc:EnsLib.EDI.Document=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$EnsError($$$EnsErrGeneral, "Service does not support Reply; Document "_pReplyDocument)
]]></Implementation>
</Method>

<Method name="OnDocumentEnd">
<Description>
Called by the Parser at the end of a document</Description>
<FormalSpec>pDocument:EnsLib.EDI.Document,pSource:%String,pStatus:%Status</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK  Set:'$D(pStatus) pStatus=tSC
	Quit:..%PreserveSession>1 tSC ; don't let Service process the document; we're in ImportFrom...()
	If '..%PreserveSession { Set ..%SessionId=""  Kill $$$JobSessionId }
	Set:"HPRIM.EDI.E1238.Adapter.TCPAdapter"=..#ADAPTER pDocument.Source=..Adapter.OutQueueName_$C(13,10)_pDocument.Source
	Set tSC=..standardOnProcessInput(pDocument,.tDocOut)
	If $$$ISERR(tSC) && $$$StatusEquals(tSC,$$$EnsErrGeneral) Set pStatus=$$$ADDSC(pStatus,tSC) // !!! quit on fatal errors only
	Quit pStatus
]]></Implementation>
</Method>

<Method name="GetRequestClassList">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>OnProcessInput</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSignature=$$$comMemberKeyGet(%class.Name,$$$cCLASSmethod,"standardOnProcessInput",$$$cMETHformalspecparsed)
	Set tClass=$lg($lg(tSignature,1),2)
	Set tSignature=$$$comMemberKeyGet(%class.Name,$$$cCLASSmethod,"OnProcessInput",$$$cMETHformalspecparsed)
	Set tClass=tClass_""","""_$lg($lg(tSignature,1),2)
	Do %code.WriteLine(" Quit $lb("""_tClass_""")")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetResponseClassList">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pRequest:%String=""</FormalSpec>
<GenerateAfter>OnProcessInput</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSignature=$$$comMemberKeyGet(%class.Name,$$$cCLASSmethod,"standardOnProcessInput",$$$cMETHformalspecparsed)
	Set tRequest1=$lg($lg(tSignature,1),2)
	Set tClass1=$lg($lg(tSignature,2),2)
	Set tSignature=$$$comMemberKeyGet(%class.Name,$$$cCLASSmethod,"OnProcessInput",$$$cMETHformalspecparsed)
	Set tRequest2=$lg($lg(tSignature,1),2)
	Set tClass2=$lg($lg(tSignature,2),2)

	Set tClass12=tClass1_$S(tClass1=tClass2:"",1:""","""_tClass2)
	If tRequest1=tRequest2 {
		Set (tClass1,tClass2)=tClass12
	}
	Do %code.WriteLine(" Quit:pRequest="""" $lb("""_tClass12_""")")
	Do %code.WriteLine(" Quit:pRequest="""_tRequest1_""" $lb("""_tClass1_""")")
	Do %code.WriteLine(" Quit:pRequest="""_tRequest2_""" $lb("""_tClass2_""")")
	Do %code.WriteLine(" Quit $lb("""")")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnGetConnections">
<Description>
Return an array of connections for drawing lines on the config diagram</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pArray:%String,pItem:Ens.Config.Item</FormalSpec>
<Implementation><![CDATA[
	Do ##super(.pArray,pItem)
	If pItem.GetModifiedSetting("TargetConfigNames",.tValue) {
		For i=1:1:$L(tValue,",") { Set tOne=$ZStrip($P(tValue,",",i),"<>W")  Continue:""=tOne  Set pArray(tOne)="" }
	}
]]></Implementation>
</Method>

<Method name="IOLogDiscard">
<Description>
Add discarded characters to IO Archive</Description>
<FormalSpec>pSC:%Status,pNote:%String,pDiscard:%GlobalCharacterStream</FormalSpec>
<Implementation><![CDATA[
	Set tIOLogEntry = ..IOLogEntry, ..IOLogEntry=$$$NULLOREF ; Save a separate entry for the unexpected input
	$$$NEWINIOLOGENTRY(pSC,pNote,pDiscard)
	$$$CLOSEIOLOGENTRY($$$OK,"",$$$NULLOREF)
	Set ..IOLogEntry = tIOLogEntry
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Service.TCPService">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>HPRIM.EDI.E1238.Service.Standard</Super>
<System>4</System>
<TimeChanged>64176,43294.366872</TimeChanged>
<TimeCreated>59318,79308.969</TimeCreated>

<Parameter name="ADAPTER">
<Default>HPRIM.EDI.E1238.Adapter.TCPAdapter</Default>
</Parameter>

<Method name="OnInit">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##super()  Quit:$$$ISERR(tSC) tSC
	Set ..%Parser.StartTimeout=..Adapter.ReadTimeout, ..%Parser.ReadTimeout=..Adapter.ReadTimeout
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnProcessInput">
<FormalSpec>pInput:%RegisteredObject,*pDocReceived:HPRIM.EDI.E1238.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..%Parser.ResetPosition()
	Set tFrameNum=..Adapter.%FrameNum
	Set tSC=..%Parser.ParseIOStream(..Adapter.Socket,.pDocReceived,.tFrameNum)
	Set ..Adapter.%FrameNum=tFrameNum
	Quit tSC
]]></Implementation>
</Method>

<Method name="standardOnProcessInput">
<FormalSpec>pDocIn:HPRIM.EDI.E1238.Document,*pDocOut:HPRIM.EDI.E1238.Document</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'$IsObject(..Adapter.%SyncReplyHeader) ##super(.pDocIn,.pDocOut)

	#; If a sync response is pending, use this received input object to satisfy it.
	Set tSC=$$$OK, pDocOut=$$$NULLOREF
	$$$ASSERT($$$IsdefObject(pDocIn) && pDocIn.%IsA("HPRIM.EDI.E1238.Document"))
	$$$sysTRACE("Got Document "_pDocIn_" / "_pDocIn.%Id())
	#; get accepted doc, resolve DocType
	Set tSCVal=..resolveAndIndex(pDocIn)
	Set tResponse=$$$NULLOREF
	If $$$ISOK(tSC)&&$$$ISOK(tSCVal) {
		Set pDocIn.IsMutable=0
		Set tSC = ..Adapter.%SyncReplyHeader.NewResponseMessage(.tResponseHeader,pDocIn)
		If $$$ISERR(tSC) {
			Set tSC = ..Adapter.%SyncReplyHeader.NewErrorResponse(.tResponseHeader,tSC)
		} Else {
			Set ..Adapter.%SyncReplyHeader=$$$NULLOREF
			$$$SyncCommitSet(tSyncCommit)
			Set tSC = ##class(Ens.Queue).EnQueue(tResponseHeader)
			$$$SyncCommitClear(tSyncCommit)
		}
		Quit tSC
	} Else { ; not forwarding due to error or no target
		If $Case(..ReplyMode,"Never":0,:1) {
			If $$$ISOK(tSC)&&$$$ISOK(tSCVal) {
				$$$SyncCommitSet(tSyncCommit)
				Set pDocIn.IsMutable=0, tSC=pDocIn.%Save() ; save the document because we're going to reply to it.
				$$$SyncCommitClear(tSyncCommit)
				If $$$ISERR(tSC) {
					$$$LOGERROR("Failed to save document "_pDocIn_" / "_pDocIn.%Id()_" : "_$$$StatusDisplayString(tSC))
				}
			}
			$$$sysTRACE("Returning reply but not forwarding document "_pDocIn_"/"_pDocIn.%Id()_$S($$$ISERR(tSC):" status "_$$$StatusDisplayString(tSC),1:""))
			Set tSC=$$$ADDSC(tSC,tSCVal)
			Set pDocOut=..reportReply(pDocIn,,.tSC)
		} Else {
			$$$sysTRACE("Not returning reply for document "_pDocIn_"/"_pDocIn.%Id()_"; ReplyMode="_..ReplyMode_$S($$$ISERR(tSC):" status "_$$$StatusDisplayString(tSC),1:""))
		}
	}
	If $IsObject(tResponse) {
		Set pDocOut=..reportReply(pDocIn,tResponse,.tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendReply">
<FormalSpec>pReplyDocument:EnsLib.EDI.Document,pOriginalDoc:EnsLib.EDI.Document=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Enqueue it to our own adapter to send when channel is available
	Set tSC = ##class(Ens.MessageHeader).NewRequestMessage(.tRequestHeader,pReplyDocument,..%SessionId) Quit:$$$ISERR(tSC) tSC
	Set tRequestHeader.SourceConfigName = ..%ConfigName
	Set tRequestHeader.TargetConfigName = ..%ConfigName
	Set tRequestHeader.SourceBusinessType = $$$eHostTypeService
	Set tRequestHeader.TargetBusinessType = $$$eHostTypeService
	Set tRequestHeader.TargetQueueName = ..Adapter.OutQueueName
	Set tRequestHeader.Description = "ASTM ""reply"" to "_pOriginalDoc.%Id()
	Quit ##class(Ens.Queue).EnQueue(tRequestHeader)
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Util.FormatHTML">
<Abstract>1</Abstract>
<IncludeCode>HPRIME1238</IncludeCode>
<Super>EnsLib.EDI.IOFormatInterface</Super>
<System>4</System>
<TimeChanged>64175,60576</TimeChanged>
<TimeCreated>59318,79308.929</TimeCreated>

<Method name="OutputDocument">
<Description>
Return 1 if we took care of the whole document or got an error. Returning 0 means the caller will continue doing component segments as usual.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocObj:EnsLib.EDI.Document,*pStatus:%Status,pIOStream:%IO.I.CharacterStream,pSeparators:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set:""=pSeparators pSeparators=pDocObj.Separators  
	Set:""=pSeparators pSeparators=$$$E1238DefSeparators
	Do pIOStream.WriteLine(
	"<table border=""0"" cellspacing=""0"" cellpadding=""0"" cols=""2"" width=""100%""><tr><td align=""center""><div class=""Text"" style=""margin: 3px;"">",,.pStatus)  Quit:$$$ISERR(pStatus) 1
	If ""'=pDocObj.DocType {
		Do:""=pDocObj.BuildMapStatus||'$D($$$vaMobj(pDocObj,"runtimePath")) pDocObj.BuildMap()
		Set tDesc=##class(HPRIM.EDI.E1238.Schema).GetDescription("DS:"_pDocObj.DocType)
		Do pIOStream.WriteLine("E1238 <b>"_$ZCVT(pDocObj.Name,"O","HTML")_"</b> document - Id = <b>"_pDocObj.%Id()_"</b>, DocType = '<a"_$S(""=tDesc:"",1:" title='"_$ZCVT(tDesc,"O","HTML")_"'")_..getDocLink(pDocObj.DocType)_"><b>"_$ZCVT(pDocObj.DocType,"O","HTML")_"</b></a>'"_
			"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_$S(""=tDesc:"", 1:"'<b><i>"_$ZCVT(tDesc,"O","HTML")_"</i></b>', ")_"<b>"_pDocObj.SegCount_"</b> Segments",,.pStatus)  Quit:$$$ISERR(pStatus) 1
		If $$$ISERR(pDocObj.BuildMapStatus) {
			Set tErr=$ZCVT($$GetOneErrorText^%apiOBJ(pDocObj.BuildMapStatus),"O","HTML")
			Do pIOStream.WriteLine("<br>&nbsp;&nbsp;&nbsp;BuildMapStatus = '<b>"_tErr_"</b>'",,.pStatus)  Quit:$$$ISERR(pStatus) 1
			For i=2:1 { Set tErr=$$GetOneErrorText^%apiOBJ(pDocObj.BuildMapStatus,i)  Quit:""=tErr
				Do pIOStream.WriteLine("<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'"_$ZCVT(tErr,"O","HTML")_"'",,.pStatus)  Quit:$$$ISERR(pStatus)
			} Quit:$$$ISERR(pStatus) 1
		}
	} Else {
		Do pIOStream.WriteLine("E1238 <b>"_$ZCVT(pDocObj.Name,"O","HTML")_"</b> document - Id = <b>"_pDocObj.%Id()_"</b>, DocType = <b>''</b>, <b>"_pDocObj.SegCount_"</b> Segments",,.pStatus)  Quit:$$$ISERR(pStatus) 1
	}
	Do pIOStream.WriteLine("</div></td></tr></table>",,.pStatus)  Quit:$$$ISERR(pStatus) 1
	Do:'$D($$$vaMobj(pDocObj,"runtimeIndex"))&&$D($$$vaMobj(pDocObj,"runtimePath")) pDocObj.buildRuntimeIndexFromPath()
	Set tCnt=$G($$$vaMobj(pDocObj,"runtimeIndex"))
	If tCnt<=0 { Do pIOStream.WriteLine("<center>No Segments</center>",,.pStatus)  Quit:$$$ISERR(pStatus) 1 }
	Else {
		Do pIOStream.WriteLine("<table class=""EDIDocumentTable"" BORDER=""0"" CELLSPACING=""0"" CELLPADDING=""0"">",,.pStatus)  Quit:$$$ISERR(pStatus) 1
		For i=1:1:tCnt {
			If i>300&&(i<=(tCnt-100)) {
				If i=301 {
					Do pIOStream.WriteLine("<TR CLASS=""EDIDocumentTableRow""><TD CLASS=""EDIDocumentTableExpandor"">&nbsp;</TD>",,.pStatus)  Quit:$$$ISERR(pStatus)
					Do pIOStream.WriteLine("<td class='EDIDocumentTableSegnum'>....&nbsp;</td><td class='EDIDocumentTableSegid' SegID='....'> </td>",,.pStatus)  Quit:$$$ISERR(pStatus)
					Do pIOStream.WriteLine("<td class='EDIDocumentTableSegname'>&nbsp;</td>",,.pStatus)  Quit:$$$ISERR(pStatus)
					Do pIOStream.WriteLine("<td>Segments 301 to "_(tCnt-100)_" not shown ...</td></TR>",,.pStatus)  Quit:$$$ISERR(pStatus)
				}
				Continue
			}
			Set tPath=$G($$$vaMobja(pDocObj,"bidirectionalLink",i),i)
			Set seg=pDocObj.getSegmentByIndex(i)
			Do pIOStream.WriteLine("<TR CLASS=""EDIDocumentTableRow""><TD CLASS=""EDIDocumentTableExpandor"">&nbsp;</TD>",,.pStatus)  Quit:$$$ISERR(pStatus)
			Do ..OutputSegment(seg,.tSC,pIOStream,pSeparators,i,tPath,pDocObj)  Quit:$$$ISERR(tSC)
			Do pIOStream.WriteLine("</TR>",,.pStatus)  Quit:$$$ISERR(pStatus)
			Do pDocObj.commitSegmentByIndex(i)
		}
		Do pIOStream.WriteLine("</table>",,.pStatus)  Quit:$$$ISERR(pStatus) 1
	}
	If $$$ISERR(tSC) Do pIOStream.WriteLine($ZCVT($$$StatusDisplayString(tSC),"O","HTML"),,.pStatus)  Set pStatus=$$$ADDSC(tSC,pStatus)
	Quit 1
]]></Implementation>
</Method>

<Method name="OutputDocumentEnd">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocObj:EnsLib.EDI.Document,*pStatus:%Status,pIOStream:%IO.I.CharacterStream,pSeparators:%String</FormalSpec>
<Implementation><![CDATA[
	Set pStatus=$$$OK
	Quit ; no return value
]]></Implementation>
</Method>

<Method name="OutputSegment">
<Description>
Return 1 if we took care of the segment or got an error. Returning 0 means the caller will output the segment as usual.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSegObj:EnsLib.EDI.Segment,*pStatus:%Status,pIOStream:%IO.I.CharacterStream,pSeparators:%String,pSegNum:%String,pSegPath:%String,pParentDoc:EnsLib.EDI.Document</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set:""=$G(pSeparators) pSeparators=pSegObj.Separators
	Set tFullLen=pSegObj.FullSize
	Do pSegObj.decompose()
	Set tName=pSegObj.Name, tFS=$ZCVT($$$FLDSEP(pSeparators),"O","HTML"), tRS=$ZCVT($$$REPSEP(pSeparators),"O","HTML"), tCS=$ZCVT($$$COMSEP(pSeparators),"O","HTML")
	Set:""=tName tName="x"
	Set tDocType=pSegObj.DocType
	Set pStatus=..outputHTMLStart(pIOStream,pSegNum,pSegPath,pSegObj.ID,tName,tDocType,tFullLen,$S($IsObject(pParentDoc):pParentDoc.DocType,1:""))  Quit:$$$ISERR(pStatus) 1
	Set tReplaceSpec(" ")="&nbsp;"
	Set tReplaceSpec($C(9))="\t"
	Set tReplaceSpec($C(13))="\r"
	Set tReplaceSpec($C(10))="\n"
	Set iCat=$P(tDocType,":"), iSeg=$P(tDocType,":",2)
	If ""=iCat||(""=iSeg) {
		Set iList=""
	} Else {
		Set iList=$G($$$vaSchemaGbl(iCat,"SS",iSeg))
		Set pStatus=##class(HPRIM.EDI.E1238.Schema).getFieldsContentArray(.tContents,"source",iCat,iSeg,0)
	}
	Set iCnt=pSegObj.GetValueAt("*",pSeparators)
	If iCnt<1 { Do pIOStream.WriteLine("<td class='EDISegmentsTableEmptyfield'>&nbsp</td>",,.pStatus)  Quit:$$$ISERR(pStatus) 1 }
	Else { For i=1:1:iCnt {
		Set iN=$ZCVT($P($E($G(tContents(i,"name"),":"_i),2,*),"("),"O","HTML")
		Set iAttrs=$LG(iList,i), iDT=$LG(iAttrs,1), iSym=$LG(iAttrs,2), iRep=$LG(iAttrs,3), iLen=$LG(iAttrs,4), isRep=$LG(iAttrs,6)
		Set:'iRep&&isRep iRep=1
		Set tAttr=$S(iRep>1:iRep,1:"")_iSym_$S(iLen:"("_iLen_")",1:"")
		If ""'=iDT {
			Set cCat=$P(iDT,":"),cTyp=$P(iDT,":",2)
			Set cList=$G($$$vaSchemaGbl(cCat,"DS",cTyp))
		}		
		If $Case(tName,"H":1,:0) && (i<=2) {
			Do pIOStream.WriteLine("<td nowrap class='EDISegmentsTableValue'><a title='"_i_" / "_iN_$S(""=tAttr:"",1:" / "_tAttr)_"'"_..getSegLink(tDocType,i)_">"_$ZCVT(pSegObj.GetValueAt(i,pSeparators),"O","HTML")_"</a></td>",,.pStatus)  Quit:$$$ISERR(pStatus)
			Continue
		} Else { Do pIOStream.WriteLine("<td class='EDISegmentsTableSeparator'>"_tFS_"</td>",,.pStatus)  Quit:$$$ISERR(pStatus) }
		If ""=pSegObj.GetValueAt(i) Do pIOStream.WriteLine("<td class='EDISegmentsTableEmptyfield'><a title='"_i_" / "_iN_$S(""=tAttr:"",1:" / "_tAttr)_"'"_..getSegLink(tDocType,i)_">&nbsp;&middot;</a></td>",,.pStatus)  Quit:$$$ISERR(pStatus)  Continue
		Set rCnt=pSegObj.GetValueAt(i_"(*)")
		Set rF=1  For r=1:1:rCnt {
			Set rN=iN,rpN=iN,rAlias=i,rpAlias=i
			If rCnt>1||iRep { Set rp=r_$S(rCnt>iRep&&(iRep'=1):"*",1:"")
				Set rN=rN_"("_r_")", rpN=rN_"("_rp_")"
				Set rAlias=rAlias_"("_r_")", rpAlias=rAlias_"("_rp_")"
			}
			If rF { Set rF=0 } Else { Do pIOStream.WriteLine("<td class='EDISegmentsTableSeparator'>"_tRS_"</td>",,.pStatus)  Quit:$$$ISERR(pStatus) }
			
			Set cCnt=pSegObj.GetValueAt(i_"("_r_").*")
			Set cF=1  For c=1:1:cCnt {
				Set cN=rN,cpN=rpN,cAlias=rAlias,cpAlias=rpAlias  If ""'=iDT||(cCnt>1) {
					Set cN=cN_"."_$ZCVT($P($G(tContents(i,c,"name"),c),"("),"O","HTML")
					Set cpN=cpN_"."_$ZCVT($P($G(tContents(i,c,"name"),c),"("),"O","HTML")
					Set cAlias=cAlias_"."_c
					Set cpAlias=cpAlias_"."_c
				}
				Set cDT=$S(""=iDT:"",1:$LG(cList,i))
				If cF { Set cF=0 } Else { Do pIOStream.WriteLine("<td class='EDISegmentsTableSeparator'>"_tCS_"</td>",,.pStatus)  Quit:$$$ISERR(pStatus) }
				
				Set tVal=pSegObj.GetValueAt(cAlias,pSeparators)
				If ""=tVal Do pIOStream.WriteLine("<td class='EDISegmentsTableEmptyfield'><a title='"_$S(cpAlias=cpN:"",1:cpAlias_" / ")_cpN_$S(""=tAttr:"",1:" / "_tAttr)_"'"_..getSegLink(tDocType,i)_">&nbsp;&middot;</a></td>",,.pStatus)  Quit:$$$ISERR(pStatus)  Continue
				Do pIOStream.Write("<td nowrap class='EDISegmentsTableValue'><a title='"_$S(cpAlias=cpN:"",1:cpAlias_" / ")_cpN_$S(""=tAttr:"",1:" / "_tAttr)_"'"_..getSegLink(tDocType,i)_">",,.pStatus)  Quit:$$$ISERR(pStatus)
				Set:$L(tVal)>2000 tVal=$E(tVal,1,2000)_" ..."
				While ""'=tVal { Set tPiece=$E(tVal,1,1000), tVal=$E(tVal,1001,*) Do pIOStream.Write($$replaceArray^EnsUtil($ZCVT(tPiece,"O","HTML"),.tReplaceSpec),,.pStatus)  Quit:$$$ISERR(pStatus) }
				Do pIOStream.WriteLine("</a></td>",,.pStatus)  Quit:$$$ISERR(pStatus)
			} Quit:$$$ISERR(pStatus)
		} Quit:$$$ISERR(pStatus)
	} Quit:$$$ISERR(pStatus) 1 }
	Set pStatus=..outputHTMLEnd(pIOStream)
	Quit 1
]]></Implementation>
</Method>

<Method name="outputChildLinks">
<Description>
This is ASTM so we have no child documents.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.I.CharacterStream,pSegObj:EnsLib.EDI.Segment,pDocsRefParent,tTypeName</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="outputHTMLStart">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.I.CharacterStream,pSegNum,pSegPath,pID,pName,pDocType,pFullLen,pMsgStructure</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tDesc=$S(""=pDocType:"", 1:##class(HPRIM.EDI.E1238.Schema).GetDescription("SS:"_pDocType))
	Set len=$S(pFullLen<=2000:"",1:" (len="_pFullLen_")")
	Do pIOStream.WriteLine(
	"<td class='EDIDocumentTableSegnum'>"_(pSegNum)_"&nbsp;</td><td class='EDIDocumentTableSegid' SegID='"_(pID)_"'>"_($S(""=pID:"*",1:"&nbsp;"))_"</td>"_
	"<td class='EDIDocumentTableSegname'>"_
		"<a title='"_$S(pSegNum=pSegPath&&(""'=pDocType):"SS:"_pDocType, 1:$ZCVT(pSegPath_$S(""=tDesc:"", 1:" - "_tDesc),"O","HTML"))_len_"'"_..getSegLink(pDocType,,$S(pSegNum=pSegPath&&(""'=pDocType):"", 1:$ZCVT(pSegPath,"O","HTML")),$ZCVT(pMsgStructure,"O","HTML"))_">"_pName_
	"</a></td><td><table class='EDISegmentsTable'><tr>",,.tSC)
	Quit tSC
]]></Implementation>
</Method>

<Method name="linkParents">
<Description>
This is ASTM so we have no parent documents.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocObj</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ""
]]></Implementation>
</Method>

<Method name="getSegLink">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocType,pAnchor="",pPath="",pMsgStructure=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Quit:""=pDocType||'##class(HPRIM.EDI.E1238.Schema).ElementExists("SS:"_pDocType) ""
	Quit " href='"_##class(%CSP.Page).Link("E1238/E1238SchemaSegmentStructure.csp?SS=SS:"_$$$URLENCODE(pDocType)_$S(""=pPath:"",1:"&PATH="_$$$URLENCODE(pPath))_$S(""=pMsgStructure:"",1:"&MS="_$$$URLENCODE(pMsgStructure))_$S(""=pAnchor:"",1:"#"_pAnchor))_"' target='_blank'"
]]></Implementation>
</Method>

<Method name="getDocLink">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocType</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Quit:""=pDocType||'##class(HPRIM.EDI.E1238.Schema).ElementExists("DS:"_pDocType) ""
	Quit " href='"_##class(%CSP.Page).Link("E1238/E1238SchemaDocumentStructure.csp?DS=DS:"_$$$URLENCODE(pDocType))_"' target='_blank'"
]]></Implementation>
</Method>

<Method name="outputHTMLEnd">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.I.CharacterStream</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do pIOStream.WriteLine("</tr></table></td>",,.tSC)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="HPRIM.EDI.E1238.Util.FormatHTMLZen">
<Abstract>1</Abstract>
<IncludeCode>HPRIME1238</IncludeCode>
<Super>EnsLib.EDI.IOFormatInterface</Super>
<System>4</System>
<TimeChanged>64175,60576</TimeChanged>
<TimeCreated>59318,79308.929</TimeCreated>

<Method name="OutputDocument">
<Description>
Return 1 if we took care of the whole document or got an error. Returning 0 means the caller will continue doing component segments as usual.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocObj:EnsLib.EDI.Document,*pStatus:%Status,pIOStream:%IO.I.CharacterStream,pSeparators:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set tVDoc = $ZCVT($$$Text("E1238","EDIDocumentView"),"O","HTML")
	Set tDoc = $ZCVT($$$Text("Document","EDIDocumentView"),"O","HTML")
	Set tId = $ZCVT($$$Text("Id","EDIDocumentView"),"O","HTML")
	Set tType = $ZCVT($$$Text("DocType","EDIDocumentView"),"O","HTML")
	Set tSeg = $ZCVT($$$Text("Segments","EDIDocumentView"),"O","HTML")
	Set tSegNo = $ZCVT($$$Text("No Segments","EDIDocumentView"),"O","HTML")
	Set tBMS = $ZCVT($$$Text("Build Map Status","EDIDocumentView"),"O","HTML")
	Set:""=pSeparators pSeparators=pDocObj.Separators  
	Set:""=pSeparators pSeparators=$$$E1238DefSeparators
	Do pIOStream.WriteLine(
	"<table border=""0"" cellspacing=""0"" cellpadding=""0"" nowrap width=""1200px""><tr><td align=""left""><div style=""font-size:9pt; margin: 3px;"">",,.pStatus)  Quit:$$$ISERR(pStatus) 1
	If ""'=pDocObj.DocType {
		Do:""=pDocObj.BuildMapStatus||'$D($$$vaMobj(pDocObj,"runtimePath")) pDocObj.BuildMap()
		Set tDesc=##class(HPRIM.EDI.E1238.Schema).GetDescription("DS:"_pDocObj.DocType)
		Do pIOStream.WriteLine(
			tVDoc_" <b>"_$ZCVT(pDocObj.Name,"O","HTML")_"</b> "_tDoc_" - "_tId_" <b>"_pDocObj.%Id()_"</b>, "_
			tType_" = '<a"_$S(""=tDesc:"",1:" title='"_$ZCVT(tDesc,"O","HTML")_"'")_
			..getDocLink(pDocObj.DocType)_"><b>"_$ZCVT(pDocObj.DocType,"O","HTML")_"</b></a>'"_
			"<br>"_
			$S(""=tDesc:"", 1:"'<b><i>"_$ZCVT(tDesc,"O","HTML")_"</i></b>', ")_
			"<b>"_pDocObj.SegCount_"</b> "_tSeg,,.pStatus)  Quit:$$$ISERR(pStatus) 1
		If $$$ISERR(pDocObj.BuildMapStatus) {
			Set tErr=$ZCVT($$GetOneErrorText^%apiOBJ(pDocObj.BuildMapStatus),"O","HTML")
			Do pIOStream.WriteLine("<br>"_tBMS_" = '<b>"_tErr_"</b>'",,.pStatus)  Quit:$$$ISERR(pStatus) 1
			For i=2:1 { Set tErr=$$GetOneErrorText^%apiOBJ(pDocObj.BuildMapStatus,i)  Quit:""=tErr
				Do pIOStream.WriteLine("<br>'"_$ZCVT(tErr,"O","HTML")_"'",,.pStatus)  Quit:$$$ISERR(pStatus)
			} Quit:$$$ISERR(pStatus) 1
		}
	} Else {
		Do pIOStream.WriteLine(
			tVDoc_" <b>"_$ZCVT(pDocObj.Name,"O","HTML")_"</b> "_tDoc_" - "_tId_" <b>"_pDocObj.%Id()_"</b>, "_
			tType_" = <b>''</b>, <b>"_pDocObj.SegCount_"</b> "_tSeg,,.pStatus)  Quit:$$$ISERR(pStatus) 1
	}
	Do pIOStream.WriteLine("</div></td></tr></table>",,.pStatus)  Quit:$$$ISERR(pStatus) 1
	Do:'$D($$$vaMobj(pDocObj,"runtimeIndex"))&&$D($$$vaMobj(pDocObj,"runtimePath")) pDocObj.buildRuntimeIndexFromPath()
	Set tCnt=$G($$$vaMobj(pDocObj,"runtimeIndex"))
	If tCnt<=0 { Do pIOStream.WriteLine("<center>"_tSegNo_"</center>",,.pStatus)  Quit:$$$ISERR(pStatus) 1 }
	Else {
		Do pIOStream.WriteLine("<table class=""EDIDocumentTable"" BORDER=""0"" CELLSPACING=""0"" CELLPADDING=""0"">",,.pStatus)  Quit:$$$ISERR(pStatus) 1
		For i=1:1:tCnt {
			If i>300&&(i<=(tCnt-100)) {
				If i=301 {
					Do pIOStream.WriteLine("<TR CLASS=""EDIDocumentTableRow""><TD CLASS=""EDIDocumentTableExpandor"">&nbsp;</TD>",,.pStatus)  Quit:$$$ISERR(pStatus)
					Do pIOStream.WriteLine("<td class='EDIDocumentTableSegnum'>....&nbsp;</td><td class='EDIDocumentTableSegid' SegID='....'> </td>",,.pStatus)  Quit:$$$ISERR(pStatus)
					Do pIOStream.WriteLine("<td class='EDIDocumentTableSegname'>&nbsp;</td>",,.pStatus)  Quit:$$$ISERR(pStatus)
					Set tCount = $ZCVT($$$FormatText($$$Text("Segments 301 to %1 not shown ...","EDIDocumentView"),tCnt-100),"O","HTML")
					Do pIOStream.WriteLine("<td>"_tCount_"</td></TR>",,.pStatus)  Quit:$$$ISERR(pStatus)
				}
				Continue
			}
			Set tPath=$G($$$vaMobja(pDocObj,"bidirectionalLink",i),i)
			Set seg=pDocObj.getSegmentByIndex(i)
			Do pIOStream.WriteLine("<TR CLASS=""EDIDocumentTableRow""><TD CLASS=""EDIDocumentTableExpandor"">&nbsp;</TD>",,.pStatus)  Quit:$$$ISERR(pStatus)
			Do ..OutputSegment(seg,.tSC,pIOStream,pSeparators,i,tPath,pDocObj)  Quit:$$$ISERR(tSC)
			Do pIOStream.WriteLine("</TR>",,.pStatus)  Quit:$$$ISERR(pStatus)
			Do pDocObj.commitSegmentByIndex(i)
		}
		Do pIOStream.WriteLine("</table>",,.pStatus)  Quit:$$$ISERR(pStatus) 1
	}
	If $$$ISERR(tSC) Do pIOStream.WriteLine($ZCVT($$$StatusDisplayString(tSC),"O","HTML"),,.pStatus)  Set pStatus=$$$ADDSC(tSC,pStatus)
	Quit 1
]]></Implementation>
</Method>

<Method name="OutputDocumentEnd">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocObj:EnsLib.EDI.Document,*pStatus:%Status,pIOStream:%IO.I.CharacterStream,pSeparators:%String</FormalSpec>
<Implementation><![CDATA[
	Set pStatus=$$$OK
	Quit ; no return value
]]></Implementation>
</Method>

<Method name="OutputSegment">
<Description>
Return 1 if we took care of the segment or got an error. Returning 0 means the caller will output the segment as usual.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSegObj:EnsLib.EDI.Segment,*pStatus:%Status,pIOStream:%IO.I.CharacterStream,pSeparators:%String,pSegNum:%String,pSegPath:%String,pParentDoc:EnsLib.EDI.Document</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set:""=$G(pSeparators) pSeparators=pSegObj.Separators
	Set tFullLen=pSegObj.FullSize
	Do pSegObj.decompose()
	Set tName=pSegObj.Name, tFS=$ZCVT($$$FLDSEP(pSeparators),"O","HTML"), tRS=$ZCVT($$$REPSEP(pSeparators),"O","HTML"), tSS=$ZCVT($$$SSSEP(pSeparators),"O","HTML"), tCS=$ZCVT($$$COMSEP(pSeparators),"O","HTML")
	Set:""=tName tName="x"
	Set tDocType=pSegObj.DocType
	Set pStatus=..outputHTMLStart(pIOStream,pSegNum,pSegPath,pSegObj.ID,tName,tDocType,tFullLen,$S($IsObject(pParentDoc):pParentDoc.DocType,1:""))  Quit:$$$ISERR(pStatus) 1
	Set tReplaceSpec(" ")="&nbsp;"
	Set tReplaceSpec($C(9))="\t"
	Set tReplaceSpec($C(13))="\r"
	Set tReplaceSpec($C(10))="\n"
	Set iCat=$P(tDocType,":"), iSeg=$P(tDocType,":",2)
	If ""=iCat||(""=iSeg) {
		Set iList=""
	} Else {
		Set iList=$G($$$vaSchemaGbl(iCat,"SS",iSeg))
		Set pStatus=##class(HPRIM.EDI.E1238.Schema).getFieldsContentArray(.tContents,"source",iCat,iSeg,0)
	}
	Set iCnt=pSegObj.GetValueAt("*",pSeparators)
	If iCnt<1 { Do pIOStream.WriteLine("<td class='EDISegmentsTableEmptyfield'>&nbsp</td>",,.pStatus)  Quit:$$$ISERR(pStatus) 1 }
	Else { For i=1:1:iCnt {
		Set iN=$ZCVT($P($E($G(tContents(i,"name"),":"_i),2,*),"("),"O","HTML")
		Set iAttrs=$LG(iList,i), iDT=$LG(iAttrs,1), iSym=$LG(iAttrs,2), iRep=$LG(iAttrs,3), iLen=$LG(iAttrs,4), isRep=$LG(iAttrs,6)
		Set:'iRep&&isRep iRep=1
		Set tAttr=$S(iRep>1:iRep,1:"")_iSym_$S(iLen:"("_iLen_")",1:"")
		If ""'=iDT {
			Set cCat=$P(iDT,":"),cTyp=$P(iDT,":",2)
			Set cList=$G($$$vaSchemaGbl(cCat,"DS",cTyp))
		}		
		If $Case(tName,"H":1,:0) && (i<=2) {
			Do pIOStream.WriteLine("<td nowrap class='EDISegmentsTableValue'><a title='"_i_" / "_iN_$S(""=tAttr:"",1:" / "_tAttr)_"'"_..getSegLink(tDocType,i)_">"_$ZCVT(pSegObj.GetValueAt(i,pSeparators),"O","HTML")_"</a></td>",,.pStatus)  Quit:$$$ISERR(pStatus)
			Continue
		} Else { Do pIOStream.WriteLine("<td class='EDISegmentsTableSeparator'>"_tFS_"</td>",,.pStatus)  Quit:$$$ISERR(pStatus) }
		If ""=pSegObj.GetValueAt(i) Do pIOStream.WriteLine("<td class='EDISegmentsTableEmptyfield'><a title='"_i_" / "_iN_$S(""=tAttr:"",1:" / "_tAttr)_"'"_..getSegLink(tDocType,i)_">&nbsp;&middot;</a></td>",,.pStatus)  Quit:$$$ISERR(pStatus)  Continue
		Set rCnt=pSegObj.GetValueAt(i_"(*)")
		Set rF=1  For r=1:1:rCnt {
			Set rN=iN,rpN=iN,rAlias=i,rpAlias=i
			If rCnt>1||iRep { Set rp=r_$S(rCnt>iRep&&(iRep'=1):"*",1:"")
				Set rN=rN_"("_r_")", rpN=rN_"("_rp_")"
				Set rAlias=rAlias_"("_r_")", rpAlias=rAlias_"("_rp_")"
			}
			If rF { Set rF=0 } Else { Do pIOStream.WriteLine("<td class='EDISegmentsTableSeparator'>"_tRS_"</td>",,.pStatus)  Quit:$$$ISERR(pStatus) }
			
			Set cCnt=pSegObj.GetValueAt(i_"("_r_").*")
			Set cF=1  For c=1:1:cCnt {
				Set cN=rN,cpN=rpN,cAlias=rAlias,cpAlias=rpAlias  If ""'=iDT||(cCnt>1) {
					Set cN=cN_"."_$ZCVT($P($G(tContents(i,c,"name"),c),"("),"O","HTML")
					Set cpN=cpN_"."_$ZCVT($P($G(tContents(i,c,"name"),c),"("),"O","HTML")
					Set cAlias=cAlias_"."_c
					Set cpAlias=cpAlias_"."_c
				}
				Set cDT=$S(""=iDT:"",1:$LG(cList,i))
				If cF { Set cF=0 } Else { Do pIOStream.WriteLine("<td class='EDISegmentsTableSeparator'>"_tSS_"</td>",,.pStatus)  Quit:$$$ISERR(pStatus) }
				
				Set tVal=pSegObj.GetValueAt(cAlias,pSeparators)
				If ""=tVal Do pIOStream.WriteLine("<td class='EDISegmentsTableEmptyfield'><a title='"_$S(cpAlias=cpN:"",1:cpAlias_" / ")_cpN_$S(""=tAttr:"",1:" / "_tAttr)_"'"_..getSegLink(tDocType,i)_">&nbsp;&middot;</a></td>",,.pStatus)  Quit:$$$ISERR(pStatus)  Continue
				Do pIOStream.Write("<td nowrap class='EDISegmentsTableValue'><a title='"_$S(cpAlias=cpN:"",1:cpAlias_" / ")_cpN_$S(""=tAttr:"",1:" / "_tAttr)_"'"_..getSegLink(tDocType,i)_">",,.pStatus)  Quit:$$$ISERR(pStatus)
				Set:$L(tVal)>2000 tVal=$E(tVal,1,2000)_" ..."
				While ""'=tVal { Set tPiece=$E(tVal,1,1000), tVal=$E(tVal,1001,*) Do pIOStream.Write($$replaceArray^EnsUtil($ZCVT(tPiece,"O","HTML"),.tReplaceSpec),,.pStatus)  Quit:$$$ISERR(pStatus) }
				Do pIOStream.WriteLine("</a></td>",,.pStatus)  Quit:$$$ISERR(pStatus)
			} Quit:$$$ISERR(pStatus)
		} Quit:$$$ISERR(pStatus)
	} Quit:$$$ISERR(pStatus) 1 }
	Set pStatus=..outputHTMLEnd(pIOStream)
	Quit 1
]]></Implementation>
</Method>

<Method name="outputChildLinks">
<Description>
This is ASTM so we have no child documents.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.I.CharacterStream,pSegObj:EnsLib.EDI.Segment,pDocsRefParent,tTypeName</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="outputHTMLStart">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.I.CharacterStream,pSegNum,pSegPath,pID,pName,pDocType,pFullLen,pMsgStructure</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tDesc=$S(""=pDocType:"", 1:##class(HPRIM.EDI.E1238.Schema).GetDescription("SS:"_pDocType))
	Set len=$S(pFullLen<=2000:"",1:" (len="_pFullLen_")")
	Do pIOStream.WriteLine(
	"<td class='EDIDocumentTableSegnum'>"_(pSegNum)_"&nbsp;</td><td class='EDIDocumentTableSegid' SegID='"_(pID)_"'>"_($S(""=pID:"*",1:"&nbsp;"))_"</td>"_
	"<td class='EDIDocumentTableSegname'>"_
		"<a title='"_$S(pSegNum=pSegPath&&(""'=pDocType):"SS:"_pDocType, 1:$ZCVT(pSegPath_$S(""=tDesc:"", 1:" - "_tDesc),"O","HTML"))_len_"'"_..getSegLink(pDocType,,$S(pSegNum=pSegPath&&(""'=pDocType):"", 1:$ZCVT(pSegPath,"O","HTML")),$ZCVT(pMsgStructure,"O","HTML"))_">"_pName_
	"</a></td><td><table class='EDISegmentsTable'><tr>",,.tSC)
	Quit tSC
]]></Implementation>
</Method>

<Method name="linkParents">
<Description>
This is ASTM so we have no parent documents.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocObj</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ""
]]></Implementation>
</Method>

<Method name="getSegLink">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocType,pAnchor="",pPath="",pMsgStructure=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Quit:""=pDocType||'##class(HPRIM.EDI.E1238.Schema).ElementExists("SS:"_pDocType) ""
	Quit " href='"_##class(%CSP.Page).Link("EnsPortal.EDI.ASTM.SchemaSegmentStructure.zen?SS=SS:"_$$$URLENCODE(pDocType)_$S(""=pPath:"",1:"&PATH="_$$$URLENCODE(pPath))_$S(""=pMsgStructure:"",1:"&DS="_$$$URLENCODE(pMsgStructure))_$S(""=pAnchor:"",1:"#"_pAnchor))_"' target='_blank'"
]]></Implementation>
</Method>

<Method name="getDocLink">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocType</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Quit:""=pDocType||'##class(HPRIM.EDI.E1238.Schema).ElementExists("DS:"_pDocType) ""
	Quit " href='"_##class(%CSP.Page).Link("EnsPortal.EDI.ASTM.SchemaDocumentStructure.zen?DS=DS:"_$$$URLENCODE(pDocType))_"' target='_blank'"
]]></Implementation>
</Method>

<Method name="outputHTMLEnd">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.I.CharacterStream</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do pIOStream.WriteLine("</tr></table></td>",,.tSC)
	Quit tSC
]]></Implementation>
</Method>
</Class>




<Project name="HPRIM" LastModified="2016-09-15 18:12:14.11719">
  <Items>
    <ProjectItem name="HPRIM" type="PKG"></ProjectItem>
    <ProjectItem name="HPRIME1238.INC" type="MAC"></ProjectItem>
    <ProjectItem name="HPRIME1238Errors.INC" type="MAC"></ProjectItem>
  </Items>
</Project>


<Class name="HPRIM.prod.routeurHPRIMRoutingRule">
<Description>
</Description>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>64175,63983.141516</TimeChanged>
<TimeCreated>64175,62460.483737</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>EnsLib.MsgRouter.RuleAssist</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="EnsLib.MsgRouter.RoutingEngine" production="HPRIM.prod.test">
<ruleSet name="" effectiveBegin="" effectiveEnd="">
<send transform="HPRIM.transfo.test" target="HPRIM out"></send>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="HPRIM.prod.test">
<Super>Ens.Production</Super>
<TimeChanged>64176,65042.273223</TimeChanged>
<TimeCreated>64175,60071.751507</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="HPRIM.prod.test" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="HPRIM in" Category="" ClassName="HPRIM.EDI.E1238.Service.FileService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="FilePath">C:\data\HPRIM\in\</Setting>
    <Setting Target="Adapter" Name="FileSpec">*.hpr</Setting>
    <Setting Target="Adapter" Name="SemaphoreSpec">*.ok</Setting>
    <Setting Target="Host" Name="TargetConfigNames">routeurHPRIM</Setting>
    <Setting Target="Host" Name="DocSchemaCategory">HPRIM2.2</Setting>
  </Item>
  <Item Name="HPRIM out" Category="" ClassName="HPRIM.EDI.E1238.Operation.FileOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="Filename">%f_%Q.hpr</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\data\HPRIM\out\</Setting>
    <Setting Target="Host" Name="FileOK">1</Setting>
    <Setting Target="Host" Name="SearchTableClass">EnsLib.EDI.E1238.SearchTable</Setting>
    <Setting Target="Adapter" Name="Overwrite">1</Setting>
    <Setting Target="Host" Name="OKSpec">ok</Setting>
    <Setting Target="Host" Name="ASegmentsEnabled">1</Setting>
    <Setting Target="Host" Name="MaxSegmentSize">220</Setting>
  </Item>
  <Item Name="routeurHPRIM" Category="" ClassName="EnsLib.MsgRouter.RoutingEngine" PoolSize="0" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="Validation"></Setting>
    <Setting Target="Host" Name="BusinessRuleName">HPRIM.prod.routeurHPRIMRoutingRule</Setting>
    <Setting Target="Host" Name="FailureTimeout">-1</Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="HPRIM.transfo.test">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>64176,64289.229701</TimeChanged>
<TimeCreated>64175,62551.79954</TimeCreated>
<DependsOn>HPRIM.EDI.E1238.Document</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='HPRIM.EDI.E1238.Document' targetClass='HPRIM.EDI.E1238.Document' sourceDocType='HPRIM2.2:P' targetDocType='HPRIM2.2:P' create='copy' language='objectscript' >
<assign value='..ToUpper(source.{H})' property='target.{H}' action='set' />
</transform>
]]></Data>
</XData>
</Class>


<Routine name="HPRIME1238" type="INC" timestamp="64176,63854.849625"><![CDATA[
#; HPRIME1238.inc
#;
#Include EnsEDI
#Include HPRIME1238Errors

#; ASTM E1238 special TCP control character codes 
#define STX             $C(2)
#define ETX             $C(3)
#define EOT             $C(4)
#define ENQ             $C(5)
#define ACK             $C(6)
#define ETB             $C(23)

#define MapCtlChar(%c)  $Case(%c,$$$STX:"<STX>",$$$ETX:"<ETX>",$$$EOT:"<EOT>",$$$ENQ:"<ENQ>",$$$ACK:"<ACK>",$$$ETB:"<ETB>",$C(13):"<CR>",$C(10):"<LF>",:"<"_$A(%c)_">")
#define MapCtlChars(%s) ##class(HPRIM.EDI.E1238.Parser).mapCtlChars(%s)
 
#; LVD array macros
#define vaSchemaGbl       ^HPRIM.E1238.Schema
#define vaSchemaDescGbl   ^HPRIM.E1238.Description
#define vaSegmentGbl      ^HPRIM.E1238.Segment
#define vaExtentGbl       ^HPRIM.EDI.E1238.DocumentD
#; Note: SchemaGbl macros are defined in EnsEDISEF
 
#ifndef LOCALMAPS
#define vaTempInstanceGbl ^CacheTemp.HPRIM.E1238
#endif
#;
#; 22 = Name MAXLEN
#define MAXSEGNAME 22
#define vaDataSegName(%segdata)        $P($E(%segdata,6,6+22-1),$$$FLDSEP(%segdata))
#define vaDataTypeName(%segdata)       $$$SEGELEM(%segdata,1)_$S("M"=$$$SEGELEM(%segdata,1):"-"_$$$SEGELEM(%segdata,3),1:"")
#define vaDataTypeVersion(%segdata)    $$$SEGELEM(%segdata,13)
#define vaDataDocIdentifier(%segdata)  $$$SEGELEM(%segdata,3)
 
#; return an 8 bit checksum value in 2 ascii hex chars
#define CHKSUM(%s)                $$$NUM($ZHex(+($ZCRC(%s,0)#256)),2)
 
#define FLDSEP(%s)                $E(%s,1)
#define SSSEP(%s)				  $E(%s,2)
#define REPSEP(%s)                $E(%s,3)
#define COMSEP(%s)                $E(%s,4)
#define ESCSEP(%s)                $E(%s,5)
 
#; Default Separator values
#define E1238DefFS  "|"
#define E1238DefSS "^"
#define E1238DefRS "~"
#define E1238DefESC "\"
#define E1238DefCS "&"
#define E1238DefSeparators  $$$E1238DefFS_$$$E1238DefSS_$$$E1238DefRS_$$$E1238DefESC_$$$E1238DefCS
 
 
#; Get stuff directly out of segment global
#define SEGELEM(%seg,%el)         $P(%seg,$$$FLDSEP(%seg),2+%el)
#define SEGIDELEM(%id,%el)        $$$SEGELEM($G($$$vaSegmentGbl(+%id)),%el)
#define SEGIDNAME(%id)            $$$SEGIDELEM(%id,0)
 
#; Enable all validation levels
#define ValidationFull            2

#; Ascii value of Start-Block marker character
#define E1238DefStartBlockAscii 11
 
#; Ascii value of End-Data marker character
#define E1238DefEndBlockAscii 28
 
#; Ascii value of End-Block marker character
#define E1238DefEndDataCRAscii 13
 
#; Ascii value of End-Segment marker character
#define E1238DefSegTerminatorAscii 13,10
 
#; For AckMode=Byte ACK
#define SingleByteAckAcceptAscii 6
 
#; For AckMode=Byte NACK
#define SingleByteAckErrorAscii 21

#; For long string support
#define E1238MaxReadLen		$S($G($$$EnsConfig("HL7-NoLongStrings")): 32760, 1: $$$MaxLocalLength - 5)
#define E1238MaxSegLen		$S($G($$$EnsConfig("HL7-NoLongStrings")): $$$MAXSEG, 1: $$$MaxLocalLength)
]]></Routine>


<Routine name="HPRIME1238Errors" type="INC" timestamp="63614,31171.329077"><![CDATA[
#define HPRIME1238ErrAckSeqNum  "<HPRIME1238>ErrAckSeqNum"
#define HPRIME1238ErrEndBlock   "<HPRIME1238>ErrEndBlock"
#define HPRIME1238ErrGeneral    "<HPRIME1238>ErrGeneral"
#define HPRIME1238ErrStartBlock "<HPRIME1238>ErrStartBlock"
]]></Routine>
</Export>
